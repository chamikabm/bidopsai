
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectDocument
 * 
 */
export type ProjectDocument = $Result.DefaultSelection<Prisma.$ProjectDocumentPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model WorkflowExecution
 * 
 */
export type WorkflowExecution = $Result.DefaultSelection<Prisma.$WorkflowExecutionPayload>
/**
 * Model AgentTask
 * 
 */
export type AgentTask = $Result.DefaultSelection<Prisma.$AgentTaskPayload>
/**
 * Model Artifact
 * 
 */
export type Artifact = $Result.DefaultSelection<Prisma.$ArtifactPayload>
/**
 * Model ArtifactVersion
 * 
 */
export type ArtifactVersion = $Result.DefaultSelection<Prisma.$ArtifactVersionPayload>
/**
 * Model KnowledgeBase
 * 
 */
export type KnowledgeBase = $Result.DefaultSelection<Prisma.$KnowledgeBasePayload>
/**
 * Model KnowledgeBaseDocument
 * 
 */
export type KnowledgeBaseDocument = $Result.DefaultSelection<Prisma.$KnowledgeBaseDocumentPayload>
/**
 * Model KnowledgeBasePermission
 * 
 */
export type KnowledgeBasePermission = $Result.DefaultSelection<Prisma.$KnowledgeBasePermissionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model AgentConfiguration
 * 
 */
export type AgentConfiguration = $Result.DefaultSelection<Prisma.$AgentConfigurationPayload>
/**
 * Model Integration
 * 
 */
export type Integration = $Result.DefaultSelection<Prisma.$IntegrationPayload>
/**
 * Model IntegrationLog
 * 
 */
export type IntegrationLog = $Result.DefaultSelection<Prisma.$IntegrationLogPayload>
/**
 * Model BidStatistics
 * 
 */
export type BidStatistics = $Result.DefaultSelection<Prisma.$BidStatisticsPayload>
/**
 * Model SubmissionRecord
 * 
 */
export type SubmissionRecord = $Result.DefaultSelection<Prisma.$SubmissionRecordPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectDocument`: Exposes CRUD operations for the **ProjectDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectDocuments
    * const projectDocuments = await prisma.projectDocument.findMany()
    * ```
    */
  get projectDocument(): Prisma.ProjectDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflowExecution`: Exposes CRUD operations for the **WorkflowExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowExecutions
    * const workflowExecutions = await prisma.workflowExecution.findMany()
    * ```
    */
  get workflowExecution(): Prisma.WorkflowExecutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentTask`: Exposes CRUD operations for the **AgentTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentTasks
    * const agentTasks = await prisma.agentTask.findMany()
    * ```
    */
  get agentTask(): Prisma.AgentTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artifact`: Exposes CRUD operations for the **Artifact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Artifacts
    * const artifacts = await prisma.artifact.findMany()
    * ```
    */
  get artifact(): Prisma.ArtifactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artifactVersion`: Exposes CRUD operations for the **ArtifactVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArtifactVersions
    * const artifactVersions = await prisma.artifactVersion.findMany()
    * ```
    */
  get artifactVersion(): Prisma.ArtifactVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeBase`: Exposes CRUD operations for the **KnowledgeBase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeBases
    * const knowledgeBases = await prisma.knowledgeBase.findMany()
    * ```
    */
  get knowledgeBase(): Prisma.KnowledgeBaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeBaseDocument`: Exposes CRUD operations for the **KnowledgeBaseDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeBaseDocuments
    * const knowledgeBaseDocuments = await prisma.knowledgeBaseDocument.findMany()
    * ```
    */
  get knowledgeBaseDocument(): Prisma.KnowledgeBaseDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeBasePermission`: Exposes CRUD operations for the **KnowledgeBasePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeBasePermissions
    * const knowledgeBasePermissions = await prisma.knowledgeBasePermission.findMany()
    * ```
    */
  get knowledgeBasePermission(): Prisma.KnowledgeBasePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentConfiguration`: Exposes CRUD operations for the **AgentConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentConfigurations
    * const agentConfigurations = await prisma.agentConfiguration.findMany()
    * ```
    */
  get agentConfiguration(): Prisma.AgentConfigurationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **Integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.IntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integrationLog`: Exposes CRUD operations for the **IntegrationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntegrationLogs
    * const integrationLogs = await prisma.integrationLog.findMany()
    * ```
    */
  get integrationLog(): Prisma.IntegrationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bidStatistics`: Exposes CRUD operations for the **BidStatistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BidStatistics
    * const bidStatistics = await prisma.bidStatistics.findMany()
    * ```
    */
  get bidStatistics(): Prisma.BidStatisticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.submissionRecord`: Exposes CRUD operations for the **SubmissionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubmissionRecords
    * const submissionRecords = await prisma.submissionRecord.findMany()
    * ```
    */
  get submissionRecord(): Prisma.SubmissionRecordDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    UserRole: 'UserRole',
    Permission: 'Permission',
    Project: 'Project',
    ProjectDocument: 'ProjectDocument',
    ProjectMember: 'ProjectMember',
    WorkflowExecution: 'WorkflowExecution',
    AgentTask: 'AgentTask',
    Artifact: 'Artifact',
    ArtifactVersion: 'ArtifactVersion',
    KnowledgeBase: 'KnowledgeBase',
    KnowledgeBaseDocument: 'KnowledgeBaseDocument',
    KnowledgeBasePermission: 'KnowledgeBasePermission',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    AgentConfiguration: 'AgentConfiguration',
    Integration: 'Integration',
    IntegrationLog: 'IntegrationLog',
    BidStatistics: 'BidStatistics',
    SubmissionRecord: 'SubmissionRecord'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "role" | "userRole" | "permission" | "project" | "projectDocument" | "projectMember" | "workflowExecution" | "agentTask" | "artifact" | "artifactVersion" | "knowledgeBase" | "knowledgeBaseDocument" | "knowledgeBasePermission" | "notification" | "auditLog" | "agentConfiguration" | "integration" | "integrationLog" | "bidStatistics" | "submissionRecord"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectDocument: {
        payload: Prisma.$ProjectDocumentPayload<ExtArgs>
        fields: Prisma.ProjectDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          findFirst: {
            args: Prisma.ProjectDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          findMany: {
            args: Prisma.ProjectDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>[]
          }
          create: {
            args: Prisma.ProjectDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          createMany: {
            args: Prisma.ProjectDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>[]
          }
          delete: {
            args: Prisma.ProjectDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          update: {
            args: Prisma.ProjectDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>[]
          }
          upsert: {
            args: Prisma.ProjectDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          aggregate: {
            args: Prisma.ProjectDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectDocument>
          }
          groupBy: {
            args: Prisma.ProjectDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectDocumentCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      WorkflowExecution: {
        payload: Prisma.$WorkflowExecutionPayload<ExtArgs>
        fields: Prisma.WorkflowExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowExecutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowExecutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          findFirst: {
            args: Prisma.WorkflowExecutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowExecutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          findMany: {
            args: Prisma.WorkflowExecutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>[]
          }
          create: {
            args: Prisma.WorkflowExecutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          createMany: {
            args: Prisma.WorkflowExecutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowExecutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>[]
          }
          delete: {
            args: Prisma.WorkflowExecutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          update: {
            args: Prisma.WorkflowExecutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowExecutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowExecutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkflowExecutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>[]
          }
          upsert: {
            args: Prisma.WorkflowExecutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
          }
          aggregate: {
            args: Prisma.WorkflowExecutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowExecution>
          }
          groupBy: {
            args: Prisma.WorkflowExecutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowExecutionCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowExecutionCountAggregateOutputType> | number
          }
        }
      }
      AgentTask: {
        payload: Prisma.$AgentTaskPayload<ExtArgs>
        fields: Prisma.AgentTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          findFirst: {
            args: Prisma.AgentTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          findMany: {
            args: Prisma.AgentTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>[]
          }
          create: {
            args: Prisma.AgentTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          createMany: {
            args: Prisma.AgentTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>[]
          }
          delete: {
            args: Prisma.AgentTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          update: {
            args: Prisma.AgentTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          deleteMany: {
            args: Prisma.AgentTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>[]
          }
          upsert: {
            args: Prisma.AgentTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          aggregate: {
            args: Prisma.AgentTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentTask>
          }
          groupBy: {
            args: Prisma.AgentTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentTaskCountArgs<ExtArgs>
            result: $Utils.Optional<AgentTaskCountAggregateOutputType> | number
          }
        }
      }
      Artifact: {
        payload: Prisma.$ArtifactPayload<ExtArgs>
        fields: Prisma.ArtifactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtifactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtifactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          findFirst: {
            args: Prisma.ArtifactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtifactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          findMany: {
            args: Prisma.ArtifactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
          }
          create: {
            args: Prisma.ArtifactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          createMany: {
            args: Prisma.ArtifactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtifactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
          }
          delete: {
            args: Prisma.ArtifactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          update: {
            args: Prisma.ArtifactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          deleteMany: {
            args: Prisma.ArtifactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtifactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtifactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
          }
          upsert: {
            args: Prisma.ArtifactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          aggregate: {
            args: Prisma.ArtifactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtifact>
          }
          groupBy: {
            args: Prisma.ArtifactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtifactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtifactCountArgs<ExtArgs>
            result: $Utils.Optional<ArtifactCountAggregateOutputType> | number
          }
        }
      }
      ArtifactVersion: {
        payload: Prisma.$ArtifactVersionPayload<ExtArgs>
        fields: Prisma.ArtifactVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtifactVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtifactVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactVersionPayload>
          }
          findFirst: {
            args: Prisma.ArtifactVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtifactVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactVersionPayload>
          }
          findMany: {
            args: Prisma.ArtifactVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactVersionPayload>[]
          }
          create: {
            args: Prisma.ArtifactVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactVersionPayload>
          }
          createMany: {
            args: Prisma.ArtifactVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtifactVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactVersionPayload>[]
          }
          delete: {
            args: Prisma.ArtifactVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactVersionPayload>
          }
          update: {
            args: Prisma.ArtifactVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactVersionPayload>
          }
          deleteMany: {
            args: Prisma.ArtifactVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtifactVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtifactVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactVersionPayload>[]
          }
          upsert: {
            args: Prisma.ArtifactVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactVersionPayload>
          }
          aggregate: {
            args: Prisma.ArtifactVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtifactVersion>
          }
          groupBy: {
            args: Prisma.ArtifactVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtifactVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtifactVersionCountArgs<ExtArgs>
            result: $Utils.Optional<ArtifactVersionCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeBase: {
        payload: Prisma.$KnowledgeBasePayload<ExtArgs>
        fields: Prisma.KnowledgeBaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeBaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeBaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeBaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeBaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          findMany: {
            args: Prisma.KnowledgeBaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>[]
          }
          create: {
            args: Prisma.KnowledgeBaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          createMany: {
            args: Prisma.KnowledgeBaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeBaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>[]
          }
          delete: {
            args: Prisma.KnowledgeBaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          update: {
            args: Prisma.KnowledgeBaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeBaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeBaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeBaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeBaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeBaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeBase>
          }
          groupBy: {
            args: Prisma.KnowledgeBaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeBaseCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeBaseDocument: {
        payload: Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>
        fields: Prisma.KnowledgeBaseDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeBaseDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeBaseDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseDocumentPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeBaseDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeBaseDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseDocumentPayload>
          }
          findMany: {
            args: Prisma.KnowledgeBaseDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseDocumentPayload>[]
          }
          create: {
            args: Prisma.KnowledgeBaseDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseDocumentPayload>
          }
          createMany: {
            args: Prisma.KnowledgeBaseDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeBaseDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseDocumentPayload>[]
          }
          delete: {
            args: Prisma.KnowledgeBaseDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseDocumentPayload>
          }
          update: {
            args: Prisma.KnowledgeBaseDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseDocumentPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeBaseDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeBaseDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeBaseDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseDocumentPayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeBaseDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseDocumentPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeBaseDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeBaseDocument>
          }
          groupBy: {
            args: Prisma.KnowledgeBaseDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeBaseDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseDocumentCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeBasePermission: {
        payload: Prisma.$KnowledgeBasePermissionPayload<ExtArgs>
        fields: Prisma.KnowledgeBasePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeBasePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeBasePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePermissionPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeBasePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeBasePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePermissionPayload>
          }
          findMany: {
            args: Prisma.KnowledgeBasePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePermissionPayload>[]
          }
          create: {
            args: Prisma.KnowledgeBasePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePermissionPayload>
          }
          createMany: {
            args: Prisma.KnowledgeBasePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeBasePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePermissionPayload>[]
          }
          delete: {
            args: Prisma.KnowledgeBasePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePermissionPayload>
          }
          update: {
            args: Prisma.KnowledgeBasePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePermissionPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeBasePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeBasePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeBasePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePermissionPayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeBasePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBasePermissionPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeBasePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeBasePermission>
          }
          groupBy: {
            args: Prisma.KnowledgeBasePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBasePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeBasePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBasePermissionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      AgentConfiguration: {
        payload: Prisma.$AgentConfigurationPayload<ExtArgs>
        fields: Prisma.AgentConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConfigurationPayload>
          }
          findFirst: {
            args: Prisma.AgentConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConfigurationPayload>
          }
          findMany: {
            args: Prisma.AgentConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConfigurationPayload>[]
          }
          create: {
            args: Prisma.AgentConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConfigurationPayload>
          }
          createMany: {
            args: Prisma.AgentConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConfigurationPayload>[]
          }
          delete: {
            args: Prisma.AgentConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConfigurationPayload>
          }
          update: {
            args: Prisma.AgentConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.AgentConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentConfigurationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConfigurationPayload>[]
          }
          upsert: {
            args: Prisma.AgentConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentConfigurationPayload>
          }
          aggregate: {
            args: Prisma.AgentConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentConfiguration>
          }
          groupBy: {
            args: Prisma.AgentConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<AgentConfigurationCountAggregateOutputType> | number
          }
        }
      }
      Integration: {
        payload: Prisma.$IntegrationPayload<ExtArgs>
        fields: Prisma.IntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findFirst: {
            args: Prisma.IntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findMany: {
            args: Prisma.IntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          create: {
            args: Prisma.IntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          createMany: {
            args: Prisma.IntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          delete: {
            args: Prisma.IntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          update: {
            args: Prisma.IntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          upsert: {
            args: Prisma.IntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.IntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
      IntegrationLog: {
        payload: Prisma.$IntegrationLogPayload<ExtArgs>
        fields: Prisma.IntegrationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
          }
          findFirst: {
            args: Prisma.IntegrationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
          }
          findMany: {
            args: Prisma.IntegrationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationLogPayload>[]
          }
          create: {
            args: Prisma.IntegrationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
          }
          createMany: {
            args: Prisma.IntegrationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationLogPayload>[]
          }
          delete: {
            args: Prisma.IntegrationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
          }
          update: {
            args: Prisma.IntegrationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntegrationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationLogPayload>[]
          }
          upsert: {
            args: Prisma.IntegrationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationLogPayload>
          }
          aggregate: {
            args: Prisma.IntegrationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegrationLog>
          }
          groupBy: {
            args: Prisma.IntegrationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationLogCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationLogCountAggregateOutputType> | number
          }
        }
      }
      BidStatistics: {
        payload: Prisma.$BidStatisticsPayload<ExtArgs>
        fields: Prisma.BidStatisticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BidStatisticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidStatisticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BidStatisticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidStatisticsPayload>
          }
          findFirst: {
            args: Prisma.BidStatisticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidStatisticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BidStatisticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidStatisticsPayload>
          }
          findMany: {
            args: Prisma.BidStatisticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidStatisticsPayload>[]
          }
          create: {
            args: Prisma.BidStatisticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidStatisticsPayload>
          }
          createMany: {
            args: Prisma.BidStatisticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BidStatisticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidStatisticsPayload>[]
          }
          delete: {
            args: Prisma.BidStatisticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidStatisticsPayload>
          }
          update: {
            args: Prisma.BidStatisticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidStatisticsPayload>
          }
          deleteMany: {
            args: Prisma.BidStatisticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BidStatisticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BidStatisticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidStatisticsPayload>[]
          }
          upsert: {
            args: Prisma.BidStatisticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidStatisticsPayload>
          }
          aggregate: {
            args: Prisma.BidStatisticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBidStatistics>
          }
          groupBy: {
            args: Prisma.BidStatisticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BidStatisticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BidStatisticsCountArgs<ExtArgs>
            result: $Utils.Optional<BidStatisticsCountAggregateOutputType> | number
          }
        }
      }
      SubmissionRecord: {
        payload: Prisma.$SubmissionRecordPayload<ExtArgs>
        fields: Prisma.SubmissionRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubmissionRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubmissionRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionRecordPayload>
          }
          findFirst: {
            args: Prisma.SubmissionRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubmissionRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionRecordPayload>
          }
          findMany: {
            args: Prisma.SubmissionRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionRecordPayload>[]
          }
          create: {
            args: Prisma.SubmissionRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionRecordPayload>
          }
          createMany: {
            args: Prisma.SubmissionRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubmissionRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionRecordPayload>[]
          }
          delete: {
            args: Prisma.SubmissionRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionRecordPayload>
          }
          update: {
            args: Prisma.SubmissionRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionRecordPayload>
          }
          deleteMany: {
            args: Prisma.SubmissionRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubmissionRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubmissionRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionRecordPayload>[]
          }
          upsert: {
            args: Prisma.SubmissionRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionRecordPayload>
          }
          aggregate: {
            args: Prisma.SubmissionRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubmissionRecord>
          }
          groupBy: {
            args: Prisma.SubmissionRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubmissionRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubmissionRecordCountArgs<ExtArgs>
            result: $Utils.Optional<SubmissionRecordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    userRole?: UserRoleOmit
    permission?: PermissionOmit
    project?: ProjectOmit
    projectDocument?: ProjectDocumentOmit
    projectMember?: ProjectMemberOmit
    workflowExecution?: WorkflowExecutionOmit
    agentTask?: AgentTaskOmit
    artifact?: ArtifactOmit
    artifactVersion?: ArtifactVersionOmit
    knowledgeBase?: KnowledgeBaseOmit
    knowledgeBaseDocument?: KnowledgeBaseDocumentOmit
    knowledgeBasePermission?: KnowledgeBasePermissionOmit
    notification?: NotificationOmit
    auditLog?: AuditLogOmit
    agentConfiguration?: AgentConfigurationOmit
    integration?: IntegrationOmit
    integrationLog?: IntegrationLogOmit
    bidStatistics?: BidStatisticsOmit
    submissionRecord?: SubmissionRecordOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    roles: number
    projectMemberships: number
    createdProjects: number
    completedProjects: number
    notifications: number
    auditLogs: number
    uploadedDocuments: number
    createdKnowledgeBases: number
    createdArtifacts: number
    approvedArtifacts: number
    submissions: number
    createdIntegrations: number
    uploadedKBDocuments: number
    createdArtifactVersions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    projectMemberships?: boolean | UserCountOutputTypeCountProjectMembershipsArgs
    createdProjects?: boolean | UserCountOutputTypeCountCreatedProjectsArgs
    completedProjects?: boolean | UserCountOutputTypeCountCompletedProjectsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    uploadedDocuments?: boolean | UserCountOutputTypeCountUploadedDocumentsArgs
    createdKnowledgeBases?: boolean | UserCountOutputTypeCountCreatedKnowledgeBasesArgs
    createdArtifacts?: boolean | UserCountOutputTypeCountCreatedArtifactsArgs
    approvedArtifacts?: boolean | UserCountOutputTypeCountApprovedArtifactsArgs
    submissions?: boolean | UserCountOutputTypeCountSubmissionsArgs
    createdIntegrations?: boolean | UserCountOutputTypeCountCreatedIntegrationsArgs
    uploadedKBDocuments?: boolean | UserCountOutputTypeCountUploadedKBDocumentsArgs
    createdArtifactVersions?: boolean | UserCountOutputTypeCountCreatedArtifactVersionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompletedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedKnowledgeBasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedKBDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseDocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedArtifactVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactVersionWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userRoles: number
    permissions: number
    kbPermissions: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
    kbPermissions?: boolean | RoleCountOutputTypeCountKbPermissionsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountKbPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBasePermissionWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    members: number
    documents: number
    knowledgeBases: number
    artifacts: number
    workflowExecutions: number
    submissions: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    documents?: boolean | ProjectCountOutputTypeCountDocumentsArgs
    knowledgeBases?: boolean | ProjectCountOutputTypeCountKnowledgeBasesArgs
    artifacts?: boolean | ProjectCountOutputTypeCountArtifactsArgs
    workflowExecutions?: boolean | ProjectCountOutputTypeCountWorkflowExecutionsArgs
    submissions?: boolean | ProjectCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDocumentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountKnowledgeBasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountWorkflowExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowExecutionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionRecordWhereInput
  }


  /**
   * Count Type WorkflowExecutionCountOutputType
   */

  export type WorkflowExecutionCountOutputType = {
    agentTasks: number
  }

  export type WorkflowExecutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agentTasks?: boolean | WorkflowExecutionCountOutputTypeCountAgentTasksArgs
  }

  // Custom InputTypes
  /**
   * WorkflowExecutionCountOutputType without action
   */
  export type WorkflowExecutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionCountOutputType
     */
    select?: WorkflowExecutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkflowExecutionCountOutputType without action
   */
  export type WorkflowExecutionCountOutputTypeCountAgentTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentTaskWhereInput
  }


  /**
   * Count Type ArtifactCountOutputType
   */

  export type ArtifactCountOutputType = {
    versions: number
    submissions: number
  }

  export type ArtifactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | ArtifactCountOutputTypeCountVersionsArgs
    submissions?: boolean | ArtifactCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * ArtifactCountOutputType without action
   */
  export type ArtifactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCountOutputType
     */
    select?: ArtifactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArtifactCountOutputType without action
   */
  export type ArtifactCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactVersionWhereInput
  }

  /**
   * ArtifactCountOutputType without action
   */
  export type ArtifactCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionRecordWhereInput
  }


  /**
   * Count Type KnowledgeBaseCountOutputType
   */

  export type KnowledgeBaseCountOutputType = {
    documents: number
    permissions: number
  }

  export type KnowledgeBaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | KnowledgeBaseCountOutputTypeCountDocumentsArgs
    permissions?: boolean | KnowledgeBaseCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * KnowledgeBaseCountOutputType without action
   */
  export type KnowledgeBaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCountOutputType
     */
    select?: KnowledgeBaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KnowledgeBaseCountOutputType without action
   */
  export type KnowledgeBaseCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseDocumentWhereInput
  }

  /**
   * KnowledgeBaseCountOutputType without action
   */
  export type KnowledgeBaseCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBasePermissionWhereInput
  }


  /**
   * Count Type IntegrationCountOutputType
   */

  export type IntegrationCountOutputType = {
    logs: number
  }

  export type IntegrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | IntegrationCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * IntegrationCountOutputType without action
   */
  export type IntegrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationCountOutputType
     */
    select?: IntegrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IntegrationCountOutputType without action
   */
  export type IntegrationCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    profileImageUrl: string | null
    preferredLanguage: string | null
    themePreference: string | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
    cognitoUserId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    profileImageUrl: string | null
    preferredLanguage: string | null
    themePreference: string | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
    cognitoUserId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    firstName: number
    lastName: number
    profileImageUrl: number
    preferredLanguage: number
    themePreference: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    lastLogin: number
    cognitoUserId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    profileImageUrl?: true
    preferredLanguage?: true
    themePreference?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    cognitoUserId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    profileImageUrl?: true
    preferredLanguage?: true
    themePreference?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    cognitoUserId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    profileImageUrl?: true
    preferredLanguage?: true
    themePreference?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    cognitoUserId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string | null
    firstName: string
    lastName: string
    profileImageUrl: string | null
    preferredLanguage: string | null
    themePreference: string | null
    emailVerified: boolean
    createdAt: Date
    updatedAt: Date
    lastLogin: Date | null
    cognitoUserId: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    preferredLanguage?: boolean
    themePreference?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    cognitoUserId?: boolean
    roles?: boolean | User$rolesArgs<ExtArgs>
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    createdProjects?: boolean | User$createdProjectsArgs<ExtArgs>
    completedProjects?: boolean | User$completedProjectsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    createdKnowledgeBases?: boolean | User$createdKnowledgeBasesArgs<ExtArgs>
    createdArtifacts?: boolean | User$createdArtifactsArgs<ExtArgs>
    approvedArtifacts?: boolean | User$approvedArtifactsArgs<ExtArgs>
    submissions?: boolean | User$submissionsArgs<ExtArgs>
    createdIntegrations?: boolean | User$createdIntegrationsArgs<ExtArgs>
    uploadedKBDocuments?: boolean | User$uploadedKBDocumentsArgs<ExtArgs>
    createdArtifactVersions?: boolean | User$createdArtifactVersionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    preferredLanguage?: boolean
    themePreference?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    cognitoUserId?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    preferredLanguage?: boolean
    themePreference?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    cognitoUserId?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImageUrl?: boolean
    preferredLanguage?: boolean
    themePreference?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    cognitoUserId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "passwordHash" | "firstName" | "lastName" | "profileImageUrl" | "preferredLanguage" | "themePreference" | "emailVerified" | "createdAt" | "updatedAt" | "lastLogin" | "cognitoUserId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | User$rolesArgs<ExtArgs>
    projectMemberships?: boolean | User$projectMembershipsArgs<ExtArgs>
    createdProjects?: boolean | User$createdProjectsArgs<ExtArgs>
    completedProjects?: boolean | User$completedProjectsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    uploadedDocuments?: boolean | User$uploadedDocumentsArgs<ExtArgs>
    createdKnowledgeBases?: boolean | User$createdKnowledgeBasesArgs<ExtArgs>
    createdArtifacts?: boolean | User$createdArtifactsArgs<ExtArgs>
    approvedArtifacts?: boolean | User$approvedArtifactsArgs<ExtArgs>
    submissions?: boolean | User$submissionsArgs<ExtArgs>
    createdIntegrations?: boolean | User$createdIntegrationsArgs<ExtArgs>
    uploadedKBDocuments?: boolean | User$uploadedKBDocumentsArgs<ExtArgs>
    createdArtifactVersions?: boolean | User$createdArtifactVersionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      roles: Prisma.$UserRolePayload<ExtArgs>[]
      projectMemberships: Prisma.$ProjectMemberPayload<ExtArgs>[]
      createdProjects: Prisma.$ProjectPayload<ExtArgs>[]
      completedProjects: Prisma.$ProjectPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      uploadedDocuments: Prisma.$ProjectDocumentPayload<ExtArgs>[]
      createdKnowledgeBases: Prisma.$KnowledgeBasePayload<ExtArgs>[]
      createdArtifacts: Prisma.$ArtifactPayload<ExtArgs>[]
      approvedArtifacts: Prisma.$ArtifactPayload<ExtArgs>[]
      submissions: Prisma.$SubmissionRecordPayload<ExtArgs>[]
      createdIntegrations: Prisma.$IntegrationPayload<ExtArgs>[]
      uploadedKBDocuments: Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>[]
      createdArtifactVersions: Prisma.$ArtifactVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string | null
      firstName: string
      lastName: string
      profileImageUrl: string | null
      preferredLanguage: string | null
      themePreference: string | null
      emailVerified: boolean
      createdAt: Date
      updatedAt: Date
      lastLogin: Date | null
      cognitoUserId: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectMemberships<T extends User$projectMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdProjects<T extends User$createdProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    completedProjects<T extends User$completedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$completedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedDocuments<T extends User$uploadedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdKnowledgeBases<T extends User$createdKnowledgeBasesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdKnowledgeBasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdArtifacts<T extends User$createdArtifactsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdArtifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedArtifacts<T extends User$approvedArtifactsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedArtifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submissions<T extends User$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdIntegrations<T extends User$createdIntegrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdIntegrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedKBDocuments<T extends User$uploadedKBDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedKBDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdArtifactVersions<T extends User$createdArtifactVersionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdArtifactVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly profileImageUrl: FieldRef<"User", 'String'>
    readonly preferredLanguage: FieldRef<"User", 'String'>
    readonly themePreference: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly cognitoUserId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.projectMemberships
   */
  export type User$projectMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * User.createdProjects
   */
  export type User$createdProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.completedProjects
   */
  export type User$completedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.uploadedDocuments
   */
  export type User$uploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    where?: ProjectDocumentWhereInput
    orderBy?: ProjectDocumentOrderByWithRelationInput | ProjectDocumentOrderByWithRelationInput[]
    cursor?: ProjectDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectDocumentScalarFieldEnum | ProjectDocumentScalarFieldEnum[]
  }

  /**
   * User.createdKnowledgeBases
   */
  export type User$createdKnowledgeBasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    where?: KnowledgeBaseWhereInput
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    cursor?: KnowledgeBaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * User.createdArtifacts
   */
  export type User$createdArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    cursor?: ArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * User.approvedArtifacts
   */
  export type User$approvedArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    cursor?: ArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * User.submissions
   */
  export type User$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    where?: SubmissionRecordWhereInput
    orderBy?: SubmissionRecordOrderByWithRelationInput | SubmissionRecordOrderByWithRelationInput[]
    cursor?: SubmissionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionRecordScalarFieldEnum | SubmissionRecordScalarFieldEnum[]
  }

  /**
   * User.createdIntegrations
   */
  export type User$createdIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * User.uploadedKBDocuments
   */
  export type User$uploadedKBDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
    where?: KnowledgeBaseDocumentWhereInput
    orderBy?: KnowledgeBaseDocumentOrderByWithRelationInput | KnowledgeBaseDocumentOrderByWithRelationInput[]
    cursor?: KnowledgeBaseDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBaseDocumentScalarFieldEnum | KnowledgeBaseDocumentScalarFieldEnum[]
  }

  /**
   * User.createdArtifactVersions
   */
  export type User$createdArtifactVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
    where?: ArtifactVersionWhereInput
    orderBy?: ArtifactVersionOrderByWithRelationInput | ArtifactVersionOrderByWithRelationInput[]
    cursor?: ArtifactVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactVersionScalarFieldEnum | ArtifactVersionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    kbPermissions?: boolean | Role$kbPermissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    kbPermissions?: boolean | Role$kbPermissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      permissions: Prisma.$PermissionPayload<ExtArgs>[]
      kbPermissions: Prisma.$KnowledgeBasePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kbPermissions<T extends Role$kbPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$kbPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Role.kbPermissions
   */
  export type Role$kbPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
    where?: KnowledgeBasePermissionWhereInput
    orderBy?: KnowledgeBasePermissionOrderByWithRelationInput | KnowledgeBasePermissionOrderByWithRelationInput[]
    cursor?: KnowledgeBasePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBasePermissionScalarFieldEnum | KnowledgeBasePermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roleId: string | null
    assignedAt: Date | null
    assignedBy: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    roleId: number
    assignedAt: number
    assignedBy: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    roleId?: true
    assignedAt?: true
    assignedBy?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    roleId: string
    assignedAt: Date
    assignedBy: string | null
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    assignedBy?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roleId" | "assignedAt" | "assignedBy", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roleId: string
      assignedAt: Date
      assignedBy: string | null
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
    readonly assignedAt: FieldRef<"UserRole", 'DateTime'>
    readonly assignedBy: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    resource: string | null
    action: string | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    resource: string | null
    action: string | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    roleId: number
    resource: number
    action: number
    createdAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    resource?: true
    action?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    resource?: true
    action?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    resource?: true
    action?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    roleId: string
    resource: string
    action: string
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    resource?: boolean
    action?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    resource?: boolean
    action?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    resource?: boolean
    action?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    resource?: boolean
    action?: boolean
    createdAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "resource" | "action" | "createdAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      resource: string
      action: string
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly roleId: FieldRef<"Permission", 'String'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    value: Decimal | null
    progressPercentage: number | null
  }

  export type ProjectSumAggregateOutputType = {
    value: Decimal | null
    progressPercentage: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    value: Decimal | null
    deadline: Date | null
    progressPercentage: number | null
    createdBy: string | null
    completedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    value: Decimal | null
    deadline: Date | null
    progressPercentage: number | null
    createdBy: string | null
    completedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    value: number
    deadline: number
    progressPercentage: number
    createdBy: number
    completedBy: number
    createdAt: number
    updatedAt: number
    completedAt: number
    metadata: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    value?: true
    progressPercentage?: true
  }

  export type ProjectSumAggregateInputType = {
    value?: true
    progressPercentage?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    value?: true
    deadline?: true
    progressPercentage?: true
    createdBy?: true
    completedBy?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    value?: true
    deadline?: true
    progressPercentage?: true
    createdBy?: true
    completedBy?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    value?: true
    deadline?: true
    progressPercentage?: true
    createdBy?: true
    completedBy?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    metadata?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: string
    value: Decimal | null
    deadline: Date | null
    progressPercentage: number
    createdBy: string
    completedBy: string | null
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    metadata: JsonValue | null
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    value?: boolean
    deadline?: boolean
    progressPercentage?: boolean
    createdBy?: boolean
    completedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    completer?: boolean | Project$completerArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    knowledgeBases?: boolean | Project$knowledgeBasesArgs<ExtArgs>
    artifacts?: boolean | Project$artifactsArgs<ExtArgs>
    workflowExecutions?: boolean | Project$workflowExecutionsArgs<ExtArgs>
    submissions?: boolean | Project$submissionsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    value?: boolean
    deadline?: boolean
    progressPercentage?: boolean
    createdBy?: boolean
    completedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    completer?: boolean | Project$completerArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    value?: boolean
    deadline?: boolean
    progressPercentage?: boolean
    createdBy?: boolean
    completedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    completer?: boolean | Project$completerArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    value?: boolean
    deadline?: boolean
    progressPercentage?: boolean
    createdBy?: boolean
    completedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    metadata?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "value" | "deadline" | "progressPercentage" | "createdBy" | "completedBy" | "createdAt" | "updatedAt" | "completedAt" | "metadata", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    completer?: boolean | Project$completerArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    documents?: boolean | Project$documentsArgs<ExtArgs>
    knowledgeBases?: boolean | Project$knowledgeBasesArgs<ExtArgs>
    artifacts?: boolean | Project$artifactsArgs<ExtArgs>
    workflowExecutions?: boolean | Project$workflowExecutionsArgs<ExtArgs>
    submissions?: boolean | Project$submissionsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    completer?: boolean | Project$completerArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    completer?: boolean | Project$completerArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      completer: Prisma.$UserPayload<ExtArgs> | null
      members: Prisma.$ProjectMemberPayload<ExtArgs>[]
      documents: Prisma.$ProjectDocumentPayload<ExtArgs>[]
      knowledgeBases: Prisma.$KnowledgeBasePayload<ExtArgs>[]
      artifacts: Prisma.$ArtifactPayload<ExtArgs>[]
      workflowExecutions: Prisma.$WorkflowExecutionPayload<ExtArgs>[]
      submissions: Prisma.$SubmissionRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: string
      value: Prisma.Decimal | null
      deadline: Date | null
      progressPercentage: number
      createdBy: string
      completedBy: string | null
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    completer<T extends Project$completerArgs<ExtArgs> = {}>(args?: Subset<T, Project$completerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Project$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Project$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    knowledgeBases<T extends Project$knowledgeBasesArgs<ExtArgs> = {}>(args?: Subset<T, Project$knowledgeBasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artifacts<T extends Project$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, Project$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workflowExecutions<T extends Project$workflowExecutionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$workflowExecutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submissions<T extends Project$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Project$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'String'>
    readonly value: FieldRef<"Project", 'Decimal'>
    readonly deadline: FieldRef<"Project", 'DateTime'>
    readonly progressPercentage: FieldRef<"Project", 'Int'>
    readonly createdBy: FieldRef<"Project", 'String'>
    readonly completedBy: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly completedAt: FieldRef<"Project", 'DateTime'>
    readonly metadata: FieldRef<"Project", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.completer
   */
  export type Project$completerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project.documents
   */
  export type Project$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    where?: ProjectDocumentWhereInput
    orderBy?: ProjectDocumentOrderByWithRelationInput | ProjectDocumentOrderByWithRelationInput[]
    cursor?: ProjectDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectDocumentScalarFieldEnum | ProjectDocumentScalarFieldEnum[]
  }

  /**
   * Project.knowledgeBases
   */
  export type Project$knowledgeBasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    where?: KnowledgeBaseWhereInput
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    cursor?: KnowledgeBaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * Project.artifacts
   */
  export type Project$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    cursor?: ArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Project.workflowExecutions
   */
  export type Project$workflowExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    where?: WorkflowExecutionWhereInput
    orderBy?: WorkflowExecutionOrderByWithRelationInput | WorkflowExecutionOrderByWithRelationInput[]
    cursor?: WorkflowExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[]
  }

  /**
   * Project.submissions
   */
  export type Project$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    where?: SubmissionRecordWhereInput
    orderBy?: SubmissionRecordOrderByWithRelationInput | SubmissionRecordOrderByWithRelationInput[]
    cursor?: SubmissionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionRecordScalarFieldEnum | SubmissionRecordScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectDocument
   */

  export type AggregateProjectDocument = {
    _count: ProjectDocumentCountAggregateOutputType | null
    _avg: ProjectDocumentAvgAggregateOutputType | null
    _sum: ProjectDocumentSumAggregateOutputType | null
    _min: ProjectDocumentMinAggregateOutputType | null
    _max: ProjectDocumentMaxAggregateOutputType | null
  }

  export type ProjectDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type ProjectDocumentSumAggregateOutputType = {
    fileSize: bigint | null
  }

  export type ProjectDocumentMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    fileName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: bigint | null
    rawFileLocation: string | null
    processedFileLocation: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
  }

  export type ProjectDocumentMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    fileName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: bigint | null
    rawFileLocation: string | null
    processedFileLocation: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
  }

  export type ProjectDocumentCountAggregateOutputType = {
    id: number
    projectId: number
    fileName: number
    filePath: number
    fileType: number
    fileSize: number
    rawFileLocation: number
    processedFileLocation: number
    uploadedBy: number
    uploadedAt: number
    metadata: number
    _all: number
  }


  export type ProjectDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type ProjectDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type ProjectDocumentMinAggregateInputType = {
    id?: true
    projectId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    rawFileLocation?: true
    processedFileLocation?: true
    uploadedBy?: true
    uploadedAt?: true
  }

  export type ProjectDocumentMaxAggregateInputType = {
    id?: true
    projectId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    rawFileLocation?: true
    processedFileLocation?: true
    uploadedBy?: true
    uploadedAt?: true
  }

  export type ProjectDocumentCountAggregateInputType = {
    id?: true
    projectId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    rawFileLocation?: true
    processedFileLocation?: true
    uploadedBy?: true
    uploadedAt?: true
    metadata?: true
    _all?: true
  }

  export type ProjectDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectDocument to aggregate.
     */
    where?: ProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDocuments to fetch.
     */
    orderBy?: ProjectDocumentOrderByWithRelationInput | ProjectDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectDocuments
    **/
    _count?: true | ProjectDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectDocumentMaxAggregateInputType
  }

  export type GetProjectDocumentAggregateType<T extends ProjectDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectDocument[P]>
      : GetScalarType<T[P], AggregateProjectDocument[P]>
  }




  export type ProjectDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDocumentWhereInput
    orderBy?: ProjectDocumentOrderByWithAggregationInput | ProjectDocumentOrderByWithAggregationInput[]
    by: ProjectDocumentScalarFieldEnum[] | ProjectDocumentScalarFieldEnum
    having?: ProjectDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectDocumentCountAggregateInputType | true
    _avg?: ProjectDocumentAvgAggregateInputType
    _sum?: ProjectDocumentSumAggregateInputType
    _min?: ProjectDocumentMinAggregateInputType
    _max?: ProjectDocumentMaxAggregateInputType
  }

  export type ProjectDocumentGroupByOutputType = {
    id: string
    projectId: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint
    rawFileLocation: string
    processedFileLocation: string | null
    uploadedBy: string
    uploadedAt: Date
    metadata: JsonValue | null
    _count: ProjectDocumentCountAggregateOutputType | null
    _avg: ProjectDocumentAvgAggregateOutputType | null
    _sum: ProjectDocumentSumAggregateOutputType | null
    _min: ProjectDocumentMinAggregateOutputType | null
    _max: ProjectDocumentMaxAggregateOutputType | null
  }

  type GetProjectDocumentGroupByPayload<T extends ProjectDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectDocumentGroupByOutputType[P]>
        }
      >
    >


  export type ProjectDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    rawFileLocation?: boolean
    processedFileLocation?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    metadata?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectDocument"]>

  export type ProjectDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    rawFileLocation?: boolean
    processedFileLocation?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    metadata?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectDocument"]>

  export type ProjectDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    rawFileLocation?: boolean
    processedFileLocation?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    metadata?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectDocument"]>

  export type ProjectDocumentSelectScalar = {
    id?: boolean
    projectId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    rawFileLocation?: boolean
    processedFileLocation?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    metadata?: boolean
  }

  export type ProjectDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "fileName" | "filePath" | "fileType" | "fileSize" | "rawFileLocation" | "processedFileLocation" | "uploadedBy" | "uploadedAt" | "metadata", ExtArgs["result"]["projectDocument"]>
  export type ProjectDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectDocument"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      fileName: string
      filePath: string
      fileType: string
      fileSize: bigint
      rawFileLocation: string
      processedFileLocation: string | null
      uploadedBy: string
      uploadedAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["projectDocument"]>
    composites: {}
  }

  type ProjectDocumentGetPayload<S extends boolean | null | undefined | ProjectDocumentDefaultArgs> = $Result.GetResult<Prisma.$ProjectDocumentPayload, S>

  type ProjectDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectDocumentCountAggregateInputType | true
    }

  export interface ProjectDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectDocument'], meta: { name: 'ProjectDocument' } }
    /**
     * Find zero or one ProjectDocument that matches the filter.
     * @param {ProjectDocumentFindUniqueArgs} args - Arguments to find a ProjectDocument
     * @example
     * // Get one ProjectDocument
     * const projectDocument = await prisma.projectDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectDocumentFindUniqueArgs>(args: SelectSubset<T, ProjectDocumentFindUniqueArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectDocumentFindUniqueOrThrowArgs} args - Arguments to find a ProjectDocument
     * @example
     * // Get one ProjectDocument
     * const projectDocument = await prisma.projectDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentFindFirstArgs} args - Arguments to find a ProjectDocument
     * @example
     * // Get one ProjectDocument
     * const projectDocument = await prisma.projectDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectDocumentFindFirstArgs>(args?: SelectSubset<T, ProjectDocumentFindFirstArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentFindFirstOrThrowArgs} args - Arguments to find a ProjectDocument
     * @example
     * // Get one ProjectDocument
     * const projectDocument = await prisma.projectDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectDocuments
     * const projectDocuments = await prisma.projectDocument.findMany()
     * 
     * // Get first 10 ProjectDocuments
     * const projectDocuments = await prisma.projectDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectDocumentWithIdOnly = await prisma.projectDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectDocumentFindManyArgs>(args?: SelectSubset<T, ProjectDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectDocument.
     * @param {ProjectDocumentCreateArgs} args - Arguments to create a ProjectDocument.
     * @example
     * // Create one ProjectDocument
     * const ProjectDocument = await prisma.projectDocument.create({
     *   data: {
     *     // ... data to create a ProjectDocument
     *   }
     * })
     * 
     */
    create<T extends ProjectDocumentCreateArgs>(args: SelectSubset<T, ProjectDocumentCreateArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectDocuments.
     * @param {ProjectDocumentCreateManyArgs} args - Arguments to create many ProjectDocuments.
     * @example
     * // Create many ProjectDocuments
     * const projectDocument = await prisma.projectDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectDocumentCreateManyArgs>(args?: SelectSubset<T, ProjectDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectDocuments and returns the data saved in the database.
     * @param {ProjectDocumentCreateManyAndReturnArgs} args - Arguments to create many ProjectDocuments.
     * @example
     * // Create many ProjectDocuments
     * const projectDocument = await prisma.projectDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectDocuments and only return the `id`
     * const projectDocumentWithIdOnly = await prisma.projectDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectDocument.
     * @param {ProjectDocumentDeleteArgs} args - Arguments to delete one ProjectDocument.
     * @example
     * // Delete one ProjectDocument
     * const ProjectDocument = await prisma.projectDocument.delete({
     *   where: {
     *     // ... filter to delete one ProjectDocument
     *   }
     * })
     * 
     */
    delete<T extends ProjectDocumentDeleteArgs>(args: SelectSubset<T, ProjectDocumentDeleteArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectDocument.
     * @param {ProjectDocumentUpdateArgs} args - Arguments to update one ProjectDocument.
     * @example
     * // Update one ProjectDocument
     * const projectDocument = await prisma.projectDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectDocumentUpdateArgs>(args: SelectSubset<T, ProjectDocumentUpdateArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectDocuments.
     * @param {ProjectDocumentDeleteManyArgs} args - Arguments to filter ProjectDocuments to delete.
     * @example
     * // Delete a few ProjectDocuments
     * const { count } = await prisma.projectDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDocumentDeleteManyArgs>(args?: SelectSubset<T, ProjectDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectDocuments
     * const projectDocument = await prisma.projectDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectDocumentUpdateManyArgs>(args: SelectSubset<T, ProjectDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectDocuments and returns the data updated in the database.
     * @param {ProjectDocumentUpdateManyAndReturnArgs} args - Arguments to update many ProjectDocuments.
     * @example
     * // Update many ProjectDocuments
     * const projectDocument = await prisma.projectDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectDocuments and only return the `id`
     * const projectDocumentWithIdOnly = await prisma.projectDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectDocument.
     * @param {ProjectDocumentUpsertArgs} args - Arguments to update or create a ProjectDocument.
     * @example
     * // Update or create a ProjectDocument
     * const projectDocument = await prisma.projectDocument.upsert({
     *   create: {
     *     // ... data to create a ProjectDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectDocument we want to update
     *   }
     * })
     */
    upsert<T extends ProjectDocumentUpsertArgs>(args: SelectSubset<T, ProjectDocumentUpsertArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentCountArgs} args - Arguments to filter ProjectDocuments to count.
     * @example
     * // Count the number of ProjectDocuments
     * const count = await prisma.projectDocument.count({
     *   where: {
     *     // ... the filter for the ProjectDocuments we want to count
     *   }
     * })
    **/
    count<T extends ProjectDocumentCountArgs>(
      args?: Subset<T, ProjectDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectDocumentAggregateArgs>(args: Subset<T, ProjectDocumentAggregateArgs>): Prisma.PrismaPromise<GetProjectDocumentAggregateType<T>>

    /**
     * Group by ProjectDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ProjectDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectDocument model
   */
  readonly fields: ProjectDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectDocument model
   */
  interface ProjectDocumentFieldRefs {
    readonly id: FieldRef<"ProjectDocument", 'String'>
    readonly projectId: FieldRef<"ProjectDocument", 'String'>
    readonly fileName: FieldRef<"ProjectDocument", 'String'>
    readonly filePath: FieldRef<"ProjectDocument", 'String'>
    readonly fileType: FieldRef<"ProjectDocument", 'String'>
    readonly fileSize: FieldRef<"ProjectDocument", 'BigInt'>
    readonly rawFileLocation: FieldRef<"ProjectDocument", 'String'>
    readonly processedFileLocation: FieldRef<"ProjectDocument", 'String'>
    readonly uploadedBy: FieldRef<"ProjectDocument", 'String'>
    readonly uploadedAt: FieldRef<"ProjectDocument", 'DateTime'>
    readonly metadata: FieldRef<"ProjectDocument", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ProjectDocument findUnique
   */
  export type ProjectDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDocument to fetch.
     */
    where: ProjectDocumentWhereUniqueInput
  }

  /**
   * ProjectDocument findUniqueOrThrow
   */
  export type ProjectDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDocument to fetch.
     */
    where: ProjectDocumentWhereUniqueInput
  }

  /**
   * ProjectDocument findFirst
   */
  export type ProjectDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDocument to fetch.
     */
    where?: ProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDocuments to fetch.
     */
    orderBy?: ProjectDocumentOrderByWithRelationInput | ProjectDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectDocuments.
     */
    cursor?: ProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectDocuments.
     */
    distinct?: ProjectDocumentScalarFieldEnum | ProjectDocumentScalarFieldEnum[]
  }

  /**
   * ProjectDocument findFirstOrThrow
   */
  export type ProjectDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDocument to fetch.
     */
    where?: ProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDocuments to fetch.
     */
    orderBy?: ProjectDocumentOrderByWithRelationInput | ProjectDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectDocuments.
     */
    cursor?: ProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectDocuments.
     */
    distinct?: ProjectDocumentScalarFieldEnum | ProjectDocumentScalarFieldEnum[]
  }

  /**
   * ProjectDocument findMany
   */
  export type ProjectDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDocuments to fetch.
     */
    where?: ProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDocuments to fetch.
     */
    orderBy?: ProjectDocumentOrderByWithRelationInput | ProjectDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectDocuments.
     */
    cursor?: ProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDocuments.
     */
    skip?: number
    distinct?: ProjectDocumentScalarFieldEnum | ProjectDocumentScalarFieldEnum[]
  }

  /**
   * ProjectDocument create
   */
  export type ProjectDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectDocument.
     */
    data: XOR<ProjectDocumentCreateInput, ProjectDocumentUncheckedCreateInput>
  }

  /**
   * ProjectDocument createMany
   */
  export type ProjectDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectDocuments.
     */
    data: ProjectDocumentCreateManyInput | ProjectDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectDocument createManyAndReturn
   */
  export type ProjectDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectDocuments.
     */
    data: ProjectDocumentCreateManyInput | ProjectDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectDocument update
   */
  export type ProjectDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectDocument.
     */
    data: XOR<ProjectDocumentUpdateInput, ProjectDocumentUncheckedUpdateInput>
    /**
     * Choose, which ProjectDocument to update.
     */
    where: ProjectDocumentWhereUniqueInput
  }

  /**
   * ProjectDocument updateMany
   */
  export type ProjectDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectDocuments.
     */
    data: XOR<ProjectDocumentUpdateManyMutationInput, ProjectDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ProjectDocuments to update
     */
    where?: ProjectDocumentWhereInput
    /**
     * Limit how many ProjectDocuments to update.
     */
    limit?: number
  }

  /**
   * ProjectDocument updateManyAndReturn
   */
  export type ProjectDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * The data used to update ProjectDocuments.
     */
    data: XOR<ProjectDocumentUpdateManyMutationInput, ProjectDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ProjectDocuments to update
     */
    where?: ProjectDocumentWhereInput
    /**
     * Limit how many ProjectDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectDocument upsert
   */
  export type ProjectDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectDocument to update in case it exists.
     */
    where: ProjectDocumentWhereUniqueInput
    /**
     * In case the ProjectDocument found by the `where` argument doesn't exist, create a new ProjectDocument with this data.
     */
    create: XOR<ProjectDocumentCreateInput, ProjectDocumentUncheckedCreateInput>
    /**
     * In case the ProjectDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectDocumentUpdateInput, ProjectDocumentUncheckedUpdateInput>
  }

  /**
   * ProjectDocument delete
   */
  export type ProjectDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter which ProjectDocument to delete.
     */
    where: ProjectDocumentWhereUniqueInput
  }

  /**
   * ProjectDocument deleteMany
   */
  export type ProjectDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectDocuments to delete
     */
    where?: ProjectDocumentWhereInput
    /**
     * Limit how many ProjectDocuments to delete.
     */
    limit?: number
  }

  /**
   * ProjectDocument without action
   */
  export type ProjectDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectDocument
     */
    omit?: ProjectDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    addedById: string | null
    joinedAt: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    addedById: string | null
    joinedAt: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    addedById: number
    joinedAt: number
    _all: number
  }


  export type ProjectMemberMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    addedById?: true
    joinedAt?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    addedById?: true
    joinedAt?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    addedById?: true
    joinedAt?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    addedById: string
    joinedAt: Date
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    addedById?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    addedById?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    addedById?: boolean
    joinedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    addedById?: boolean
    joinedAt?: boolean
  }

  export type ProjectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "addedById" | "joinedAt", ExtArgs["result"]["projectMember"]>
  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      addedById: string
      joinedAt: Date
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {ProjectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers and returns the data updated in the database.
     * @param {ProjectMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectMembers.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'String'>
    readonly projectId: FieldRef<"ProjectMember", 'String'>
    readonly userId: FieldRef<"ProjectMember", 'String'>
    readonly addedById: FieldRef<"ProjectMember", 'String'>
    readonly joinedAt: FieldRef<"ProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMember createManyAndReturn
   */
  export type ProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
  }

  /**
   * ProjectMember updateManyAndReturn
   */
  export type ProjectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to delete.
     */
    limit?: number
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowExecution
   */

  export type AggregateWorkflowExecution = {
    _count: WorkflowExecutionCountAggregateOutputType | null
    _min: WorkflowExecutionMinAggregateOutputType | null
    _max: WorkflowExecutionMaxAggregateOutputType | null
  }

  export type WorkflowExecutionMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    status: string | null
    initiatedBy: string | null
    handledBy: string | null
    completedBy: string | null
    startedAt: Date | null
    completedAt: Date | null
    lastUpdatedAt: Date | null
    errorMessage: string | null
  }

  export type WorkflowExecutionMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    status: string | null
    initiatedBy: string | null
    handledBy: string | null
    completedBy: string | null
    startedAt: Date | null
    completedAt: Date | null
    lastUpdatedAt: Date | null
    errorMessage: string | null
  }

  export type WorkflowExecutionCountAggregateOutputType = {
    id: number
    projectId: number
    status: number
    initiatedBy: number
    handledBy: number
    completedBy: number
    startedAt: number
    completedAt: number
    lastUpdatedAt: number
    workflowConfig: number
    errorLog: number
    errorMessage: number
    results: number
    _all: number
  }


  export type WorkflowExecutionMinAggregateInputType = {
    id?: true
    projectId?: true
    status?: true
    initiatedBy?: true
    handledBy?: true
    completedBy?: true
    startedAt?: true
    completedAt?: true
    lastUpdatedAt?: true
    errorMessage?: true
  }

  export type WorkflowExecutionMaxAggregateInputType = {
    id?: true
    projectId?: true
    status?: true
    initiatedBy?: true
    handledBy?: true
    completedBy?: true
    startedAt?: true
    completedAt?: true
    lastUpdatedAt?: true
    errorMessage?: true
  }

  export type WorkflowExecutionCountAggregateInputType = {
    id?: true
    projectId?: true
    status?: true
    initiatedBy?: true
    handledBy?: true
    completedBy?: true
    startedAt?: true
    completedAt?: true
    lastUpdatedAt?: true
    workflowConfig?: true
    errorLog?: true
    errorMessage?: true
    results?: true
    _all?: true
  }

  export type WorkflowExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowExecution to aggregate.
     */
    where?: WorkflowExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?: WorkflowExecutionOrderByWithRelationInput | WorkflowExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowExecutions
    **/
    _count?: true | WorkflowExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowExecutionMaxAggregateInputType
  }

  export type GetWorkflowExecutionAggregateType<T extends WorkflowExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowExecution[P]>
      : GetScalarType<T[P], AggregateWorkflowExecution[P]>
  }




  export type WorkflowExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowExecutionWhereInput
    orderBy?: WorkflowExecutionOrderByWithAggregationInput | WorkflowExecutionOrderByWithAggregationInput[]
    by: WorkflowExecutionScalarFieldEnum[] | WorkflowExecutionScalarFieldEnum
    having?: WorkflowExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowExecutionCountAggregateInputType | true
    _min?: WorkflowExecutionMinAggregateInputType
    _max?: WorkflowExecutionMaxAggregateInputType
  }

  export type WorkflowExecutionGroupByOutputType = {
    id: string
    projectId: string
    status: string
    initiatedBy: string
    handledBy: string | null
    completedBy: string | null
    startedAt: Date
    completedAt: Date | null
    lastUpdatedAt: Date
    workflowConfig: JsonValue | null
    errorLog: JsonValue | null
    errorMessage: string | null
    results: JsonValue | null
    _count: WorkflowExecutionCountAggregateOutputType | null
    _min: WorkflowExecutionMinAggregateOutputType | null
    _max: WorkflowExecutionMaxAggregateOutputType | null
  }

  type GetWorkflowExecutionGroupByPayload<T extends WorkflowExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowExecutionGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    status?: boolean
    initiatedBy?: boolean
    handledBy?: boolean
    completedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lastUpdatedAt?: boolean
    workflowConfig?: boolean
    errorLog?: boolean
    errorMessage?: boolean
    results?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    agentTasks?: boolean | WorkflowExecution$agentTasksArgs<ExtArgs>
    _count?: boolean | WorkflowExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowExecution"]>

  export type WorkflowExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    status?: boolean
    initiatedBy?: boolean
    handledBy?: boolean
    completedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lastUpdatedAt?: boolean
    workflowConfig?: boolean
    errorLog?: boolean
    errorMessage?: boolean
    results?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowExecution"]>

  export type WorkflowExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    status?: boolean
    initiatedBy?: boolean
    handledBy?: boolean
    completedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lastUpdatedAt?: boolean
    workflowConfig?: boolean
    errorLog?: boolean
    errorMessage?: boolean
    results?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowExecution"]>

  export type WorkflowExecutionSelectScalar = {
    id?: boolean
    projectId?: boolean
    status?: boolean
    initiatedBy?: boolean
    handledBy?: boolean
    completedBy?: boolean
    startedAt?: boolean
    completedAt?: boolean
    lastUpdatedAt?: boolean
    workflowConfig?: boolean
    errorLog?: boolean
    errorMessage?: boolean
    results?: boolean
  }

  export type WorkflowExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "status" | "initiatedBy" | "handledBy" | "completedBy" | "startedAt" | "completedAt" | "lastUpdatedAt" | "workflowConfig" | "errorLog" | "errorMessage" | "results", ExtArgs["result"]["workflowExecution"]>
  export type WorkflowExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    agentTasks?: boolean | WorkflowExecution$agentTasksArgs<ExtArgs>
    _count?: boolean | WorkflowExecutionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkflowExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type WorkflowExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $WorkflowExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowExecution"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      agentTasks: Prisma.$AgentTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      status: string
      initiatedBy: string
      handledBy: string | null
      completedBy: string | null
      startedAt: Date
      completedAt: Date | null
      lastUpdatedAt: Date
      workflowConfig: Prisma.JsonValue | null
      errorLog: Prisma.JsonValue | null
      errorMessage: string | null
      results: Prisma.JsonValue | null
    }, ExtArgs["result"]["workflowExecution"]>
    composites: {}
  }

  type WorkflowExecutionGetPayload<S extends boolean | null | undefined | WorkflowExecutionDefaultArgs> = $Result.GetResult<Prisma.$WorkflowExecutionPayload, S>

  type WorkflowExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkflowExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkflowExecutionCountAggregateInputType | true
    }

  export interface WorkflowExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowExecution'], meta: { name: 'WorkflowExecution' } }
    /**
     * Find zero or one WorkflowExecution that matches the filter.
     * @param {WorkflowExecutionFindUniqueArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowExecutionFindUniqueArgs>(args: SelectSubset<T, WorkflowExecutionFindUniqueArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkflowExecution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowExecutionFindUniqueOrThrowArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkflowExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionFindFirstArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowExecutionFindFirstArgs>(args?: SelectSubset<T, WorkflowExecutionFindFirstArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkflowExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionFindFirstOrThrowArgs} args - Arguments to find a WorkflowExecution
     * @example
     * // Get one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkflowExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowExecutions
     * const workflowExecutions = await prisma.workflowExecution.findMany()
     * 
     * // Get first 10 WorkflowExecutions
     * const workflowExecutions = await prisma.workflowExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowExecutionWithIdOnly = await prisma.workflowExecution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowExecutionFindManyArgs>(args?: SelectSubset<T, WorkflowExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkflowExecution.
     * @param {WorkflowExecutionCreateArgs} args - Arguments to create a WorkflowExecution.
     * @example
     * // Create one WorkflowExecution
     * const WorkflowExecution = await prisma.workflowExecution.create({
     *   data: {
     *     // ... data to create a WorkflowExecution
     *   }
     * })
     * 
     */
    create<T extends WorkflowExecutionCreateArgs>(args: SelectSubset<T, WorkflowExecutionCreateArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkflowExecutions.
     * @param {WorkflowExecutionCreateManyArgs} args - Arguments to create many WorkflowExecutions.
     * @example
     * // Create many WorkflowExecutions
     * const workflowExecution = await prisma.workflowExecution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowExecutionCreateManyArgs>(args?: SelectSubset<T, WorkflowExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowExecutions and returns the data saved in the database.
     * @param {WorkflowExecutionCreateManyAndReturnArgs} args - Arguments to create many WorkflowExecutions.
     * @example
     * // Create many WorkflowExecutions
     * const workflowExecution = await prisma.workflowExecution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowExecutions and only return the `id`
     * const workflowExecutionWithIdOnly = await prisma.workflowExecution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkflowExecution.
     * @param {WorkflowExecutionDeleteArgs} args - Arguments to delete one WorkflowExecution.
     * @example
     * // Delete one WorkflowExecution
     * const WorkflowExecution = await prisma.workflowExecution.delete({
     *   where: {
     *     // ... filter to delete one WorkflowExecution
     *   }
     * })
     * 
     */
    delete<T extends WorkflowExecutionDeleteArgs>(args: SelectSubset<T, WorkflowExecutionDeleteArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkflowExecution.
     * @param {WorkflowExecutionUpdateArgs} args - Arguments to update one WorkflowExecution.
     * @example
     * // Update one WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowExecutionUpdateArgs>(args: SelectSubset<T, WorkflowExecutionUpdateArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkflowExecutions.
     * @param {WorkflowExecutionDeleteManyArgs} args - Arguments to filter WorkflowExecutions to delete.
     * @example
     * // Delete a few WorkflowExecutions
     * const { count } = await prisma.workflowExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowExecutionDeleteManyArgs>(args?: SelectSubset<T, WorkflowExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowExecutions
     * const workflowExecution = await prisma.workflowExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowExecutionUpdateManyArgs>(args: SelectSubset<T, WorkflowExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowExecutions and returns the data updated in the database.
     * @param {WorkflowExecutionUpdateManyAndReturnArgs} args - Arguments to update many WorkflowExecutions.
     * @example
     * // Update many WorkflowExecutions
     * const workflowExecution = await prisma.workflowExecution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkflowExecutions and only return the `id`
     * const workflowExecutionWithIdOnly = await prisma.workflowExecution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkflowExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkflowExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkflowExecution.
     * @param {WorkflowExecutionUpsertArgs} args - Arguments to update or create a WorkflowExecution.
     * @example
     * // Update or create a WorkflowExecution
     * const workflowExecution = await prisma.workflowExecution.upsert({
     *   create: {
     *     // ... data to create a WorkflowExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowExecution we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowExecutionUpsertArgs>(args: SelectSubset<T, WorkflowExecutionUpsertArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkflowExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionCountArgs} args - Arguments to filter WorkflowExecutions to count.
     * @example
     * // Count the number of WorkflowExecutions
     * const count = await prisma.workflowExecution.count({
     *   where: {
     *     // ... the filter for the WorkflowExecutions we want to count
     *   }
     * })
    **/
    count<T extends WorkflowExecutionCountArgs>(
      args?: Subset<T, WorkflowExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowExecutionAggregateArgs>(args: Subset<T, WorkflowExecutionAggregateArgs>): Prisma.PrismaPromise<GetWorkflowExecutionAggregateType<T>>

    /**
     * Group by WorkflowExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowExecutionGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowExecution model
   */
  readonly fields: WorkflowExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agentTasks<T extends WorkflowExecution$agentTasksArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecution$agentTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowExecution model
   */
  interface WorkflowExecutionFieldRefs {
    readonly id: FieldRef<"WorkflowExecution", 'String'>
    readonly projectId: FieldRef<"WorkflowExecution", 'String'>
    readonly status: FieldRef<"WorkflowExecution", 'String'>
    readonly initiatedBy: FieldRef<"WorkflowExecution", 'String'>
    readonly handledBy: FieldRef<"WorkflowExecution", 'String'>
    readonly completedBy: FieldRef<"WorkflowExecution", 'String'>
    readonly startedAt: FieldRef<"WorkflowExecution", 'DateTime'>
    readonly completedAt: FieldRef<"WorkflowExecution", 'DateTime'>
    readonly lastUpdatedAt: FieldRef<"WorkflowExecution", 'DateTime'>
    readonly workflowConfig: FieldRef<"WorkflowExecution", 'Json'>
    readonly errorLog: FieldRef<"WorkflowExecution", 'Json'>
    readonly errorMessage: FieldRef<"WorkflowExecution", 'String'>
    readonly results: FieldRef<"WorkflowExecution", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowExecution findUnique
   */
  export type WorkflowExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where: WorkflowExecutionWhereUniqueInput
  }

  /**
   * WorkflowExecution findUniqueOrThrow
   */
  export type WorkflowExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where: WorkflowExecutionWhereUniqueInput
  }

  /**
   * WorkflowExecution findFirst
   */
  export type WorkflowExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where?: WorkflowExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?: WorkflowExecutionOrderByWithRelationInput | WorkflowExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowExecutions.
     */
    cursor?: WorkflowExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowExecutions.
     */
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowExecution findFirstOrThrow
   */
  export type WorkflowExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecution to fetch.
     */
    where?: WorkflowExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?: WorkflowExecutionOrderByWithRelationInput | WorkflowExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowExecutions.
     */
    cursor?: WorkflowExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowExecutions.
     */
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowExecution findMany
   */
  export type WorkflowExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecutions to fetch.
     */
    where?: WorkflowExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutions to fetch.
     */
    orderBy?: WorkflowExecutionOrderByWithRelationInput | WorkflowExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowExecutions.
     */
    cursor?: WorkflowExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutions.
     */
    skip?: number
    distinct?: WorkflowExecutionScalarFieldEnum | WorkflowExecutionScalarFieldEnum[]
  }

  /**
   * WorkflowExecution create
   */
  export type WorkflowExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowExecution.
     */
    data: XOR<WorkflowExecutionCreateInput, WorkflowExecutionUncheckedCreateInput>
  }

  /**
   * WorkflowExecution createMany
   */
  export type WorkflowExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowExecutions.
     */
    data: WorkflowExecutionCreateManyInput | WorkflowExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowExecution createManyAndReturn
   */
  export type WorkflowExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * The data used to create many WorkflowExecutions.
     */
    data: WorkflowExecutionCreateManyInput | WorkflowExecutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowExecution update
   */
  export type WorkflowExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowExecution.
     */
    data: XOR<WorkflowExecutionUpdateInput, WorkflowExecutionUncheckedUpdateInput>
    /**
     * Choose, which WorkflowExecution to update.
     */
    where: WorkflowExecutionWhereUniqueInput
  }

  /**
   * WorkflowExecution updateMany
   */
  export type WorkflowExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowExecutions.
     */
    data: XOR<WorkflowExecutionUpdateManyMutationInput, WorkflowExecutionUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowExecutions to update
     */
    where?: WorkflowExecutionWhereInput
    /**
     * Limit how many WorkflowExecutions to update.
     */
    limit?: number
  }

  /**
   * WorkflowExecution updateManyAndReturn
   */
  export type WorkflowExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * The data used to update WorkflowExecutions.
     */
    data: XOR<WorkflowExecutionUpdateManyMutationInput, WorkflowExecutionUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowExecutions to update
     */
    where?: WorkflowExecutionWhereInput
    /**
     * Limit how many WorkflowExecutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowExecution upsert
   */
  export type WorkflowExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowExecution to update in case it exists.
     */
    where: WorkflowExecutionWhereUniqueInput
    /**
     * In case the WorkflowExecution found by the `where` argument doesn't exist, create a new WorkflowExecution with this data.
     */
    create: XOR<WorkflowExecutionCreateInput, WorkflowExecutionUncheckedCreateInput>
    /**
     * In case the WorkflowExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowExecutionUpdateInput, WorkflowExecutionUncheckedUpdateInput>
  }

  /**
   * WorkflowExecution delete
   */
  export type WorkflowExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
    /**
     * Filter which WorkflowExecution to delete.
     */
    where: WorkflowExecutionWhereUniqueInput
  }

  /**
   * WorkflowExecution deleteMany
   */
  export type WorkflowExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowExecutions to delete
     */
    where?: WorkflowExecutionWhereInput
    /**
     * Limit how many WorkflowExecutions to delete.
     */
    limit?: number
  }

  /**
   * WorkflowExecution.agentTasks
   */
  export type WorkflowExecution$agentTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    where?: AgentTaskWhereInput
    orderBy?: AgentTaskOrderByWithRelationInput | AgentTaskOrderByWithRelationInput[]
    cursor?: AgentTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentTaskScalarFieldEnum | AgentTaskScalarFieldEnum[]
  }

  /**
   * WorkflowExecution without action
   */
  export type WorkflowExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecution
     */
    select?: WorkflowExecutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowExecution
     */
    omit?: WorkflowExecutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionInclude<ExtArgs> | null
  }


  /**
   * Model AgentTask
   */

  export type AggregateAgentTask = {
    _count: AgentTaskCountAggregateOutputType | null
    _avg: AgentTaskAvgAggregateOutputType | null
    _sum: AgentTaskSumAggregateOutputType | null
    _min: AgentTaskMinAggregateOutputType | null
    _max: AgentTaskMaxAggregateOutputType | null
  }

  export type AgentTaskAvgAggregateOutputType = {
    sequenceOrder: number | null
    executionTimeSeconds: number | null
  }

  export type AgentTaskSumAggregateOutputType = {
    sequenceOrder: number | null
    executionTimeSeconds: number | null
  }

  export type AgentTaskMinAggregateOutputType = {
    id: string | null
    workflowExecutionId: string | null
    initiatedBy: string | null
    handledBy: string | null
    completedBy: string | null
    agent: string | null
    status: string | null
    sequenceOrder: number | null
    errorMessage: string | null
    startedAt: Date | null
    completedAt: Date | null
    executionTimeSeconds: number | null
  }

  export type AgentTaskMaxAggregateOutputType = {
    id: string | null
    workflowExecutionId: string | null
    initiatedBy: string | null
    handledBy: string | null
    completedBy: string | null
    agent: string | null
    status: string | null
    sequenceOrder: number | null
    errorMessage: string | null
    startedAt: Date | null
    completedAt: Date | null
    executionTimeSeconds: number | null
  }

  export type AgentTaskCountAggregateOutputType = {
    id: number
    workflowExecutionId: number
    initiatedBy: number
    handledBy: number
    completedBy: number
    agent: number
    status: number
    sequenceOrder: number
    inputData: number
    outputData: number
    taskConfig: number
    errorLog: number
    errorMessage: number
    startedAt: number
    completedAt: number
    executionTimeSeconds: number
    _all: number
  }


  export type AgentTaskAvgAggregateInputType = {
    sequenceOrder?: true
    executionTimeSeconds?: true
  }

  export type AgentTaskSumAggregateInputType = {
    sequenceOrder?: true
    executionTimeSeconds?: true
  }

  export type AgentTaskMinAggregateInputType = {
    id?: true
    workflowExecutionId?: true
    initiatedBy?: true
    handledBy?: true
    completedBy?: true
    agent?: true
    status?: true
    sequenceOrder?: true
    errorMessage?: true
    startedAt?: true
    completedAt?: true
    executionTimeSeconds?: true
  }

  export type AgentTaskMaxAggregateInputType = {
    id?: true
    workflowExecutionId?: true
    initiatedBy?: true
    handledBy?: true
    completedBy?: true
    agent?: true
    status?: true
    sequenceOrder?: true
    errorMessage?: true
    startedAt?: true
    completedAt?: true
    executionTimeSeconds?: true
  }

  export type AgentTaskCountAggregateInputType = {
    id?: true
    workflowExecutionId?: true
    initiatedBy?: true
    handledBy?: true
    completedBy?: true
    agent?: true
    status?: true
    sequenceOrder?: true
    inputData?: true
    outputData?: true
    taskConfig?: true
    errorLog?: true
    errorMessage?: true
    startedAt?: true
    completedAt?: true
    executionTimeSeconds?: true
    _all?: true
  }

  export type AgentTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTask to aggregate.
     */
    where?: AgentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTasks to fetch.
     */
    orderBy?: AgentTaskOrderByWithRelationInput | AgentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentTasks
    **/
    _count?: true | AgentTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentTaskMaxAggregateInputType
  }

  export type GetAgentTaskAggregateType<T extends AgentTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentTask[P]>
      : GetScalarType<T[P], AggregateAgentTask[P]>
  }




  export type AgentTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentTaskWhereInput
    orderBy?: AgentTaskOrderByWithAggregationInput | AgentTaskOrderByWithAggregationInput[]
    by: AgentTaskScalarFieldEnum[] | AgentTaskScalarFieldEnum
    having?: AgentTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentTaskCountAggregateInputType | true
    _avg?: AgentTaskAvgAggregateInputType
    _sum?: AgentTaskSumAggregateInputType
    _min?: AgentTaskMinAggregateInputType
    _max?: AgentTaskMaxAggregateInputType
  }

  export type AgentTaskGroupByOutputType = {
    id: string
    workflowExecutionId: string
    initiatedBy: string
    handledBy: string | null
    completedBy: string | null
    agent: string
    status: string
    sequenceOrder: number
    inputData: JsonValue | null
    outputData: JsonValue | null
    taskConfig: JsonValue | null
    errorLog: JsonValue | null
    errorMessage: string | null
    startedAt: Date | null
    completedAt: Date | null
    executionTimeSeconds: number | null
    _count: AgentTaskCountAggregateOutputType | null
    _avg: AgentTaskAvgAggregateOutputType | null
    _sum: AgentTaskSumAggregateOutputType | null
    _min: AgentTaskMinAggregateOutputType | null
    _max: AgentTaskMaxAggregateOutputType | null
  }

  type GetAgentTaskGroupByPayload<T extends AgentTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentTaskGroupByOutputType[P]>
            : GetScalarType<T[P], AgentTaskGroupByOutputType[P]>
        }
      >
    >


  export type AgentTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowExecutionId?: boolean
    initiatedBy?: boolean
    handledBy?: boolean
    completedBy?: boolean
    agent?: boolean
    status?: boolean
    sequenceOrder?: boolean
    inputData?: boolean
    outputData?: boolean
    taskConfig?: boolean
    errorLog?: boolean
    errorMessage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    executionTimeSeconds?: boolean
    workflowExecution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTask"]>

  export type AgentTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowExecutionId?: boolean
    initiatedBy?: boolean
    handledBy?: boolean
    completedBy?: boolean
    agent?: boolean
    status?: boolean
    sequenceOrder?: boolean
    inputData?: boolean
    outputData?: boolean
    taskConfig?: boolean
    errorLog?: boolean
    errorMessage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    executionTimeSeconds?: boolean
    workflowExecution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTask"]>

  export type AgentTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowExecutionId?: boolean
    initiatedBy?: boolean
    handledBy?: boolean
    completedBy?: boolean
    agent?: boolean
    status?: boolean
    sequenceOrder?: boolean
    inputData?: boolean
    outputData?: boolean
    taskConfig?: boolean
    errorLog?: boolean
    errorMessage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    executionTimeSeconds?: boolean
    workflowExecution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTask"]>

  export type AgentTaskSelectScalar = {
    id?: boolean
    workflowExecutionId?: boolean
    initiatedBy?: boolean
    handledBy?: boolean
    completedBy?: boolean
    agent?: boolean
    status?: boolean
    sequenceOrder?: boolean
    inputData?: boolean
    outputData?: boolean
    taskConfig?: boolean
    errorLog?: boolean
    errorMessage?: boolean
    startedAt?: boolean
    completedAt?: boolean
    executionTimeSeconds?: boolean
  }

  export type AgentTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workflowExecutionId" | "initiatedBy" | "handledBy" | "completedBy" | "agent" | "status" | "sequenceOrder" | "inputData" | "outputData" | "taskConfig" | "errorLog" | "errorMessage" | "startedAt" | "completedAt" | "executionTimeSeconds", ExtArgs["result"]["agentTask"]>
  export type AgentTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflowExecution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }
  export type AgentTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflowExecution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }
  export type AgentTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflowExecution?: boolean | WorkflowExecutionDefaultArgs<ExtArgs>
  }

  export type $AgentTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentTask"
    objects: {
      workflowExecution: Prisma.$WorkflowExecutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowExecutionId: string
      initiatedBy: string
      handledBy: string | null
      completedBy: string | null
      agent: string
      status: string
      sequenceOrder: number
      inputData: Prisma.JsonValue | null
      outputData: Prisma.JsonValue | null
      taskConfig: Prisma.JsonValue | null
      errorLog: Prisma.JsonValue | null
      errorMessage: string | null
      startedAt: Date | null
      completedAt: Date | null
      executionTimeSeconds: number | null
    }, ExtArgs["result"]["agentTask"]>
    composites: {}
  }

  type AgentTaskGetPayload<S extends boolean | null | undefined | AgentTaskDefaultArgs> = $Result.GetResult<Prisma.$AgentTaskPayload, S>

  type AgentTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentTaskCountAggregateInputType | true
    }

  export interface AgentTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentTask'], meta: { name: 'AgentTask' } }
    /**
     * Find zero or one AgentTask that matches the filter.
     * @param {AgentTaskFindUniqueArgs} args - Arguments to find a AgentTask
     * @example
     * // Get one AgentTask
     * const agentTask = await prisma.agentTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentTaskFindUniqueArgs>(args: SelectSubset<T, AgentTaskFindUniqueArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentTaskFindUniqueOrThrowArgs} args - Arguments to find a AgentTask
     * @example
     * // Get one AgentTask
     * const agentTask = await prisma.agentTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskFindFirstArgs} args - Arguments to find a AgentTask
     * @example
     * // Get one AgentTask
     * const agentTask = await prisma.agentTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentTaskFindFirstArgs>(args?: SelectSubset<T, AgentTaskFindFirstArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskFindFirstOrThrowArgs} args - Arguments to find a AgentTask
     * @example
     * // Get one AgentTask
     * const agentTask = await prisma.agentTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentTasks
     * const agentTasks = await prisma.agentTask.findMany()
     * 
     * // Get first 10 AgentTasks
     * const agentTasks = await prisma.agentTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentTaskWithIdOnly = await prisma.agentTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentTaskFindManyArgs>(args?: SelectSubset<T, AgentTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentTask.
     * @param {AgentTaskCreateArgs} args - Arguments to create a AgentTask.
     * @example
     * // Create one AgentTask
     * const AgentTask = await prisma.agentTask.create({
     *   data: {
     *     // ... data to create a AgentTask
     *   }
     * })
     * 
     */
    create<T extends AgentTaskCreateArgs>(args: SelectSubset<T, AgentTaskCreateArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentTasks.
     * @param {AgentTaskCreateManyArgs} args - Arguments to create many AgentTasks.
     * @example
     * // Create many AgentTasks
     * const agentTask = await prisma.agentTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentTaskCreateManyArgs>(args?: SelectSubset<T, AgentTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentTasks and returns the data saved in the database.
     * @param {AgentTaskCreateManyAndReturnArgs} args - Arguments to create many AgentTasks.
     * @example
     * // Create many AgentTasks
     * const agentTask = await prisma.agentTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentTasks and only return the `id`
     * const agentTaskWithIdOnly = await prisma.agentTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentTask.
     * @param {AgentTaskDeleteArgs} args - Arguments to delete one AgentTask.
     * @example
     * // Delete one AgentTask
     * const AgentTask = await prisma.agentTask.delete({
     *   where: {
     *     // ... filter to delete one AgentTask
     *   }
     * })
     * 
     */
    delete<T extends AgentTaskDeleteArgs>(args: SelectSubset<T, AgentTaskDeleteArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentTask.
     * @param {AgentTaskUpdateArgs} args - Arguments to update one AgentTask.
     * @example
     * // Update one AgentTask
     * const agentTask = await prisma.agentTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentTaskUpdateArgs>(args: SelectSubset<T, AgentTaskUpdateArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentTasks.
     * @param {AgentTaskDeleteManyArgs} args - Arguments to filter AgentTasks to delete.
     * @example
     * // Delete a few AgentTasks
     * const { count } = await prisma.agentTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentTaskDeleteManyArgs>(args?: SelectSubset<T, AgentTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentTasks
     * const agentTask = await prisma.agentTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentTaskUpdateManyArgs>(args: SelectSubset<T, AgentTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTasks and returns the data updated in the database.
     * @param {AgentTaskUpdateManyAndReturnArgs} args - Arguments to update many AgentTasks.
     * @example
     * // Update many AgentTasks
     * const agentTask = await prisma.agentTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentTasks and only return the `id`
     * const agentTaskWithIdOnly = await prisma.agentTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentTask.
     * @param {AgentTaskUpsertArgs} args - Arguments to update or create a AgentTask.
     * @example
     * // Update or create a AgentTask
     * const agentTask = await prisma.agentTask.upsert({
     *   create: {
     *     // ... data to create a AgentTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentTask we want to update
     *   }
     * })
     */
    upsert<T extends AgentTaskUpsertArgs>(args: SelectSubset<T, AgentTaskUpsertArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskCountArgs} args - Arguments to filter AgentTasks to count.
     * @example
     * // Count the number of AgentTasks
     * const count = await prisma.agentTask.count({
     *   where: {
     *     // ... the filter for the AgentTasks we want to count
     *   }
     * })
    **/
    count<T extends AgentTaskCountArgs>(
      args?: Subset<T, AgentTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentTaskAggregateArgs>(args: Subset<T, AgentTaskAggregateArgs>): Prisma.PrismaPromise<GetAgentTaskAggregateType<T>>

    /**
     * Group by AgentTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentTaskGroupByArgs['orderBy'] }
        : { orderBy?: AgentTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentTask model
   */
  readonly fields: AgentTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflowExecution<T extends WorkflowExecutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowExecutionDefaultArgs<ExtArgs>>): Prisma__WorkflowExecutionClient<$Result.GetResult<Prisma.$WorkflowExecutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentTask model
   */
  interface AgentTaskFieldRefs {
    readonly id: FieldRef<"AgentTask", 'String'>
    readonly workflowExecutionId: FieldRef<"AgentTask", 'String'>
    readonly initiatedBy: FieldRef<"AgentTask", 'String'>
    readonly handledBy: FieldRef<"AgentTask", 'String'>
    readonly completedBy: FieldRef<"AgentTask", 'String'>
    readonly agent: FieldRef<"AgentTask", 'String'>
    readonly status: FieldRef<"AgentTask", 'String'>
    readonly sequenceOrder: FieldRef<"AgentTask", 'Int'>
    readonly inputData: FieldRef<"AgentTask", 'Json'>
    readonly outputData: FieldRef<"AgentTask", 'Json'>
    readonly taskConfig: FieldRef<"AgentTask", 'Json'>
    readonly errorLog: FieldRef<"AgentTask", 'Json'>
    readonly errorMessage: FieldRef<"AgentTask", 'String'>
    readonly startedAt: FieldRef<"AgentTask", 'DateTime'>
    readonly completedAt: FieldRef<"AgentTask", 'DateTime'>
    readonly executionTimeSeconds: FieldRef<"AgentTask", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * AgentTask findUnique
   */
  export type AgentTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter, which AgentTask to fetch.
     */
    where: AgentTaskWhereUniqueInput
  }

  /**
   * AgentTask findUniqueOrThrow
   */
  export type AgentTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter, which AgentTask to fetch.
     */
    where: AgentTaskWhereUniqueInput
  }

  /**
   * AgentTask findFirst
   */
  export type AgentTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter, which AgentTask to fetch.
     */
    where?: AgentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTasks to fetch.
     */
    orderBy?: AgentTaskOrderByWithRelationInput | AgentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTasks.
     */
    cursor?: AgentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTasks.
     */
    distinct?: AgentTaskScalarFieldEnum | AgentTaskScalarFieldEnum[]
  }

  /**
   * AgentTask findFirstOrThrow
   */
  export type AgentTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter, which AgentTask to fetch.
     */
    where?: AgentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTasks to fetch.
     */
    orderBy?: AgentTaskOrderByWithRelationInput | AgentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTasks.
     */
    cursor?: AgentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTasks.
     */
    distinct?: AgentTaskScalarFieldEnum | AgentTaskScalarFieldEnum[]
  }

  /**
   * AgentTask findMany
   */
  export type AgentTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter, which AgentTasks to fetch.
     */
    where?: AgentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTasks to fetch.
     */
    orderBy?: AgentTaskOrderByWithRelationInput | AgentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentTasks.
     */
    cursor?: AgentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTasks.
     */
    skip?: number
    distinct?: AgentTaskScalarFieldEnum | AgentTaskScalarFieldEnum[]
  }

  /**
   * AgentTask create
   */
  export type AgentTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentTask.
     */
    data: XOR<AgentTaskCreateInput, AgentTaskUncheckedCreateInput>
  }

  /**
   * AgentTask createMany
   */
  export type AgentTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentTasks.
     */
    data: AgentTaskCreateManyInput | AgentTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentTask createManyAndReturn
   */
  export type AgentTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * The data used to create many AgentTasks.
     */
    data: AgentTaskCreateManyInput | AgentTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentTask update
   */
  export type AgentTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentTask.
     */
    data: XOR<AgentTaskUpdateInput, AgentTaskUncheckedUpdateInput>
    /**
     * Choose, which AgentTask to update.
     */
    where: AgentTaskWhereUniqueInput
  }

  /**
   * AgentTask updateMany
   */
  export type AgentTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentTasks.
     */
    data: XOR<AgentTaskUpdateManyMutationInput, AgentTaskUncheckedUpdateManyInput>
    /**
     * Filter which AgentTasks to update
     */
    where?: AgentTaskWhereInput
    /**
     * Limit how many AgentTasks to update.
     */
    limit?: number
  }

  /**
   * AgentTask updateManyAndReturn
   */
  export type AgentTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * The data used to update AgentTasks.
     */
    data: XOR<AgentTaskUpdateManyMutationInput, AgentTaskUncheckedUpdateManyInput>
    /**
     * Filter which AgentTasks to update
     */
    where?: AgentTaskWhereInput
    /**
     * Limit how many AgentTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentTask upsert
   */
  export type AgentTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentTask to update in case it exists.
     */
    where: AgentTaskWhereUniqueInput
    /**
     * In case the AgentTask found by the `where` argument doesn't exist, create a new AgentTask with this data.
     */
    create: XOR<AgentTaskCreateInput, AgentTaskUncheckedCreateInput>
    /**
     * In case the AgentTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentTaskUpdateInput, AgentTaskUncheckedUpdateInput>
  }

  /**
   * AgentTask delete
   */
  export type AgentTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter which AgentTask to delete.
     */
    where: AgentTaskWhereUniqueInput
  }

  /**
   * AgentTask deleteMany
   */
  export type AgentTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTasks to delete
     */
    where?: AgentTaskWhereInput
    /**
     * Limit how many AgentTasks to delete.
     */
    limit?: number
  }

  /**
   * AgentTask without action
   */
  export type AgentTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
  }


  /**
   * Model Artifact
   */

  export type AggregateArtifact = {
    _count: ArtifactCountAggregateOutputType | null
    _min: ArtifactMinAggregateOutputType | null
    _max: ArtifactMaxAggregateOutputType | null
  }

  export type ArtifactMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    type: string | null
    category: string | null
    status: string | null
    createdBy: string | null
    approvedBy: string | null
    createdAt: Date | null
    approvedAt: Date | null
  }

  export type ArtifactMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    type: string | null
    category: string | null
    status: string | null
    createdBy: string | null
    approvedBy: string | null
    createdAt: Date | null
    approvedAt: Date | null
  }

  export type ArtifactCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    type: number
    category: number
    status: number
    createdBy: number
    approvedBy: number
    createdAt: number
    approvedAt: number
    _all: number
  }


  export type ArtifactMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    category?: true
    status?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    approvedAt?: true
  }

  export type ArtifactMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    category?: true
    status?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    approvedAt?: true
  }

  export type ArtifactCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    category?: true
    status?: true
    createdBy?: true
    approvedBy?: true
    createdAt?: true
    approvedAt?: true
    _all?: true
  }

  export type ArtifactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artifact to aggregate.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Artifacts
    **/
    _count?: true | ArtifactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtifactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtifactMaxAggregateInputType
  }

  export type GetArtifactAggregateType<T extends ArtifactAggregateArgs> = {
        [P in keyof T & keyof AggregateArtifact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtifact[P]>
      : GetScalarType<T[P], AggregateArtifact[P]>
  }




  export type ArtifactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithAggregationInput | ArtifactOrderByWithAggregationInput[]
    by: ArtifactScalarFieldEnum[] | ArtifactScalarFieldEnum
    having?: ArtifactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtifactCountAggregateInputType | true
    _min?: ArtifactMinAggregateInputType
    _max?: ArtifactMaxAggregateInputType
  }

  export type ArtifactGroupByOutputType = {
    id: string
    projectId: string
    name: string
    type: string
    category: string
    status: string
    createdBy: string
    approvedBy: string | null
    createdAt: Date
    approvedAt: Date | null
    _count: ArtifactCountAggregateOutputType | null
    _min: ArtifactMinAggregateOutputType | null
    _max: ArtifactMaxAggregateOutputType | null
  }

  type GetArtifactGroupByPayload<T extends ArtifactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtifactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtifactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtifactGroupByOutputType[P]>
            : GetScalarType<T[P], ArtifactGroupByOutputType[P]>
        }
      >
    >


  export type ArtifactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    category?: boolean
    status?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Artifact$approverArgs<ExtArgs>
    versions?: boolean | Artifact$versionsArgs<ExtArgs>
    submissions?: boolean | Artifact$submissionsArgs<ExtArgs>
    _count?: boolean | ArtifactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifact"]>

  export type ArtifactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    category?: boolean
    status?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Artifact$approverArgs<ExtArgs>
  }, ExtArgs["result"]["artifact"]>

  export type ArtifactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    category?: boolean
    status?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Artifact$approverArgs<ExtArgs>
  }, ExtArgs["result"]["artifact"]>

  export type ArtifactSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    category?: boolean
    status?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    createdAt?: boolean
    approvedAt?: boolean
  }

  export type ArtifactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "type" | "category" | "status" | "createdBy" | "approvedBy" | "createdAt" | "approvedAt", ExtArgs["result"]["artifact"]>
  export type ArtifactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Artifact$approverArgs<ExtArgs>
    versions?: boolean | Artifact$versionsArgs<ExtArgs>
    submissions?: boolean | Artifact$submissionsArgs<ExtArgs>
    _count?: boolean | ArtifactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArtifactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Artifact$approverArgs<ExtArgs>
  }
  export type ArtifactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Artifact$approverArgs<ExtArgs>
  }

  export type $ArtifactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Artifact"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
      versions: Prisma.$ArtifactVersionPayload<ExtArgs>[]
      submissions: Prisma.$SubmissionRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      type: string
      category: string
      status: string
      createdBy: string
      approvedBy: string | null
      createdAt: Date
      approvedAt: Date | null
    }, ExtArgs["result"]["artifact"]>
    composites: {}
  }

  type ArtifactGetPayload<S extends boolean | null | undefined | ArtifactDefaultArgs> = $Result.GetResult<Prisma.$ArtifactPayload, S>

  type ArtifactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtifactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtifactCountAggregateInputType | true
    }

  export interface ArtifactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Artifact'], meta: { name: 'Artifact' } }
    /**
     * Find zero or one Artifact that matches the filter.
     * @param {ArtifactFindUniqueArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtifactFindUniqueArgs>(args: SelectSubset<T, ArtifactFindUniqueArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Artifact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtifactFindUniqueOrThrowArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtifactFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtifactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artifact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindFirstArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtifactFindFirstArgs>(args?: SelectSubset<T, ArtifactFindFirstArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artifact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindFirstOrThrowArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtifactFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtifactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Artifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artifacts
     * const artifacts = await prisma.artifact.findMany()
     * 
     * // Get first 10 Artifacts
     * const artifacts = await prisma.artifact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artifactWithIdOnly = await prisma.artifact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtifactFindManyArgs>(args?: SelectSubset<T, ArtifactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Artifact.
     * @param {ArtifactCreateArgs} args - Arguments to create a Artifact.
     * @example
     * // Create one Artifact
     * const Artifact = await prisma.artifact.create({
     *   data: {
     *     // ... data to create a Artifact
     *   }
     * })
     * 
     */
    create<T extends ArtifactCreateArgs>(args: SelectSubset<T, ArtifactCreateArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Artifacts.
     * @param {ArtifactCreateManyArgs} args - Arguments to create many Artifacts.
     * @example
     * // Create many Artifacts
     * const artifact = await prisma.artifact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtifactCreateManyArgs>(args?: SelectSubset<T, ArtifactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Artifacts and returns the data saved in the database.
     * @param {ArtifactCreateManyAndReturnArgs} args - Arguments to create many Artifacts.
     * @example
     * // Create many Artifacts
     * const artifact = await prisma.artifact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Artifacts and only return the `id`
     * const artifactWithIdOnly = await prisma.artifact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtifactCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtifactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Artifact.
     * @param {ArtifactDeleteArgs} args - Arguments to delete one Artifact.
     * @example
     * // Delete one Artifact
     * const Artifact = await prisma.artifact.delete({
     *   where: {
     *     // ... filter to delete one Artifact
     *   }
     * })
     * 
     */
    delete<T extends ArtifactDeleteArgs>(args: SelectSubset<T, ArtifactDeleteArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Artifact.
     * @param {ArtifactUpdateArgs} args - Arguments to update one Artifact.
     * @example
     * // Update one Artifact
     * const artifact = await prisma.artifact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtifactUpdateArgs>(args: SelectSubset<T, ArtifactUpdateArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Artifacts.
     * @param {ArtifactDeleteManyArgs} args - Arguments to filter Artifacts to delete.
     * @example
     * // Delete a few Artifacts
     * const { count } = await prisma.artifact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtifactDeleteManyArgs>(args?: SelectSubset<T, ArtifactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artifacts
     * const artifact = await prisma.artifact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtifactUpdateManyArgs>(args: SelectSubset<T, ArtifactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artifacts and returns the data updated in the database.
     * @param {ArtifactUpdateManyAndReturnArgs} args - Arguments to update many Artifacts.
     * @example
     * // Update many Artifacts
     * const artifact = await prisma.artifact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Artifacts and only return the `id`
     * const artifactWithIdOnly = await prisma.artifact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtifactUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtifactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Artifact.
     * @param {ArtifactUpsertArgs} args - Arguments to update or create a Artifact.
     * @example
     * // Update or create a Artifact
     * const artifact = await prisma.artifact.upsert({
     *   create: {
     *     // ... data to create a Artifact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artifact we want to update
     *   }
     * })
     */
    upsert<T extends ArtifactUpsertArgs>(args: SelectSubset<T, ArtifactUpsertArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactCountArgs} args - Arguments to filter Artifacts to count.
     * @example
     * // Count the number of Artifacts
     * const count = await prisma.artifact.count({
     *   where: {
     *     // ... the filter for the Artifacts we want to count
     *   }
     * })
    **/
    count<T extends ArtifactCountArgs>(
      args?: Subset<T, ArtifactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtifactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Artifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtifactAggregateArgs>(args: Subset<T, ArtifactAggregateArgs>): Prisma.PrismaPromise<GetArtifactAggregateType<T>>

    /**
     * Group by Artifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtifactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtifactGroupByArgs['orderBy'] }
        : { orderBy?: ArtifactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtifactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtifactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Artifact model
   */
  readonly fields: ArtifactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Artifact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtifactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends Artifact$approverArgs<ExtArgs> = {}>(args?: Subset<T, Artifact$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    versions<T extends Artifact$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Artifact$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submissions<T extends Artifact$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Artifact$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Artifact model
   */
  interface ArtifactFieldRefs {
    readonly id: FieldRef<"Artifact", 'String'>
    readonly projectId: FieldRef<"Artifact", 'String'>
    readonly name: FieldRef<"Artifact", 'String'>
    readonly type: FieldRef<"Artifact", 'String'>
    readonly category: FieldRef<"Artifact", 'String'>
    readonly status: FieldRef<"Artifact", 'String'>
    readonly createdBy: FieldRef<"Artifact", 'String'>
    readonly approvedBy: FieldRef<"Artifact", 'String'>
    readonly createdAt: FieldRef<"Artifact", 'DateTime'>
    readonly approvedAt: FieldRef<"Artifact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Artifact findUnique
   */
  export type ArtifactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact findUniqueOrThrow
   */
  export type ArtifactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact findFirst
   */
  export type ArtifactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artifacts.
     */
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact findFirstOrThrow
   */
  export type ArtifactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artifacts.
     */
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact findMany
   */
  export type ArtifactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifacts to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact create
   */
  export type ArtifactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The data needed to create a Artifact.
     */
    data: XOR<ArtifactCreateInput, ArtifactUncheckedCreateInput>
  }

  /**
   * Artifact createMany
   */
  export type ArtifactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Artifacts.
     */
    data: ArtifactCreateManyInput | ArtifactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Artifact createManyAndReturn
   */
  export type ArtifactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * The data used to create many Artifacts.
     */
    data: ArtifactCreateManyInput | ArtifactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artifact update
   */
  export type ArtifactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The data needed to update a Artifact.
     */
    data: XOR<ArtifactUpdateInput, ArtifactUncheckedUpdateInput>
    /**
     * Choose, which Artifact to update.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact updateMany
   */
  export type ArtifactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Artifacts.
     */
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyInput>
    /**
     * Filter which Artifacts to update
     */
    where?: ArtifactWhereInput
    /**
     * Limit how many Artifacts to update.
     */
    limit?: number
  }

  /**
   * Artifact updateManyAndReturn
   */
  export type ArtifactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * The data used to update Artifacts.
     */
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyInput>
    /**
     * Filter which Artifacts to update
     */
    where?: ArtifactWhereInput
    /**
     * Limit how many Artifacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artifact upsert
   */
  export type ArtifactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The filter to search for the Artifact to update in case it exists.
     */
    where: ArtifactWhereUniqueInput
    /**
     * In case the Artifact found by the `where` argument doesn't exist, create a new Artifact with this data.
     */
    create: XOR<ArtifactCreateInput, ArtifactUncheckedCreateInput>
    /**
     * In case the Artifact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtifactUpdateInput, ArtifactUncheckedUpdateInput>
  }

  /**
   * Artifact delete
   */
  export type ArtifactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter which Artifact to delete.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact deleteMany
   */
  export type ArtifactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artifacts to delete
     */
    where?: ArtifactWhereInput
    /**
     * Limit how many Artifacts to delete.
     */
    limit?: number
  }

  /**
   * Artifact.approver
   */
  export type Artifact$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Artifact.versions
   */
  export type Artifact$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
    where?: ArtifactVersionWhereInput
    orderBy?: ArtifactVersionOrderByWithRelationInput | ArtifactVersionOrderByWithRelationInput[]
    cursor?: ArtifactVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactVersionScalarFieldEnum | ArtifactVersionScalarFieldEnum[]
  }

  /**
   * Artifact.submissions
   */
  export type Artifact$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    where?: SubmissionRecordWhereInput
    orderBy?: SubmissionRecordOrderByWithRelationInput | SubmissionRecordOrderByWithRelationInput[]
    cursor?: SubmissionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionRecordScalarFieldEnum | SubmissionRecordScalarFieldEnum[]
  }

  /**
   * Artifact without action
   */
  export type ArtifactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
  }


  /**
   * Model ArtifactVersion
   */

  export type AggregateArtifactVersion = {
    _count: ArtifactVersionCountAggregateOutputType | null
    _avg: ArtifactVersionAvgAggregateOutputType | null
    _sum: ArtifactVersionSumAggregateOutputType | null
    _min: ArtifactVersionMinAggregateOutputType | null
    _max: ArtifactVersionMaxAggregateOutputType | null
  }

  export type ArtifactVersionAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type ArtifactVersionSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type ArtifactVersionMinAggregateOutputType = {
    id: string | null
    artifactId: string | null
    versionNumber: number | null
    location: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type ArtifactVersionMaxAggregateOutputType = {
    id: string | null
    artifactId: string | null
    versionNumber: number | null
    location: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type ArtifactVersionCountAggregateOutputType = {
    id: number
    artifactId: number
    versionNumber: number
    content: number
    location: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type ArtifactVersionAvgAggregateInputType = {
    versionNumber?: true
  }

  export type ArtifactVersionSumAggregateInputType = {
    versionNumber?: true
  }

  export type ArtifactVersionMinAggregateInputType = {
    id?: true
    artifactId?: true
    versionNumber?: true
    location?: true
    createdBy?: true
    createdAt?: true
  }

  export type ArtifactVersionMaxAggregateInputType = {
    id?: true
    artifactId?: true
    versionNumber?: true
    location?: true
    createdBy?: true
    createdAt?: true
  }

  export type ArtifactVersionCountAggregateInputType = {
    id?: true
    artifactId?: true
    versionNumber?: true
    content?: true
    location?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type ArtifactVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtifactVersion to aggregate.
     */
    where?: ArtifactVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactVersions to fetch.
     */
    orderBy?: ArtifactVersionOrderByWithRelationInput | ArtifactVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtifactVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArtifactVersions
    **/
    _count?: true | ArtifactVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtifactVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtifactVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtifactVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtifactVersionMaxAggregateInputType
  }

  export type GetArtifactVersionAggregateType<T extends ArtifactVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateArtifactVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtifactVersion[P]>
      : GetScalarType<T[P], AggregateArtifactVersion[P]>
  }




  export type ArtifactVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactVersionWhereInput
    orderBy?: ArtifactVersionOrderByWithAggregationInput | ArtifactVersionOrderByWithAggregationInput[]
    by: ArtifactVersionScalarFieldEnum[] | ArtifactVersionScalarFieldEnum
    having?: ArtifactVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtifactVersionCountAggregateInputType | true
    _avg?: ArtifactVersionAvgAggregateInputType
    _sum?: ArtifactVersionSumAggregateInputType
    _min?: ArtifactVersionMinAggregateInputType
    _max?: ArtifactVersionMaxAggregateInputType
  }

  export type ArtifactVersionGroupByOutputType = {
    id: string
    artifactId: string
    versionNumber: number
    content: JsonValue
    location: string | null
    createdBy: string
    createdAt: Date
    _count: ArtifactVersionCountAggregateOutputType | null
    _avg: ArtifactVersionAvgAggregateOutputType | null
    _sum: ArtifactVersionSumAggregateOutputType | null
    _min: ArtifactVersionMinAggregateOutputType | null
    _max: ArtifactVersionMaxAggregateOutputType | null
  }

  type GetArtifactVersionGroupByPayload<T extends ArtifactVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtifactVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtifactVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtifactVersionGroupByOutputType[P]>
            : GetScalarType<T[P], ArtifactVersionGroupByOutputType[P]>
        }
      >
    >


  export type ArtifactVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artifactId?: boolean
    versionNumber?: boolean
    content?: boolean
    location?: boolean
    createdBy?: boolean
    createdAt?: boolean
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifactVersion"]>

  export type ArtifactVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artifactId?: boolean
    versionNumber?: boolean
    content?: boolean
    location?: boolean
    createdBy?: boolean
    createdAt?: boolean
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifactVersion"]>

  export type ArtifactVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artifactId?: boolean
    versionNumber?: boolean
    content?: boolean
    location?: boolean
    createdBy?: boolean
    createdAt?: boolean
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifactVersion"]>

  export type ArtifactVersionSelectScalar = {
    id?: boolean
    artifactId?: boolean
    versionNumber?: boolean
    content?: boolean
    location?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type ArtifactVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "artifactId" | "versionNumber" | "content" | "location" | "createdBy" | "createdAt", ExtArgs["result"]["artifactVersion"]>
  export type ArtifactVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ArtifactVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ArtifactVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ArtifactVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArtifactVersion"
    objects: {
      artifact: Prisma.$ArtifactPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      artifactId: string
      versionNumber: number
      content: Prisma.JsonValue
      location: string | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["artifactVersion"]>
    composites: {}
  }

  type ArtifactVersionGetPayload<S extends boolean | null | undefined | ArtifactVersionDefaultArgs> = $Result.GetResult<Prisma.$ArtifactVersionPayload, S>

  type ArtifactVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtifactVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtifactVersionCountAggregateInputType | true
    }

  export interface ArtifactVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArtifactVersion'], meta: { name: 'ArtifactVersion' } }
    /**
     * Find zero or one ArtifactVersion that matches the filter.
     * @param {ArtifactVersionFindUniqueArgs} args - Arguments to find a ArtifactVersion
     * @example
     * // Get one ArtifactVersion
     * const artifactVersion = await prisma.artifactVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtifactVersionFindUniqueArgs>(args: SelectSubset<T, ArtifactVersionFindUniqueArgs<ExtArgs>>): Prisma__ArtifactVersionClient<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArtifactVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtifactVersionFindUniqueOrThrowArgs} args - Arguments to find a ArtifactVersion
     * @example
     * // Get one ArtifactVersion
     * const artifactVersion = await prisma.artifactVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtifactVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtifactVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtifactVersionClient<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtifactVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactVersionFindFirstArgs} args - Arguments to find a ArtifactVersion
     * @example
     * // Get one ArtifactVersion
     * const artifactVersion = await prisma.artifactVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtifactVersionFindFirstArgs>(args?: SelectSubset<T, ArtifactVersionFindFirstArgs<ExtArgs>>): Prisma__ArtifactVersionClient<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtifactVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactVersionFindFirstOrThrowArgs} args - Arguments to find a ArtifactVersion
     * @example
     * // Get one ArtifactVersion
     * const artifactVersion = await prisma.artifactVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtifactVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtifactVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtifactVersionClient<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArtifactVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArtifactVersions
     * const artifactVersions = await prisma.artifactVersion.findMany()
     * 
     * // Get first 10 ArtifactVersions
     * const artifactVersions = await prisma.artifactVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artifactVersionWithIdOnly = await prisma.artifactVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtifactVersionFindManyArgs>(args?: SelectSubset<T, ArtifactVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArtifactVersion.
     * @param {ArtifactVersionCreateArgs} args - Arguments to create a ArtifactVersion.
     * @example
     * // Create one ArtifactVersion
     * const ArtifactVersion = await prisma.artifactVersion.create({
     *   data: {
     *     // ... data to create a ArtifactVersion
     *   }
     * })
     * 
     */
    create<T extends ArtifactVersionCreateArgs>(args: SelectSubset<T, ArtifactVersionCreateArgs<ExtArgs>>): Prisma__ArtifactVersionClient<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArtifactVersions.
     * @param {ArtifactVersionCreateManyArgs} args - Arguments to create many ArtifactVersions.
     * @example
     * // Create many ArtifactVersions
     * const artifactVersion = await prisma.artifactVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtifactVersionCreateManyArgs>(args?: SelectSubset<T, ArtifactVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArtifactVersions and returns the data saved in the database.
     * @param {ArtifactVersionCreateManyAndReturnArgs} args - Arguments to create many ArtifactVersions.
     * @example
     * // Create many ArtifactVersions
     * const artifactVersion = await prisma.artifactVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArtifactVersions and only return the `id`
     * const artifactVersionWithIdOnly = await prisma.artifactVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtifactVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtifactVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArtifactVersion.
     * @param {ArtifactVersionDeleteArgs} args - Arguments to delete one ArtifactVersion.
     * @example
     * // Delete one ArtifactVersion
     * const ArtifactVersion = await prisma.artifactVersion.delete({
     *   where: {
     *     // ... filter to delete one ArtifactVersion
     *   }
     * })
     * 
     */
    delete<T extends ArtifactVersionDeleteArgs>(args: SelectSubset<T, ArtifactVersionDeleteArgs<ExtArgs>>): Prisma__ArtifactVersionClient<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArtifactVersion.
     * @param {ArtifactVersionUpdateArgs} args - Arguments to update one ArtifactVersion.
     * @example
     * // Update one ArtifactVersion
     * const artifactVersion = await prisma.artifactVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtifactVersionUpdateArgs>(args: SelectSubset<T, ArtifactVersionUpdateArgs<ExtArgs>>): Prisma__ArtifactVersionClient<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArtifactVersions.
     * @param {ArtifactVersionDeleteManyArgs} args - Arguments to filter ArtifactVersions to delete.
     * @example
     * // Delete a few ArtifactVersions
     * const { count } = await prisma.artifactVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtifactVersionDeleteManyArgs>(args?: SelectSubset<T, ArtifactVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtifactVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArtifactVersions
     * const artifactVersion = await prisma.artifactVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtifactVersionUpdateManyArgs>(args: SelectSubset<T, ArtifactVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtifactVersions and returns the data updated in the database.
     * @param {ArtifactVersionUpdateManyAndReturnArgs} args - Arguments to update many ArtifactVersions.
     * @example
     * // Update many ArtifactVersions
     * const artifactVersion = await prisma.artifactVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArtifactVersions and only return the `id`
     * const artifactVersionWithIdOnly = await prisma.artifactVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtifactVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtifactVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArtifactVersion.
     * @param {ArtifactVersionUpsertArgs} args - Arguments to update or create a ArtifactVersion.
     * @example
     * // Update or create a ArtifactVersion
     * const artifactVersion = await prisma.artifactVersion.upsert({
     *   create: {
     *     // ... data to create a ArtifactVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArtifactVersion we want to update
     *   }
     * })
     */
    upsert<T extends ArtifactVersionUpsertArgs>(args: SelectSubset<T, ArtifactVersionUpsertArgs<ExtArgs>>): Prisma__ArtifactVersionClient<$Result.GetResult<Prisma.$ArtifactVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArtifactVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactVersionCountArgs} args - Arguments to filter ArtifactVersions to count.
     * @example
     * // Count the number of ArtifactVersions
     * const count = await prisma.artifactVersion.count({
     *   where: {
     *     // ... the filter for the ArtifactVersions we want to count
     *   }
     * })
    **/
    count<T extends ArtifactVersionCountArgs>(
      args?: Subset<T, ArtifactVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtifactVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArtifactVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtifactVersionAggregateArgs>(args: Subset<T, ArtifactVersionAggregateArgs>): Prisma.PrismaPromise<GetArtifactVersionAggregateType<T>>

    /**
     * Group by ArtifactVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtifactVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtifactVersionGroupByArgs['orderBy'] }
        : { orderBy?: ArtifactVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtifactVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtifactVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArtifactVersion model
   */
  readonly fields: ArtifactVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArtifactVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtifactVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artifact<T extends ArtifactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtifactDefaultArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArtifactVersion model
   */
  interface ArtifactVersionFieldRefs {
    readonly id: FieldRef<"ArtifactVersion", 'String'>
    readonly artifactId: FieldRef<"ArtifactVersion", 'String'>
    readonly versionNumber: FieldRef<"ArtifactVersion", 'Int'>
    readonly content: FieldRef<"ArtifactVersion", 'Json'>
    readonly location: FieldRef<"ArtifactVersion", 'String'>
    readonly createdBy: FieldRef<"ArtifactVersion", 'String'>
    readonly createdAt: FieldRef<"ArtifactVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ArtifactVersion findUnique
   */
  export type ArtifactVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactVersion to fetch.
     */
    where: ArtifactVersionWhereUniqueInput
  }

  /**
   * ArtifactVersion findUniqueOrThrow
   */
  export type ArtifactVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactVersion to fetch.
     */
    where: ArtifactVersionWhereUniqueInput
  }

  /**
   * ArtifactVersion findFirst
   */
  export type ArtifactVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactVersion to fetch.
     */
    where?: ArtifactVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactVersions to fetch.
     */
    orderBy?: ArtifactVersionOrderByWithRelationInput | ArtifactVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtifactVersions.
     */
    cursor?: ArtifactVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtifactVersions.
     */
    distinct?: ArtifactVersionScalarFieldEnum | ArtifactVersionScalarFieldEnum[]
  }

  /**
   * ArtifactVersion findFirstOrThrow
   */
  export type ArtifactVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactVersion to fetch.
     */
    where?: ArtifactVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactVersions to fetch.
     */
    orderBy?: ArtifactVersionOrderByWithRelationInput | ArtifactVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtifactVersions.
     */
    cursor?: ArtifactVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtifactVersions.
     */
    distinct?: ArtifactVersionScalarFieldEnum | ArtifactVersionScalarFieldEnum[]
  }

  /**
   * ArtifactVersion findMany
   */
  export type ArtifactVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactVersions to fetch.
     */
    where?: ArtifactVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactVersions to fetch.
     */
    orderBy?: ArtifactVersionOrderByWithRelationInput | ArtifactVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArtifactVersions.
     */
    cursor?: ArtifactVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactVersions.
     */
    skip?: number
    distinct?: ArtifactVersionScalarFieldEnum | ArtifactVersionScalarFieldEnum[]
  }

  /**
   * ArtifactVersion create
   */
  export type ArtifactVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a ArtifactVersion.
     */
    data: XOR<ArtifactVersionCreateInput, ArtifactVersionUncheckedCreateInput>
  }

  /**
   * ArtifactVersion createMany
   */
  export type ArtifactVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArtifactVersions.
     */
    data: ArtifactVersionCreateManyInput | ArtifactVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArtifactVersion createManyAndReturn
   */
  export type ArtifactVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * The data used to create many ArtifactVersions.
     */
    data: ArtifactVersionCreateManyInput | ArtifactVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtifactVersion update
   */
  export type ArtifactVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a ArtifactVersion.
     */
    data: XOR<ArtifactVersionUpdateInput, ArtifactVersionUncheckedUpdateInput>
    /**
     * Choose, which ArtifactVersion to update.
     */
    where: ArtifactVersionWhereUniqueInput
  }

  /**
   * ArtifactVersion updateMany
   */
  export type ArtifactVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArtifactVersions.
     */
    data: XOR<ArtifactVersionUpdateManyMutationInput, ArtifactVersionUncheckedUpdateManyInput>
    /**
     * Filter which ArtifactVersions to update
     */
    where?: ArtifactVersionWhereInput
    /**
     * Limit how many ArtifactVersions to update.
     */
    limit?: number
  }

  /**
   * ArtifactVersion updateManyAndReturn
   */
  export type ArtifactVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * The data used to update ArtifactVersions.
     */
    data: XOR<ArtifactVersionUpdateManyMutationInput, ArtifactVersionUncheckedUpdateManyInput>
    /**
     * Filter which ArtifactVersions to update
     */
    where?: ArtifactVersionWhereInput
    /**
     * Limit how many ArtifactVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtifactVersion upsert
   */
  export type ArtifactVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the ArtifactVersion to update in case it exists.
     */
    where: ArtifactVersionWhereUniqueInput
    /**
     * In case the ArtifactVersion found by the `where` argument doesn't exist, create a new ArtifactVersion with this data.
     */
    create: XOR<ArtifactVersionCreateInput, ArtifactVersionUncheckedCreateInput>
    /**
     * In case the ArtifactVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtifactVersionUpdateInput, ArtifactVersionUncheckedUpdateInput>
  }

  /**
   * ArtifactVersion delete
   */
  export type ArtifactVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
    /**
     * Filter which ArtifactVersion to delete.
     */
    where: ArtifactVersionWhereUniqueInput
  }

  /**
   * ArtifactVersion deleteMany
   */
  export type ArtifactVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtifactVersions to delete
     */
    where?: ArtifactVersionWhereInput
    /**
     * Limit how many ArtifactVersions to delete.
     */
    limit?: number
  }

  /**
   * ArtifactVersion without action
   */
  export type ArtifactVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactVersion
     */
    select?: ArtifactVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactVersion
     */
    omit?: ArtifactVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactVersionInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeBase
   */

  export type AggregateKnowledgeBase = {
    _count: KnowledgeBaseCountAggregateOutputType | null
    _avg: KnowledgeBaseAvgAggregateOutputType | null
    _sum: KnowledgeBaseSumAggregateOutputType | null
    _min: KnowledgeBaseMinAggregateOutputType | null
    _max: KnowledgeBaseMaxAggregateOutputType | null
  }

  export type KnowledgeBaseAvgAggregateOutputType = {
    documentCount: number | null
  }

  export type KnowledgeBaseSumAggregateOutputType = {
    documentCount: number | null
  }

  export type KnowledgeBaseMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    scope: string | null
    projectId: string | null
    documentCount: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    vectorStoreId: string | null
  }

  export type KnowledgeBaseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    scope: string | null
    projectId: string | null
    documentCount: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    vectorStoreId: string | null
  }

  export type KnowledgeBaseCountAggregateOutputType = {
    id: number
    name: number
    description: number
    scope: number
    projectId: number
    documentCount: number
    createdBy: number
    createdAt: number
    updatedAt: number
    vectorStoreId: number
    _all: number
  }


  export type KnowledgeBaseAvgAggregateInputType = {
    documentCount?: true
  }

  export type KnowledgeBaseSumAggregateInputType = {
    documentCount?: true
  }

  export type KnowledgeBaseMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    scope?: true
    projectId?: true
    documentCount?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    vectorStoreId?: true
  }

  export type KnowledgeBaseMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    scope?: true
    projectId?: true
    documentCount?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    vectorStoreId?: true
  }

  export type KnowledgeBaseCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    scope?: true
    projectId?: true
    documentCount?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    vectorStoreId?: true
    _all?: true
  }

  export type KnowledgeBaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBase to aggregate.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeBases
    **/
    _count?: true | KnowledgeBaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeBaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeBaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeBaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeBaseMaxAggregateInputType
  }

  export type GetKnowledgeBaseAggregateType<T extends KnowledgeBaseAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeBase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeBase[P]>
      : GetScalarType<T[P], AggregateKnowledgeBase[P]>
  }




  export type KnowledgeBaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseWhereInput
    orderBy?: KnowledgeBaseOrderByWithAggregationInput | KnowledgeBaseOrderByWithAggregationInput[]
    by: KnowledgeBaseScalarFieldEnum[] | KnowledgeBaseScalarFieldEnum
    having?: KnowledgeBaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeBaseCountAggregateInputType | true
    _avg?: KnowledgeBaseAvgAggregateInputType
    _sum?: KnowledgeBaseSumAggregateInputType
    _min?: KnowledgeBaseMinAggregateInputType
    _max?: KnowledgeBaseMaxAggregateInputType
  }

  export type KnowledgeBaseGroupByOutputType = {
    id: string
    name: string
    description: string | null
    scope: string
    projectId: string | null
    documentCount: number
    createdBy: string
    createdAt: Date
    updatedAt: Date
    vectorStoreId: string | null
    _count: KnowledgeBaseCountAggregateOutputType | null
    _avg: KnowledgeBaseAvgAggregateOutputType | null
    _sum: KnowledgeBaseSumAggregateOutputType | null
    _min: KnowledgeBaseMinAggregateOutputType | null
    _max: KnowledgeBaseMaxAggregateOutputType | null
  }

  type GetKnowledgeBaseGroupByPayload<T extends KnowledgeBaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeBaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeBaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeBaseGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeBaseGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeBaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    scope?: boolean
    projectId?: boolean
    documentCount?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vectorStoreId?: boolean
    project?: boolean | KnowledgeBase$projectArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | KnowledgeBase$documentsArgs<ExtArgs>
    permissions?: boolean | KnowledgeBase$permissionsArgs<ExtArgs>
    _count?: boolean | KnowledgeBaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBase"]>

  export type KnowledgeBaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    scope?: boolean
    projectId?: boolean
    documentCount?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vectorStoreId?: boolean
    project?: boolean | KnowledgeBase$projectArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBase"]>

  export type KnowledgeBaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    scope?: boolean
    projectId?: boolean
    documentCount?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vectorStoreId?: boolean
    project?: boolean | KnowledgeBase$projectArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBase"]>

  export type KnowledgeBaseSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    scope?: boolean
    projectId?: boolean
    documentCount?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vectorStoreId?: boolean
  }

  export type KnowledgeBaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "scope" | "projectId" | "documentCount" | "createdBy" | "createdAt" | "updatedAt" | "vectorStoreId", ExtArgs["result"]["knowledgeBase"]>
  export type KnowledgeBaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | KnowledgeBase$projectArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    documents?: boolean | KnowledgeBase$documentsArgs<ExtArgs>
    permissions?: boolean | KnowledgeBase$permissionsArgs<ExtArgs>
    _count?: boolean | KnowledgeBaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KnowledgeBaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | KnowledgeBase$projectArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KnowledgeBaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | KnowledgeBase$projectArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $KnowledgeBasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeBase"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      documents: Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>[]
      permissions: Prisma.$KnowledgeBasePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      scope: string
      projectId: string | null
      documentCount: number
      createdBy: string
      createdAt: Date
      updatedAt: Date
      vectorStoreId: string | null
    }, ExtArgs["result"]["knowledgeBase"]>
    composites: {}
  }

  type KnowledgeBaseGetPayload<S extends boolean | null | undefined | KnowledgeBaseDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeBasePayload, S>

  type KnowledgeBaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeBaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeBaseCountAggregateInputType | true
    }

  export interface KnowledgeBaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeBase'], meta: { name: 'KnowledgeBase' } }
    /**
     * Find zero or one KnowledgeBase that matches the filter.
     * @param {KnowledgeBaseFindUniqueArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeBaseFindUniqueArgs>(args: SelectSubset<T, KnowledgeBaseFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeBase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeBaseFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeBaseFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeBaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeBase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseFindFirstArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeBaseFindFirstArgs>(args?: SelectSubset<T, KnowledgeBaseFindFirstArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeBase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseFindFirstOrThrowArgs} args - Arguments to find a KnowledgeBase
     * @example
     * // Get one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeBaseFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeBaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeBases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeBases
     * const knowledgeBases = await prisma.knowledgeBase.findMany()
     * 
     * // Get first 10 KnowledgeBases
     * const knowledgeBases = await prisma.knowledgeBase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeBaseWithIdOnly = await prisma.knowledgeBase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeBaseFindManyArgs>(args?: SelectSubset<T, KnowledgeBaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeBase.
     * @param {KnowledgeBaseCreateArgs} args - Arguments to create a KnowledgeBase.
     * @example
     * // Create one KnowledgeBase
     * const KnowledgeBase = await prisma.knowledgeBase.create({
     *   data: {
     *     // ... data to create a KnowledgeBase
     *   }
     * })
     * 
     */
    create<T extends KnowledgeBaseCreateArgs>(args: SelectSubset<T, KnowledgeBaseCreateArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeBases.
     * @param {KnowledgeBaseCreateManyArgs} args - Arguments to create many KnowledgeBases.
     * @example
     * // Create many KnowledgeBases
     * const knowledgeBase = await prisma.knowledgeBase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeBaseCreateManyArgs>(args?: SelectSubset<T, KnowledgeBaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeBases and returns the data saved in the database.
     * @param {KnowledgeBaseCreateManyAndReturnArgs} args - Arguments to create many KnowledgeBases.
     * @example
     * // Create many KnowledgeBases
     * const knowledgeBase = await prisma.knowledgeBase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeBases and only return the `id`
     * const knowledgeBaseWithIdOnly = await prisma.knowledgeBase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeBaseCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeBaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeBase.
     * @param {KnowledgeBaseDeleteArgs} args - Arguments to delete one KnowledgeBase.
     * @example
     * // Delete one KnowledgeBase
     * const KnowledgeBase = await prisma.knowledgeBase.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeBase
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeBaseDeleteArgs>(args: SelectSubset<T, KnowledgeBaseDeleteArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeBase.
     * @param {KnowledgeBaseUpdateArgs} args - Arguments to update one KnowledgeBase.
     * @example
     * // Update one KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeBaseUpdateArgs>(args: SelectSubset<T, KnowledgeBaseUpdateArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeBases.
     * @param {KnowledgeBaseDeleteManyArgs} args - Arguments to filter KnowledgeBases to delete.
     * @example
     * // Delete a few KnowledgeBases
     * const { count } = await prisma.knowledgeBase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeBaseDeleteManyArgs>(args?: SelectSubset<T, KnowledgeBaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeBases
     * const knowledgeBase = await prisma.knowledgeBase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeBaseUpdateManyArgs>(args: SelectSubset<T, KnowledgeBaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBases and returns the data updated in the database.
     * @param {KnowledgeBaseUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeBases.
     * @example
     * // Update many KnowledgeBases
     * const knowledgeBase = await prisma.knowledgeBase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeBases and only return the `id`
     * const knowledgeBaseWithIdOnly = await prisma.knowledgeBase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeBaseUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeBaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeBase.
     * @param {KnowledgeBaseUpsertArgs} args - Arguments to update or create a KnowledgeBase.
     * @example
     * // Update or create a KnowledgeBase
     * const knowledgeBase = await prisma.knowledgeBase.upsert({
     *   create: {
     *     // ... data to create a KnowledgeBase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeBase we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeBaseUpsertArgs>(args: SelectSubset<T, KnowledgeBaseUpsertArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeBases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseCountArgs} args - Arguments to filter KnowledgeBases to count.
     * @example
     * // Count the number of KnowledgeBases
     * const count = await prisma.knowledgeBase.count({
     *   where: {
     *     // ... the filter for the KnowledgeBases we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeBaseCountArgs>(
      args?: Subset<T, KnowledgeBaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeBaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeBaseAggregateArgs>(args: Subset<T, KnowledgeBaseAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeBaseAggregateType<T>>

    /**
     * Group by KnowledgeBase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeBaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeBaseGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeBaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeBaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeBaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeBase model
   */
  readonly fields: KnowledgeBaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeBase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeBaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends KnowledgeBase$projectArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBase$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    documents<T extends KnowledgeBase$documentsArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBase$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends KnowledgeBase$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBase$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeBase model
   */
  interface KnowledgeBaseFieldRefs {
    readonly id: FieldRef<"KnowledgeBase", 'String'>
    readonly name: FieldRef<"KnowledgeBase", 'String'>
    readonly description: FieldRef<"KnowledgeBase", 'String'>
    readonly scope: FieldRef<"KnowledgeBase", 'String'>
    readonly projectId: FieldRef<"KnowledgeBase", 'String'>
    readonly documentCount: FieldRef<"KnowledgeBase", 'Int'>
    readonly createdBy: FieldRef<"KnowledgeBase", 'String'>
    readonly createdAt: FieldRef<"KnowledgeBase", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeBase", 'DateTime'>
    readonly vectorStoreId: FieldRef<"KnowledgeBase", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeBase findUnique
   */
  export type KnowledgeBaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase findUniqueOrThrow
   */
  export type KnowledgeBaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase findFirst
   */
  export type KnowledgeBaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBases.
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBases.
     */
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * KnowledgeBase findFirstOrThrow
   */
  export type KnowledgeBaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBase to fetch.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBases.
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBases.
     */
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * KnowledgeBase findMany
   */
  export type KnowledgeBaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBases to fetch.
     */
    where?: KnowledgeBaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBases to fetch.
     */
    orderBy?: KnowledgeBaseOrderByWithRelationInput | KnowledgeBaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeBases.
     */
    cursor?: KnowledgeBaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBases.
     */
    skip?: number
    distinct?: KnowledgeBaseScalarFieldEnum | KnowledgeBaseScalarFieldEnum[]
  }

  /**
   * KnowledgeBase create
   */
  export type KnowledgeBaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeBase.
     */
    data: XOR<KnowledgeBaseCreateInput, KnowledgeBaseUncheckedCreateInput>
  }

  /**
   * KnowledgeBase createMany
   */
  export type KnowledgeBaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeBases.
     */
    data: KnowledgeBaseCreateManyInput | KnowledgeBaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeBase createManyAndReturn
   */
  export type KnowledgeBaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeBases.
     */
    data: KnowledgeBaseCreateManyInput | KnowledgeBaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeBase update
   */
  export type KnowledgeBaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeBase.
     */
    data: XOR<KnowledgeBaseUpdateInput, KnowledgeBaseUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeBase to update.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase updateMany
   */
  export type KnowledgeBaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeBases.
     */
    data: XOR<KnowledgeBaseUpdateManyMutationInput, KnowledgeBaseUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBases to update
     */
    where?: KnowledgeBaseWhereInput
    /**
     * Limit how many KnowledgeBases to update.
     */
    limit?: number
  }

  /**
   * KnowledgeBase updateManyAndReturn
   */
  export type KnowledgeBaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeBases.
     */
    data: XOR<KnowledgeBaseUpdateManyMutationInput, KnowledgeBaseUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBases to update
     */
    where?: KnowledgeBaseWhereInput
    /**
     * Limit how many KnowledgeBases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeBase upsert
   */
  export type KnowledgeBaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeBase to update in case it exists.
     */
    where: KnowledgeBaseWhereUniqueInput
    /**
     * In case the KnowledgeBase found by the `where` argument doesn't exist, create a new KnowledgeBase with this data.
     */
    create: XOR<KnowledgeBaseCreateInput, KnowledgeBaseUncheckedCreateInput>
    /**
     * In case the KnowledgeBase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeBaseUpdateInput, KnowledgeBaseUncheckedUpdateInput>
  }

  /**
   * KnowledgeBase delete
   */
  export type KnowledgeBaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeBase to delete.
     */
    where: KnowledgeBaseWhereUniqueInput
  }

  /**
   * KnowledgeBase deleteMany
   */
  export type KnowledgeBaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBases to delete
     */
    where?: KnowledgeBaseWhereInput
    /**
     * Limit how many KnowledgeBases to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeBase.project
   */
  export type KnowledgeBase$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * KnowledgeBase.documents
   */
  export type KnowledgeBase$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
    where?: KnowledgeBaseDocumentWhereInput
    orderBy?: KnowledgeBaseDocumentOrderByWithRelationInput | KnowledgeBaseDocumentOrderByWithRelationInput[]
    cursor?: KnowledgeBaseDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBaseDocumentScalarFieldEnum | KnowledgeBaseDocumentScalarFieldEnum[]
  }

  /**
   * KnowledgeBase.permissions
   */
  export type KnowledgeBase$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
    where?: KnowledgeBasePermissionWhereInput
    orderBy?: KnowledgeBasePermissionOrderByWithRelationInput | KnowledgeBasePermissionOrderByWithRelationInput[]
    cursor?: KnowledgeBasePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBasePermissionScalarFieldEnum | KnowledgeBasePermissionScalarFieldEnum[]
  }

  /**
   * KnowledgeBase without action
   */
  export type KnowledgeBaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBase
     */
    select?: KnowledgeBaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBase
     */
    omit?: KnowledgeBaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeBaseDocument
   */

  export type AggregateKnowledgeBaseDocument = {
    _count: KnowledgeBaseDocumentCountAggregateOutputType | null
    _avg: KnowledgeBaseDocumentAvgAggregateOutputType | null
    _sum: KnowledgeBaseDocumentSumAggregateOutputType | null
    _min: KnowledgeBaseDocumentMinAggregateOutputType | null
    _max: KnowledgeBaseDocumentMaxAggregateOutputType | null
  }

  export type KnowledgeBaseDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type KnowledgeBaseDocumentSumAggregateOutputType = {
    fileSize: bigint | null
  }

  export type KnowledgeBaseDocumentMinAggregateOutputType = {
    id: string | null
    knowledgeBaseId: string | null
    fileName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: bigint | null
    s3Bucket: string | null
    s3Key: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    vectorIds: string | null
  }

  export type KnowledgeBaseDocumentMaxAggregateOutputType = {
    id: string | null
    knowledgeBaseId: string | null
    fileName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: bigint | null
    s3Bucket: string | null
    s3Key: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
    vectorIds: string | null
  }

  export type KnowledgeBaseDocumentCountAggregateOutputType = {
    id: number
    knowledgeBaseId: number
    fileName: number
    filePath: number
    fileType: number
    fileSize: number
    s3Bucket: number
    s3Key: number
    uploadedBy: number
    uploadedAt: number
    metadata: number
    vectorIds: number
    _all: number
  }


  export type KnowledgeBaseDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type KnowledgeBaseDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type KnowledgeBaseDocumentMinAggregateInputType = {
    id?: true
    knowledgeBaseId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    s3Bucket?: true
    s3Key?: true
    uploadedBy?: true
    uploadedAt?: true
    vectorIds?: true
  }

  export type KnowledgeBaseDocumentMaxAggregateInputType = {
    id?: true
    knowledgeBaseId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    s3Bucket?: true
    s3Key?: true
    uploadedBy?: true
    uploadedAt?: true
    vectorIds?: true
  }

  export type KnowledgeBaseDocumentCountAggregateInputType = {
    id?: true
    knowledgeBaseId?: true
    fileName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    s3Bucket?: true
    s3Key?: true
    uploadedBy?: true
    uploadedAt?: true
    metadata?: true
    vectorIds?: true
    _all?: true
  }

  export type KnowledgeBaseDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBaseDocument to aggregate.
     */
    where?: KnowledgeBaseDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseDocuments to fetch.
     */
    orderBy?: KnowledgeBaseDocumentOrderByWithRelationInput | KnowledgeBaseDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeBaseDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeBaseDocuments
    **/
    _count?: true | KnowledgeBaseDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeBaseDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeBaseDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeBaseDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeBaseDocumentMaxAggregateInputType
  }

  export type GetKnowledgeBaseDocumentAggregateType<T extends KnowledgeBaseDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeBaseDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeBaseDocument[P]>
      : GetScalarType<T[P], AggregateKnowledgeBaseDocument[P]>
  }




  export type KnowledgeBaseDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseDocumentWhereInput
    orderBy?: KnowledgeBaseDocumentOrderByWithAggregationInput | KnowledgeBaseDocumentOrderByWithAggregationInput[]
    by: KnowledgeBaseDocumentScalarFieldEnum[] | KnowledgeBaseDocumentScalarFieldEnum
    having?: KnowledgeBaseDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeBaseDocumentCountAggregateInputType | true
    _avg?: KnowledgeBaseDocumentAvgAggregateInputType
    _sum?: KnowledgeBaseDocumentSumAggregateInputType
    _min?: KnowledgeBaseDocumentMinAggregateInputType
    _max?: KnowledgeBaseDocumentMaxAggregateInputType
  }

  export type KnowledgeBaseDocumentGroupByOutputType = {
    id: string
    knowledgeBaseId: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint
    s3Bucket: string
    s3Key: string
    uploadedBy: string
    uploadedAt: Date
    metadata: JsonValue | null
    vectorIds: string | null
    _count: KnowledgeBaseDocumentCountAggregateOutputType | null
    _avg: KnowledgeBaseDocumentAvgAggregateOutputType | null
    _sum: KnowledgeBaseDocumentSumAggregateOutputType | null
    _min: KnowledgeBaseDocumentMinAggregateOutputType | null
    _max: KnowledgeBaseDocumentMaxAggregateOutputType | null
  }

  type GetKnowledgeBaseDocumentGroupByPayload<T extends KnowledgeBaseDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeBaseDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeBaseDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeBaseDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeBaseDocumentGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeBaseDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeBaseId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    s3Bucket?: boolean
    s3Key?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    metadata?: boolean
    vectorIds?: boolean
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBaseDocument"]>

  export type KnowledgeBaseDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeBaseId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    s3Bucket?: boolean
    s3Key?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    metadata?: boolean
    vectorIds?: boolean
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBaseDocument"]>

  export type KnowledgeBaseDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeBaseId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    s3Bucket?: boolean
    s3Key?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    metadata?: boolean
    vectorIds?: boolean
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBaseDocument"]>

  export type KnowledgeBaseDocumentSelectScalar = {
    id?: boolean
    knowledgeBaseId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    s3Bucket?: boolean
    s3Key?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    metadata?: boolean
    vectorIds?: boolean
  }

  export type KnowledgeBaseDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "knowledgeBaseId" | "fileName" | "filePath" | "fileType" | "fileSize" | "s3Bucket" | "s3Key" | "uploadedBy" | "uploadedAt" | "metadata" | "vectorIds", ExtArgs["result"]["knowledgeBaseDocument"]>
  export type KnowledgeBaseDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KnowledgeBaseDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type KnowledgeBaseDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $KnowledgeBaseDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeBaseDocument"
    objects: {
      knowledgeBase: Prisma.$KnowledgeBasePayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      knowledgeBaseId: string
      fileName: string
      filePath: string
      fileType: string
      fileSize: bigint
      s3Bucket: string
      s3Key: string
      uploadedBy: string
      uploadedAt: Date
      metadata: Prisma.JsonValue | null
      vectorIds: string | null
    }, ExtArgs["result"]["knowledgeBaseDocument"]>
    composites: {}
  }

  type KnowledgeBaseDocumentGetPayload<S extends boolean | null | undefined | KnowledgeBaseDocumentDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload, S>

  type KnowledgeBaseDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeBaseDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeBaseDocumentCountAggregateInputType | true
    }

  export interface KnowledgeBaseDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeBaseDocument'], meta: { name: 'KnowledgeBaseDocument' } }
    /**
     * Find zero or one KnowledgeBaseDocument that matches the filter.
     * @param {KnowledgeBaseDocumentFindUniqueArgs} args - Arguments to find a KnowledgeBaseDocument
     * @example
     * // Get one KnowledgeBaseDocument
     * const knowledgeBaseDocument = await prisma.knowledgeBaseDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeBaseDocumentFindUniqueArgs>(args: SelectSubset<T, KnowledgeBaseDocumentFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeBaseDocumentClient<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeBaseDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeBaseDocumentFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeBaseDocument
     * @example
     * // Get one KnowledgeBaseDocument
     * const knowledgeBaseDocument = await prisma.knowledgeBaseDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeBaseDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeBaseDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseDocumentClient<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeBaseDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseDocumentFindFirstArgs} args - Arguments to find a KnowledgeBaseDocument
     * @example
     * // Get one KnowledgeBaseDocument
     * const knowledgeBaseDocument = await prisma.knowledgeBaseDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeBaseDocumentFindFirstArgs>(args?: SelectSubset<T, KnowledgeBaseDocumentFindFirstArgs<ExtArgs>>): Prisma__KnowledgeBaseDocumentClient<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeBaseDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseDocumentFindFirstOrThrowArgs} args - Arguments to find a KnowledgeBaseDocument
     * @example
     * // Get one KnowledgeBaseDocument
     * const knowledgeBaseDocument = await prisma.knowledgeBaseDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeBaseDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeBaseDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseDocumentClient<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeBaseDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeBaseDocuments
     * const knowledgeBaseDocuments = await prisma.knowledgeBaseDocument.findMany()
     * 
     * // Get first 10 KnowledgeBaseDocuments
     * const knowledgeBaseDocuments = await prisma.knowledgeBaseDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeBaseDocumentWithIdOnly = await prisma.knowledgeBaseDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeBaseDocumentFindManyArgs>(args?: SelectSubset<T, KnowledgeBaseDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeBaseDocument.
     * @param {KnowledgeBaseDocumentCreateArgs} args - Arguments to create a KnowledgeBaseDocument.
     * @example
     * // Create one KnowledgeBaseDocument
     * const KnowledgeBaseDocument = await prisma.knowledgeBaseDocument.create({
     *   data: {
     *     // ... data to create a KnowledgeBaseDocument
     *   }
     * })
     * 
     */
    create<T extends KnowledgeBaseDocumentCreateArgs>(args: SelectSubset<T, KnowledgeBaseDocumentCreateArgs<ExtArgs>>): Prisma__KnowledgeBaseDocumentClient<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeBaseDocuments.
     * @param {KnowledgeBaseDocumentCreateManyArgs} args - Arguments to create many KnowledgeBaseDocuments.
     * @example
     * // Create many KnowledgeBaseDocuments
     * const knowledgeBaseDocument = await prisma.knowledgeBaseDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeBaseDocumentCreateManyArgs>(args?: SelectSubset<T, KnowledgeBaseDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeBaseDocuments and returns the data saved in the database.
     * @param {KnowledgeBaseDocumentCreateManyAndReturnArgs} args - Arguments to create many KnowledgeBaseDocuments.
     * @example
     * // Create many KnowledgeBaseDocuments
     * const knowledgeBaseDocument = await prisma.knowledgeBaseDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeBaseDocuments and only return the `id`
     * const knowledgeBaseDocumentWithIdOnly = await prisma.knowledgeBaseDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeBaseDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeBaseDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeBaseDocument.
     * @param {KnowledgeBaseDocumentDeleteArgs} args - Arguments to delete one KnowledgeBaseDocument.
     * @example
     * // Delete one KnowledgeBaseDocument
     * const KnowledgeBaseDocument = await prisma.knowledgeBaseDocument.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeBaseDocument
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeBaseDocumentDeleteArgs>(args: SelectSubset<T, KnowledgeBaseDocumentDeleteArgs<ExtArgs>>): Prisma__KnowledgeBaseDocumentClient<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeBaseDocument.
     * @param {KnowledgeBaseDocumentUpdateArgs} args - Arguments to update one KnowledgeBaseDocument.
     * @example
     * // Update one KnowledgeBaseDocument
     * const knowledgeBaseDocument = await prisma.knowledgeBaseDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeBaseDocumentUpdateArgs>(args: SelectSubset<T, KnowledgeBaseDocumentUpdateArgs<ExtArgs>>): Prisma__KnowledgeBaseDocumentClient<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeBaseDocuments.
     * @param {KnowledgeBaseDocumentDeleteManyArgs} args - Arguments to filter KnowledgeBaseDocuments to delete.
     * @example
     * // Delete a few KnowledgeBaseDocuments
     * const { count } = await prisma.knowledgeBaseDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeBaseDocumentDeleteManyArgs>(args?: SelectSubset<T, KnowledgeBaseDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBaseDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeBaseDocuments
     * const knowledgeBaseDocument = await prisma.knowledgeBaseDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeBaseDocumentUpdateManyArgs>(args: SelectSubset<T, KnowledgeBaseDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBaseDocuments and returns the data updated in the database.
     * @param {KnowledgeBaseDocumentUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeBaseDocuments.
     * @example
     * // Update many KnowledgeBaseDocuments
     * const knowledgeBaseDocument = await prisma.knowledgeBaseDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeBaseDocuments and only return the `id`
     * const knowledgeBaseDocumentWithIdOnly = await prisma.knowledgeBaseDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeBaseDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeBaseDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeBaseDocument.
     * @param {KnowledgeBaseDocumentUpsertArgs} args - Arguments to update or create a KnowledgeBaseDocument.
     * @example
     * // Update or create a KnowledgeBaseDocument
     * const knowledgeBaseDocument = await prisma.knowledgeBaseDocument.upsert({
     *   create: {
     *     // ... data to create a KnowledgeBaseDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeBaseDocument we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeBaseDocumentUpsertArgs>(args: SelectSubset<T, KnowledgeBaseDocumentUpsertArgs<ExtArgs>>): Prisma__KnowledgeBaseDocumentClient<$Result.GetResult<Prisma.$KnowledgeBaseDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeBaseDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseDocumentCountArgs} args - Arguments to filter KnowledgeBaseDocuments to count.
     * @example
     * // Count the number of KnowledgeBaseDocuments
     * const count = await prisma.knowledgeBaseDocument.count({
     *   where: {
     *     // ... the filter for the KnowledgeBaseDocuments we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeBaseDocumentCountArgs>(
      args?: Subset<T, KnowledgeBaseDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeBaseDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeBaseDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeBaseDocumentAggregateArgs>(args: Subset<T, KnowledgeBaseDocumentAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeBaseDocumentAggregateType<T>>

    /**
     * Group by KnowledgeBaseDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeBaseDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeBaseDocumentGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeBaseDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeBaseDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeBaseDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeBaseDocument model
   */
  readonly fields: KnowledgeBaseDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeBaseDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeBaseDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    knowledgeBase<T extends KnowledgeBaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBaseDefaultArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeBaseDocument model
   */
  interface KnowledgeBaseDocumentFieldRefs {
    readonly id: FieldRef<"KnowledgeBaseDocument", 'String'>
    readonly knowledgeBaseId: FieldRef<"KnowledgeBaseDocument", 'String'>
    readonly fileName: FieldRef<"KnowledgeBaseDocument", 'String'>
    readonly filePath: FieldRef<"KnowledgeBaseDocument", 'String'>
    readonly fileType: FieldRef<"KnowledgeBaseDocument", 'String'>
    readonly fileSize: FieldRef<"KnowledgeBaseDocument", 'BigInt'>
    readonly s3Bucket: FieldRef<"KnowledgeBaseDocument", 'String'>
    readonly s3Key: FieldRef<"KnowledgeBaseDocument", 'String'>
    readonly uploadedBy: FieldRef<"KnowledgeBaseDocument", 'String'>
    readonly uploadedAt: FieldRef<"KnowledgeBaseDocument", 'DateTime'>
    readonly metadata: FieldRef<"KnowledgeBaseDocument", 'Json'>
    readonly vectorIds: FieldRef<"KnowledgeBaseDocument", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeBaseDocument findUnique
   */
  export type KnowledgeBaseDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseDocument to fetch.
     */
    where: KnowledgeBaseDocumentWhereUniqueInput
  }

  /**
   * KnowledgeBaseDocument findUniqueOrThrow
   */
  export type KnowledgeBaseDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseDocument to fetch.
     */
    where: KnowledgeBaseDocumentWhereUniqueInput
  }

  /**
   * KnowledgeBaseDocument findFirst
   */
  export type KnowledgeBaseDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseDocument to fetch.
     */
    where?: KnowledgeBaseDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseDocuments to fetch.
     */
    orderBy?: KnowledgeBaseDocumentOrderByWithRelationInput | KnowledgeBaseDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBaseDocuments.
     */
    cursor?: KnowledgeBaseDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBaseDocuments.
     */
    distinct?: KnowledgeBaseDocumentScalarFieldEnum | KnowledgeBaseDocumentScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseDocument findFirstOrThrow
   */
  export type KnowledgeBaseDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseDocument to fetch.
     */
    where?: KnowledgeBaseDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseDocuments to fetch.
     */
    orderBy?: KnowledgeBaseDocumentOrderByWithRelationInput | KnowledgeBaseDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBaseDocuments.
     */
    cursor?: KnowledgeBaseDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBaseDocuments.
     */
    distinct?: KnowledgeBaseDocumentScalarFieldEnum | KnowledgeBaseDocumentScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseDocument findMany
   */
  export type KnowledgeBaseDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseDocuments to fetch.
     */
    where?: KnowledgeBaseDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseDocuments to fetch.
     */
    orderBy?: KnowledgeBaseDocumentOrderByWithRelationInput | KnowledgeBaseDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeBaseDocuments.
     */
    cursor?: KnowledgeBaseDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseDocuments.
     */
    skip?: number
    distinct?: KnowledgeBaseDocumentScalarFieldEnum | KnowledgeBaseDocumentScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseDocument create
   */
  export type KnowledgeBaseDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeBaseDocument.
     */
    data: XOR<KnowledgeBaseDocumentCreateInput, KnowledgeBaseDocumentUncheckedCreateInput>
  }

  /**
   * KnowledgeBaseDocument createMany
   */
  export type KnowledgeBaseDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeBaseDocuments.
     */
    data: KnowledgeBaseDocumentCreateManyInput | KnowledgeBaseDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeBaseDocument createManyAndReturn
   */
  export type KnowledgeBaseDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeBaseDocuments.
     */
    data: KnowledgeBaseDocumentCreateManyInput | KnowledgeBaseDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeBaseDocument update
   */
  export type KnowledgeBaseDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeBaseDocument.
     */
    data: XOR<KnowledgeBaseDocumentUpdateInput, KnowledgeBaseDocumentUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeBaseDocument to update.
     */
    where: KnowledgeBaseDocumentWhereUniqueInput
  }

  /**
   * KnowledgeBaseDocument updateMany
   */
  export type KnowledgeBaseDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeBaseDocuments.
     */
    data: XOR<KnowledgeBaseDocumentUpdateManyMutationInput, KnowledgeBaseDocumentUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBaseDocuments to update
     */
    where?: KnowledgeBaseDocumentWhereInput
    /**
     * Limit how many KnowledgeBaseDocuments to update.
     */
    limit?: number
  }

  /**
   * KnowledgeBaseDocument updateManyAndReturn
   */
  export type KnowledgeBaseDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeBaseDocuments.
     */
    data: XOR<KnowledgeBaseDocumentUpdateManyMutationInput, KnowledgeBaseDocumentUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBaseDocuments to update
     */
    where?: KnowledgeBaseDocumentWhereInput
    /**
     * Limit how many KnowledgeBaseDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeBaseDocument upsert
   */
  export type KnowledgeBaseDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeBaseDocument to update in case it exists.
     */
    where: KnowledgeBaseDocumentWhereUniqueInput
    /**
     * In case the KnowledgeBaseDocument found by the `where` argument doesn't exist, create a new KnowledgeBaseDocument with this data.
     */
    create: XOR<KnowledgeBaseDocumentCreateInput, KnowledgeBaseDocumentUncheckedCreateInput>
    /**
     * In case the KnowledgeBaseDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeBaseDocumentUpdateInput, KnowledgeBaseDocumentUncheckedUpdateInput>
  }

  /**
   * KnowledgeBaseDocument delete
   */
  export type KnowledgeBaseDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeBaseDocument to delete.
     */
    where: KnowledgeBaseDocumentWhereUniqueInput
  }

  /**
   * KnowledgeBaseDocument deleteMany
   */
  export type KnowledgeBaseDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBaseDocuments to delete
     */
    where?: KnowledgeBaseDocumentWhereInput
    /**
     * Limit how many KnowledgeBaseDocuments to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeBaseDocument without action
   */
  export type KnowledgeBaseDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseDocument
     */
    select?: KnowledgeBaseDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBaseDocument
     */
    omit?: KnowledgeBaseDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseDocumentInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeBasePermission
   */

  export type AggregateKnowledgeBasePermission = {
    _count: KnowledgeBasePermissionCountAggregateOutputType | null
    _min: KnowledgeBasePermissionMinAggregateOutputType | null
    _max: KnowledgeBasePermissionMaxAggregateOutputType | null
  }

  export type KnowledgeBasePermissionMinAggregateOutputType = {
    id: string | null
    knowledgeBaseId: string | null
    userId: string | null
    roleId: string | null
    permissionType: string | null
    grantedAt: Date | null
  }

  export type KnowledgeBasePermissionMaxAggregateOutputType = {
    id: string | null
    knowledgeBaseId: string | null
    userId: string | null
    roleId: string | null
    permissionType: string | null
    grantedAt: Date | null
  }

  export type KnowledgeBasePermissionCountAggregateOutputType = {
    id: number
    knowledgeBaseId: number
    userId: number
    roleId: number
    permissionType: number
    grantedAt: number
    _all: number
  }


  export type KnowledgeBasePermissionMinAggregateInputType = {
    id?: true
    knowledgeBaseId?: true
    userId?: true
    roleId?: true
    permissionType?: true
    grantedAt?: true
  }

  export type KnowledgeBasePermissionMaxAggregateInputType = {
    id?: true
    knowledgeBaseId?: true
    userId?: true
    roleId?: true
    permissionType?: true
    grantedAt?: true
  }

  export type KnowledgeBasePermissionCountAggregateInputType = {
    id?: true
    knowledgeBaseId?: true
    userId?: true
    roleId?: true
    permissionType?: true
    grantedAt?: true
    _all?: true
  }

  export type KnowledgeBasePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBasePermission to aggregate.
     */
    where?: KnowledgeBasePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBasePermissions to fetch.
     */
    orderBy?: KnowledgeBasePermissionOrderByWithRelationInput | KnowledgeBasePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeBasePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBasePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBasePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeBasePermissions
    **/
    _count?: true | KnowledgeBasePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeBasePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeBasePermissionMaxAggregateInputType
  }

  export type GetKnowledgeBasePermissionAggregateType<T extends KnowledgeBasePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeBasePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeBasePermission[P]>
      : GetScalarType<T[P], AggregateKnowledgeBasePermission[P]>
  }




  export type KnowledgeBasePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBasePermissionWhereInput
    orderBy?: KnowledgeBasePermissionOrderByWithAggregationInput | KnowledgeBasePermissionOrderByWithAggregationInput[]
    by: KnowledgeBasePermissionScalarFieldEnum[] | KnowledgeBasePermissionScalarFieldEnum
    having?: KnowledgeBasePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeBasePermissionCountAggregateInputType | true
    _min?: KnowledgeBasePermissionMinAggregateInputType
    _max?: KnowledgeBasePermissionMaxAggregateInputType
  }

  export type KnowledgeBasePermissionGroupByOutputType = {
    id: string
    knowledgeBaseId: string
    userId: string | null
    roleId: string | null
    permissionType: string
    grantedAt: Date
    _count: KnowledgeBasePermissionCountAggregateOutputType | null
    _min: KnowledgeBasePermissionMinAggregateOutputType | null
    _max: KnowledgeBasePermissionMaxAggregateOutputType | null
  }

  type GetKnowledgeBasePermissionGroupByPayload<T extends KnowledgeBasePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeBasePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeBasePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeBasePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeBasePermissionGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeBasePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeBaseId?: boolean
    userId?: boolean
    roleId?: boolean
    permissionType?: boolean
    grantedAt?: boolean
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    role?: boolean | KnowledgeBasePermission$roleArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBasePermission"]>

  export type KnowledgeBasePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeBaseId?: boolean
    userId?: boolean
    roleId?: boolean
    permissionType?: boolean
    grantedAt?: boolean
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    role?: boolean | KnowledgeBasePermission$roleArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBasePermission"]>

  export type KnowledgeBasePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeBaseId?: boolean
    userId?: boolean
    roleId?: boolean
    permissionType?: boolean
    grantedAt?: boolean
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    role?: boolean | KnowledgeBasePermission$roleArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBasePermission"]>

  export type KnowledgeBasePermissionSelectScalar = {
    id?: boolean
    knowledgeBaseId?: boolean
    userId?: boolean
    roleId?: boolean
    permissionType?: boolean
    grantedAt?: boolean
  }

  export type KnowledgeBasePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "knowledgeBaseId" | "userId" | "roleId" | "permissionType" | "grantedAt", ExtArgs["result"]["knowledgeBasePermission"]>
  export type KnowledgeBasePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    role?: boolean | KnowledgeBasePermission$roleArgs<ExtArgs>
  }
  export type KnowledgeBasePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    role?: boolean | KnowledgeBasePermission$roleArgs<ExtArgs>
  }
  export type KnowledgeBasePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledgeBase?: boolean | KnowledgeBaseDefaultArgs<ExtArgs>
    role?: boolean | KnowledgeBasePermission$roleArgs<ExtArgs>
  }

  export type $KnowledgeBasePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeBasePermission"
    objects: {
      knowledgeBase: Prisma.$KnowledgeBasePayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      knowledgeBaseId: string
      userId: string | null
      roleId: string | null
      permissionType: string
      grantedAt: Date
    }, ExtArgs["result"]["knowledgeBasePermission"]>
    composites: {}
  }

  type KnowledgeBasePermissionGetPayload<S extends boolean | null | undefined | KnowledgeBasePermissionDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeBasePermissionPayload, S>

  type KnowledgeBasePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeBasePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeBasePermissionCountAggregateInputType | true
    }

  export interface KnowledgeBasePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeBasePermission'], meta: { name: 'KnowledgeBasePermission' } }
    /**
     * Find zero or one KnowledgeBasePermission that matches the filter.
     * @param {KnowledgeBasePermissionFindUniqueArgs} args - Arguments to find a KnowledgeBasePermission
     * @example
     * // Get one KnowledgeBasePermission
     * const knowledgeBasePermission = await prisma.knowledgeBasePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeBasePermissionFindUniqueArgs>(args: SelectSubset<T, KnowledgeBasePermissionFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeBasePermissionClient<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeBasePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeBasePermissionFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeBasePermission
     * @example
     * // Get one KnowledgeBasePermission
     * const knowledgeBasePermission = await prisma.knowledgeBasePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeBasePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeBasePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBasePermissionClient<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeBasePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBasePermissionFindFirstArgs} args - Arguments to find a KnowledgeBasePermission
     * @example
     * // Get one KnowledgeBasePermission
     * const knowledgeBasePermission = await prisma.knowledgeBasePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeBasePermissionFindFirstArgs>(args?: SelectSubset<T, KnowledgeBasePermissionFindFirstArgs<ExtArgs>>): Prisma__KnowledgeBasePermissionClient<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeBasePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBasePermissionFindFirstOrThrowArgs} args - Arguments to find a KnowledgeBasePermission
     * @example
     * // Get one KnowledgeBasePermission
     * const knowledgeBasePermission = await prisma.knowledgeBasePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeBasePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeBasePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBasePermissionClient<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeBasePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBasePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeBasePermissions
     * const knowledgeBasePermissions = await prisma.knowledgeBasePermission.findMany()
     * 
     * // Get first 10 KnowledgeBasePermissions
     * const knowledgeBasePermissions = await prisma.knowledgeBasePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeBasePermissionWithIdOnly = await prisma.knowledgeBasePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeBasePermissionFindManyArgs>(args?: SelectSubset<T, KnowledgeBasePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeBasePermission.
     * @param {KnowledgeBasePermissionCreateArgs} args - Arguments to create a KnowledgeBasePermission.
     * @example
     * // Create one KnowledgeBasePermission
     * const KnowledgeBasePermission = await prisma.knowledgeBasePermission.create({
     *   data: {
     *     // ... data to create a KnowledgeBasePermission
     *   }
     * })
     * 
     */
    create<T extends KnowledgeBasePermissionCreateArgs>(args: SelectSubset<T, KnowledgeBasePermissionCreateArgs<ExtArgs>>): Prisma__KnowledgeBasePermissionClient<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeBasePermissions.
     * @param {KnowledgeBasePermissionCreateManyArgs} args - Arguments to create many KnowledgeBasePermissions.
     * @example
     * // Create many KnowledgeBasePermissions
     * const knowledgeBasePermission = await prisma.knowledgeBasePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeBasePermissionCreateManyArgs>(args?: SelectSubset<T, KnowledgeBasePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeBasePermissions and returns the data saved in the database.
     * @param {KnowledgeBasePermissionCreateManyAndReturnArgs} args - Arguments to create many KnowledgeBasePermissions.
     * @example
     * // Create many KnowledgeBasePermissions
     * const knowledgeBasePermission = await prisma.knowledgeBasePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeBasePermissions and only return the `id`
     * const knowledgeBasePermissionWithIdOnly = await prisma.knowledgeBasePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeBasePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeBasePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeBasePermission.
     * @param {KnowledgeBasePermissionDeleteArgs} args - Arguments to delete one KnowledgeBasePermission.
     * @example
     * // Delete one KnowledgeBasePermission
     * const KnowledgeBasePermission = await prisma.knowledgeBasePermission.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeBasePermission
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeBasePermissionDeleteArgs>(args: SelectSubset<T, KnowledgeBasePermissionDeleteArgs<ExtArgs>>): Prisma__KnowledgeBasePermissionClient<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeBasePermission.
     * @param {KnowledgeBasePermissionUpdateArgs} args - Arguments to update one KnowledgeBasePermission.
     * @example
     * // Update one KnowledgeBasePermission
     * const knowledgeBasePermission = await prisma.knowledgeBasePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeBasePermissionUpdateArgs>(args: SelectSubset<T, KnowledgeBasePermissionUpdateArgs<ExtArgs>>): Prisma__KnowledgeBasePermissionClient<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeBasePermissions.
     * @param {KnowledgeBasePermissionDeleteManyArgs} args - Arguments to filter KnowledgeBasePermissions to delete.
     * @example
     * // Delete a few KnowledgeBasePermissions
     * const { count } = await prisma.knowledgeBasePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeBasePermissionDeleteManyArgs>(args?: SelectSubset<T, KnowledgeBasePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBasePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBasePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeBasePermissions
     * const knowledgeBasePermission = await prisma.knowledgeBasePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeBasePermissionUpdateManyArgs>(args: SelectSubset<T, KnowledgeBasePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBasePermissions and returns the data updated in the database.
     * @param {KnowledgeBasePermissionUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeBasePermissions.
     * @example
     * // Update many KnowledgeBasePermissions
     * const knowledgeBasePermission = await prisma.knowledgeBasePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeBasePermissions and only return the `id`
     * const knowledgeBasePermissionWithIdOnly = await prisma.knowledgeBasePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeBasePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeBasePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeBasePermission.
     * @param {KnowledgeBasePermissionUpsertArgs} args - Arguments to update or create a KnowledgeBasePermission.
     * @example
     * // Update or create a KnowledgeBasePermission
     * const knowledgeBasePermission = await prisma.knowledgeBasePermission.upsert({
     *   create: {
     *     // ... data to create a KnowledgeBasePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeBasePermission we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeBasePermissionUpsertArgs>(args: SelectSubset<T, KnowledgeBasePermissionUpsertArgs<ExtArgs>>): Prisma__KnowledgeBasePermissionClient<$Result.GetResult<Prisma.$KnowledgeBasePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeBasePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBasePermissionCountArgs} args - Arguments to filter KnowledgeBasePermissions to count.
     * @example
     * // Count the number of KnowledgeBasePermissions
     * const count = await prisma.knowledgeBasePermission.count({
     *   where: {
     *     // ... the filter for the KnowledgeBasePermissions we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeBasePermissionCountArgs>(
      args?: Subset<T, KnowledgeBasePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeBasePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeBasePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBasePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeBasePermissionAggregateArgs>(args: Subset<T, KnowledgeBasePermissionAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeBasePermissionAggregateType<T>>

    /**
     * Group by KnowledgeBasePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBasePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeBasePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeBasePermissionGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeBasePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeBasePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeBasePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeBasePermission model
   */
  readonly fields: KnowledgeBasePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeBasePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeBasePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    knowledgeBase<T extends KnowledgeBaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBaseDefaultArgs<ExtArgs>>): Prisma__KnowledgeBaseClient<$Result.GetResult<Prisma.$KnowledgeBasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends KnowledgeBasePermission$roleArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBasePermission$roleArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeBasePermission model
   */
  interface KnowledgeBasePermissionFieldRefs {
    readonly id: FieldRef<"KnowledgeBasePermission", 'String'>
    readonly knowledgeBaseId: FieldRef<"KnowledgeBasePermission", 'String'>
    readonly userId: FieldRef<"KnowledgeBasePermission", 'String'>
    readonly roleId: FieldRef<"KnowledgeBasePermission", 'String'>
    readonly permissionType: FieldRef<"KnowledgeBasePermission", 'String'>
    readonly grantedAt: FieldRef<"KnowledgeBasePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeBasePermission findUnique
   */
  export type KnowledgeBasePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBasePermission to fetch.
     */
    where: KnowledgeBasePermissionWhereUniqueInput
  }

  /**
   * KnowledgeBasePermission findUniqueOrThrow
   */
  export type KnowledgeBasePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBasePermission to fetch.
     */
    where: KnowledgeBasePermissionWhereUniqueInput
  }

  /**
   * KnowledgeBasePermission findFirst
   */
  export type KnowledgeBasePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBasePermission to fetch.
     */
    where?: KnowledgeBasePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBasePermissions to fetch.
     */
    orderBy?: KnowledgeBasePermissionOrderByWithRelationInput | KnowledgeBasePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBasePermissions.
     */
    cursor?: KnowledgeBasePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBasePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBasePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBasePermissions.
     */
    distinct?: KnowledgeBasePermissionScalarFieldEnum | KnowledgeBasePermissionScalarFieldEnum[]
  }

  /**
   * KnowledgeBasePermission findFirstOrThrow
   */
  export type KnowledgeBasePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBasePermission to fetch.
     */
    where?: KnowledgeBasePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBasePermissions to fetch.
     */
    orderBy?: KnowledgeBasePermissionOrderByWithRelationInput | KnowledgeBasePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBasePermissions.
     */
    cursor?: KnowledgeBasePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBasePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBasePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBasePermissions.
     */
    distinct?: KnowledgeBasePermissionScalarFieldEnum | KnowledgeBasePermissionScalarFieldEnum[]
  }

  /**
   * KnowledgeBasePermission findMany
   */
  export type KnowledgeBasePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBasePermissions to fetch.
     */
    where?: KnowledgeBasePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBasePermissions to fetch.
     */
    orderBy?: KnowledgeBasePermissionOrderByWithRelationInput | KnowledgeBasePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeBasePermissions.
     */
    cursor?: KnowledgeBasePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBasePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBasePermissions.
     */
    skip?: number
    distinct?: KnowledgeBasePermissionScalarFieldEnum | KnowledgeBasePermissionScalarFieldEnum[]
  }

  /**
   * KnowledgeBasePermission create
   */
  export type KnowledgeBasePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeBasePermission.
     */
    data: XOR<KnowledgeBasePermissionCreateInput, KnowledgeBasePermissionUncheckedCreateInput>
  }

  /**
   * KnowledgeBasePermission createMany
   */
  export type KnowledgeBasePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeBasePermissions.
     */
    data: KnowledgeBasePermissionCreateManyInput | KnowledgeBasePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeBasePermission createManyAndReturn
   */
  export type KnowledgeBasePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeBasePermissions.
     */
    data: KnowledgeBasePermissionCreateManyInput | KnowledgeBasePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeBasePermission update
   */
  export type KnowledgeBasePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeBasePermission.
     */
    data: XOR<KnowledgeBasePermissionUpdateInput, KnowledgeBasePermissionUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeBasePermission to update.
     */
    where: KnowledgeBasePermissionWhereUniqueInput
  }

  /**
   * KnowledgeBasePermission updateMany
   */
  export type KnowledgeBasePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeBasePermissions.
     */
    data: XOR<KnowledgeBasePermissionUpdateManyMutationInput, KnowledgeBasePermissionUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBasePermissions to update
     */
    where?: KnowledgeBasePermissionWhereInput
    /**
     * Limit how many KnowledgeBasePermissions to update.
     */
    limit?: number
  }

  /**
   * KnowledgeBasePermission updateManyAndReturn
   */
  export type KnowledgeBasePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeBasePermissions.
     */
    data: XOR<KnowledgeBasePermissionUpdateManyMutationInput, KnowledgeBasePermissionUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBasePermissions to update
     */
    where?: KnowledgeBasePermissionWhereInput
    /**
     * Limit how many KnowledgeBasePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeBasePermission upsert
   */
  export type KnowledgeBasePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeBasePermission to update in case it exists.
     */
    where: KnowledgeBasePermissionWhereUniqueInput
    /**
     * In case the KnowledgeBasePermission found by the `where` argument doesn't exist, create a new KnowledgeBasePermission with this data.
     */
    create: XOR<KnowledgeBasePermissionCreateInput, KnowledgeBasePermissionUncheckedCreateInput>
    /**
     * In case the KnowledgeBasePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeBasePermissionUpdateInput, KnowledgeBasePermissionUncheckedUpdateInput>
  }

  /**
   * KnowledgeBasePermission delete
   */
  export type KnowledgeBasePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeBasePermission to delete.
     */
    where: KnowledgeBasePermissionWhereUniqueInput
  }

  /**
   * KnowledgeBasePermission deleteMany
   */
  export type KnowledgeBasePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBasePermissions to delete
     */
    where?: KnowledgeBasePermissionWhereInput
    /**
     * Limit how many KnowledgeBasePermissions to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeBasePermission.role
   */
  export type KnowledgeBasePermission$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * KnowledgeBasePermission without action
   */
  export type KnowledgeBasePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBasePermission
     */
    select?: KnowledgeBasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeBasePermission
     */
    omit?: KnowledgeBasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBasePermissionInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    read: number
    metadata: number
    createdAt: number
    readAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    read?: true
    metadata?: true
    createdAt?: true
    readAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    read: boolean
    metadata: JsonValue | null
    createdAt: Date
    readAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    read?: boolean
    metadata?: boolean
    createdAt?: boolean
    readAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "read" | "metadata" | "createdAt" | "readAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      read: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resourceType: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resourceType: number
    resourceId: number
    previousState: number
    newState: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceType?: true
    resourceId?: true
    previousState?: true
    newState?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    resourceType: string
    resourceId: string
    previousState: JsonValue | null
    newState: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    previousState?: boolean
    newState?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    previousState?: boolean
    newState?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    previousState?: boolean
    newState?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceType?: boolean
    resourceId?: boolean
    previousState?: boolean
    newState?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resourceType" | "resourceId" | "previousState" | "newState" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      resourceType: string
      resourceId: string
      previousState: Prisma.JsonValue | null
      newState: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resourceType: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly previousState: FieldRef<"AuditLog", 'Json'>
    readonly newState: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model AgentConfiguration
   */

  export type AggregateAgentConfiguration = {
    _count: AgentConfigurationCountAggregateOutputType | null
    _avg: AgentConfigurationAvgAggregateOutputType | null
    _sum: AgentConfigurationSumAggregateOutputType | null
    _min: AgentConfigurationMinAggregateOutputType | null
    _max: AgentConfigurationMaxAggregateOutputType | null
  }

  export type AgentConfigurationAvgAggregateOutputType = {
    temperature: number | null
    maxTokens: number | null
  }

  export type AgentConfigurationSumAggregateOutputType = {
    temperature: number | null
    maxTokens: number | null
  }

  export type AgentConfigurationMinAggregateOutputType = {
    id: string | null
    agentType: string | null
    modelName: string | null
    temperature: number | null
    maxTokens: number | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type AgentConfigurationMaxAggregateOutputType = {
    id: string | null
    agentType: string | null
    modelName: string | null
    temperature: number | null
    maxTokens: number | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type AgentConfigurationCountAggregateOutputType = {
    id: number
    agentType: number
    modelName: number
    temperature: number
    maxTokens: number
    systemPrompt: number
    additionalParameters: number
    enabled: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type AgentConfigurationAvgAggregateInputType = {
    temperature?: true
    maxTokens?: true
  }

  export type AgentConfigurationSumAggregateInputType = {
    temperature?: true
    maxTokens?: true
  }

  export type AgentConfigurationMinAggregateInputType = {
    id?: true
    agentType?: true
    modelName?: true
    temperature?: true
    maxTokens?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type AgentConfigurationMaxAggregateInputType = {
    id?: true
    agentType?: true
    modelName?: true
    temperature?: true
    maxTokens?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type AgentConfigurationCountAggregateInputType = {
    id?: true
    agentType?: true
    modelName?: true
    temperature?: true
    maxTokens?: true
    systemPrompt?: true
    additionalParameters?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type AgentConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentConfiguration to aggregate.
     */
    where?: AgentConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentConfigurations to fetch.
     */
    orderBy?: AgentConfigurationOrderByWithRelationInput | AgentConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentConfigurations
    **/
    _count?: true | AgentConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentConfigurationMaxAggregateInputType
  }

  export type GetAgentConfigurationAggregateType<T extends AgentConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentConfiguration[P]>
      : GetScalarType<T[P], AggregateAgentConfiguration[P]>
  }




  export type AgentConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentConfigurationWhereInput
    orderBy?: AgentConfigurationOrderByWithAggregationInput | AgentConfigurationOrderByWithAggregationInput[]
    by: AgentConfigurationScalarFieldEnum[] | AgentConfigurationScalarFieldEnum
    having?: AgentConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentConfigurationCountAggregateInputType | true
    _avg?: AgentConfigurationAvgAggregateInputType
    _sum?: AgentConfigurationSumAggregateInputType
    _min?: AgentConfigurationMinAggregateInputType
    _max?: AgentConfigurationMaxAggregateInputType
  }

  export type AgentConfigurationGroupByOutputType = {
    id: string
    agentType: string
    modelName: string
    temperature: number
    maxTokens: number
    systemPrompt: JsonValue
    additionalParameters: JsonValue | null
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    updatedBy: string | null
    _count: AgentConfigurationCountAggregateOutputType | null
    _avg: AgentConfigurationAvgAggregateOutputType | null
    _sum: AgentConfigurationSumAggregateOutputType | null
    _min: AgentConfigurationMinAggregateOutputType | null
    _max: AgentConfigurationMaxAggregateOutputType | null
  }

  type GetAgentConfigurationGroupByPayload<T extends AgentConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], AgentConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type AgentConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentType?: boolean
    modelName?: boolean
    temperature?: boolean
    maxTokens?: boolean
    systemPrompt?: boolean
    additionalParameters?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["agentConfiguration"]>

  export type AgentConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentType?: boolean
    modelName?: boolean
    temperature?: boolean
    maxTokens?: boolean
    systemPrompt?: boolean
    additionalParameters?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["agentConfiguration"]>

  export type AgentConfigurationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentType?: boolean
    modelName?: boolean
    temperature?: boolean
    maxTokens?: boolean
    systemPrompt?: boolean
    additionalParameters?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["agentConfiguration"]>

  export type AgentConfigurationSelectScalar = {
    id?: boolean
    agentType?: boolean
    modelName?: boolean
    temperature?: boolean
    maxTokens?: boolean
    systemPrompt?: boolean
    additionalParameters?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type AgentConfigurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentType" | "modelName" | "temperature" | "maxTokens" | "systemPrompt" | "additionalParameters" | "enabled" | "createdAt" | "updatedAt" | "updatedBy", ExtArgs["result"]["agentConfiguration"]>

  export type $AgentConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentConfiguration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentType: string
      modelName: string
      temperature: number
      maxTokens: number
      systemPrompt: Prisma.JsonValue
      additionalParameters: Prisma.JsonValue | null
      enabled: boolean
      createdAt: Date
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["agentConfiguration"]>
    composites: {}
  }

  type AgentConfigurationGetPayload<S extends boolean | null | undefined | AgentConfigurationDefaultArgs> = $Result.GetResult<Prisma.$AgentConfigurationPayload, S>

  type AgentConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentConfigurationCountAggregateInputType | true
    }

  export interface AgentConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentConfiguration'], meta: { name: 'AgentConfiguration' } }
    /**
     * Find zero or one AgentConfiguration that matches the filter.
     * @param {AgentConfigurationFindUniqueArgs} args - Arguments to find a AgentConfiguration
     * @example
     * // Get one AgentConfiguration
     * const agentConfiguration = await prisma.agentConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentConfigurationFindUniqueArgs>(args: SelectSubset<T, AgentConfigurationFindUniqueArgs<ExtArgs>>): Prisma__AgentConfigurationClient<$Result.GetResult<Prisma.$AgentConfigurationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentConfiguration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentConfigurationFindUniqueOrThrowArgs} args - Arguments to find a AgentConfiguration
     * @example
     * // Get one AgentConfiguration
     * const agentConfiguration = await prisma.agentConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentConfigurationClient<$Result.GetResult<Prisma.$AgentConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConfigurationFindFirstArgs} args - Arguments to find a AgentConfiguration
     * @example
     * // Get one AgentConfiguration
     * const agentConfiguration = await prisma.agentConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentConfigurationFindFirstArgs>(args?: SelectSubset<T, AgentConfigurationFindFirstArgs<ExtArgs>>): Prisma__AgentConfigurationClient<$Result.GetResult<Prisma.$AgentConfigurationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConfigurationFindFirstOrThrowArgs} args - Arguments to find a AgentConfiguration
     * @example
     * // Get one AgentConfiguration
     * const agentConfiguration = await prisma.agentConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentConfigurationClient<$Result.GetResult<Prisma.$AgentConfigurationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentConfigurations
     * const agentConfigurations = await prisma.agentConfiguration.findMany()
     * 
     * // Get first 10 AgentConfigurations
     * const agentConfigurations = await prisma.agentConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentConfigurationWithIdOnly = await prisma.agentConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentConfigurationFindManyArgs>(args?: SelectSubset<T, AgentConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentConfiguration.
     * @param {AgentConfigurationCreateArgs} args - Arguments to create a AgentConfiguration.
     * @example
     * // Create one AgentConfiguration
     * const AgentConfiguration = await prisma.agentConfiguration.create({
     *   data: {
     *     // ... data to create a AgentConfiguration
     *   }
     * })
     * 
     */
    create<T extends AgentConfigurationCreateArgs>(args: SelectSubset<T, AgentConfigurationCreateArgs<ExtArgs>>): Prisma__AgentConfigurationClient<$Result.GetResult<Prisma.$AgentConfigurationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentConfigurations.
     * @param {AgentConfigurationCreateManyArgs} args - Arguments to create many AgentConfigurations.
     * @example
     * // Create many AgentConfigurations
     * const agentConfiguration = await prisma.agentConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentConfigurationCreateManyArgs>(args?: SelectSubset<T, AgentConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentConfigurations and returns the data saved in the database.
     * @param {AgentConfigurationCreateManyAndReturnArgs} args - Arguments to create many AgentConfigurations.
     * @example
     * // Create many AgentConfigurations
     * const agentConfiguration = await prisma.agentConfiguration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentConfigurations and only return the `id`
     * const agentConfigurationWithIdOnly = await prisma.agentConfiguration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentConfigurationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentConfiguration.
     * @param {AgentConfigurationDeleteArgs} args - Arguments to delete one AgentConfiguration.
     * @example
     * // Delete one AgentConfiguration
     * const AgentConfiguration = await prisma.agentConfiguration.delete({
     *   where: {
     *     // ... filter to delete one AgentConfiguration
     *   }
     * })
     * 
     */
    delete<T extends AgentConfigurationDeleteArgs>(args: SelectSubset<T, AgentConfigurationDeleteArgs<ExtArgs>>): Prisma__AgentConfigurationClient<$Result.GetResult<Prisma.$AgentConfigurationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentConfiguration.
     * @param {AgentConfigurationUpdateArgs} args - Arguments to update one AgentConfiguration.
     * @example
     * // Update one AgentConfiguration
     * const agentConfiguration = await prisma.agentConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentConfigurationUpdateArgs>(args: SelectSubset<T, AgentConfigurationUpdateArgs<ExtArgs>>): Prisma__AgentConfigurationClient<$Result.GetResult<Prisma.$AgentConfigurationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentConfigurations.
     * @param {AgentConfigurationDeleteManyArgs} args - Arguments to filter AgentConfigurations to delete.
     * @example
     * // Delete a few AgentConfigurations
     * const { count } = await prisma.agentConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentConfigurationDeleteManyArgs>(args?: SelectSubset<T, AgentConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentConfigurations
     * const agentConfiguration = await prisma.agentConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentConfigurationUpdateManyArgs>(args: SelectSubset<T, AgentConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentConfigurations and returns the data updated in the database.
     * @param {AgentConfigurationUpdateManyAndReturnArgs} args - Arguments to update many AgentConfigurations.
     * @example
     * // Update many AgentConfigurations
     * const agentConfiguration = await prisma.agentConfiguration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentConfigurations and only return the `id`
     * const agentConfigurationWithIdOnly = await prisma.agentConfiguration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentConfigurationUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentConfigurationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentConfigurationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentConfiguration.
     * @param {AgentConfigurationUpsertArgs} args - Arguments to update or create a AgentConfiguration.
     * @example
     * // Update or create a AgentConfiguration
     * const agentConfiguration = await prisma.agentConfiguration.upsert({
     *   create: {
     *     // ... data to create a AgentConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends AgentConfigurationUpsertArgs>(args: SelectSubset<T, AgentConfigurationUpsertArgs<ExtArgs>>): Prisma__AgentConfigurationClient<$Result.GetResult<Prisma.$AgentConfigurationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConfigurationCountArgs} args - Arguments to filter AgentConfigurations to count.
     * @example
     * // Count the number of AgentConfigurations
     * const count = await prisma.agentConfiguration.count({
     *   where: {
     *     // ... the filter for the AgentConfigurations we want to count
     *   }
     * })
    **/
    count<T extends AgentConfigurationCountArgs>(
      args?: Subset<T, AgentConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentConfigurationAggregateArgs>(args: Subset<T, AgentConfigurationAggregateArgs>): Prisma.PrismaPromise<GetAgentConfigurationAggregateType<T>>

    /**
     * Group by AgentConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: AgentConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentConfiguration model
   */
  readonly fields: AgentConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentConfiguration model
   */
  interface AgentConfigurationFieldRefs {
    readonly id: FieldRef<"AgentConfiguration", 'String'>
    readonly agentType: FieldRef<"AgentConfiguration", 'String'>
    readonly modelName: FieldRef<"AgentConfiguration", 'String'>
    readonly temperature: FieldRef<"AgentConfiguration", 'Float'>
    readonly maxTokens: FieldRef<"AgentConfiguration", 'Int'>
    readonly systemPrompt: FieldRef<"AgentConfiguration", 'Json'>
    readonly additionalParameters: FieldRef<"AgentConfiguration", 'Json'>
    readonly enabled: FieldRef<"AgentConfiguration", 'Boolean'>
    readonly createdAt: FieldRef<"AgentConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentConfiguration", 'DateTime'>
    readonly updatedBy: FieldRef<"AgentConfiguration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgentConfiguration findUnique
   */
  export type AgentConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which AgentConfiguration to fetch.
     */
    where: AgentConfigurationWhereUniqueInput
  }

  /**
   * AgentConfiguration findUniqueOrThrow
   */
  export type AgentConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which AgentConfiguration to fetch.
     */
    where: AgentConfigurationWhereUniqueInput
  }

  /**
   * AgentConfiguration findFirst
   */
  export type AgentConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which AgentConfiguration to fetch.
     */
    where?: AgentConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentConfigurations to fetch.
     */
    orderBy?: AgentConfigurationOrderByWithRelationInput | AgentConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentConfigurations.
     */
    cursor?: AgentConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentConfigurations.
     */
    distinct?: AgentConfigurationScalarFieldEnum | AgentConfigurationScalarFieldEnum[]
  }

  /**
   * AgentConfiguration findFirstOrThrow
   */
  export type AgentConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which AgentConfiguration to fetch.
     */
    where?: AgentConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentConfigurations to fetch.
     */
    orderBy?: AgentConfigurationOrderByWithRelationInput | AgentConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentConfigurations.
     */
    cursor?: AgentConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentConfigurations.
     */
    distinct?: AgentConfigurationScalarFieldEnum | AgentConfigurationScalarFieldEnum[]
  }

  /**
   * AgentConfiguration findMany
   */
  export type AgentConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which AgentConfigurations to fetch.
     */
    where?: AgentConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentConfigurations to fetch.
     */
    orderBy?: AgentConfigurationOrderByWithRelationInput | AgentConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentConfigurations.
     */
    cursor?: AgentConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentConfigurations.
     */
    skip?: number
    distinct?: AgentConfigurationScalarFieldEnum | AgentConfigurationScalarFieldEnum[]
  }

  /**
   * AgentConfiguration create
   */
  export type AgentConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to create a AgentConfiguration.
     */
    data: XOR<AgentConfigurationCreateInput, AgentConfigurationUncheckedCreateInput>
  }

  /**
   * AgentConfiguration createMany
   */
  export type AgentConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentConfigurations.
     */
    data: AgentConfigurationCreateManyInput | AgentConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentConfiguration createManyAndReturn
   */
  export type AgentConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
    /**
     * The data used to create many AgentConfigurations.
     */
    data: AgentConfigurationCreateManyInput | AgentConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentConfiguration update
   */
  export type AgentConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to update a AgentConfiguration.
     */
    data: XOR<AgentConfigurationUpdateInput, AgentConfigurationUncheckedUpdateInput>
    /**
     * Choose, which AgentConfiguration to update.
     */
    where: AgentConfigurationWhereUniqueInput
  }

  /**
   * AgentConfiguration updateMany
   */
  export type AgentConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentConfigurations.
     */
    data: XOR<AgentConfigurationUpdateManyMutationInput, AgentConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which AgentConfigurations to update
     */
    where?: AgentConfigurationWhereInput
    /**
     * Limit how many AgentConfigurations to update.
     */
    limit?: number
  }

  /**
   * AgentConfiguration updateManyAndReturn
   */
  export type AgentConfigurationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
    /**
     * The data used to update AgentConfigurations.
     */
    data: XOR<AgentConfigurationUpdateManyMutationInput, AgentConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which AgentConfigurations to update
     */
    where?: AgentConfigurationWhereInput
    /**
     * Limit how many AgentConfigurations to update.
     */
    limit?: number
  }

  /**
   * AgentConfiguration upsert
   */
  export type AgentConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
    /**
     * The filter to search for the AgentConfiguration to update in case it exists.
     */
    where: AgentConfigurationWhereUniqueInput
    /**
     * In case the AgentConfiguration found by the `where` argument doesn't exist, create a new AgentConfiguration with this data.
     */
    create: XOR<AgentConfigurationCreateInput, AgentConfigurationUncheckedCreateInput>
    /**
     * In case the AgentConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentConfigurationUpdateInput, AgentConfigurationUncheckedUpdateInput>
  }

  /**
   * AgentConfiguration delete
   */
  export type AgentConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
    /**
     * Filter which AgentConfiguration to delete.
     */
    where: AgentConfigurationWhereUniqueInput
  }

  /**
   * AgentConfiguration deleteMany
   */
  export type AgentConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentConfigurations to delete
     */
    where?: AgentConfigurationWhereInput
    /**
     * Limit how many AgentConfigurations to delete.
     */
    limit?: number
  }

  /**
   * AgentConfiguration without action
   */
  export type AgentConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentConfiguration
     */
    select?: AgentConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentConfiguration
     */
    omit?: AgentConfigurationOmit<ExtArgs> | null
  }


  /**
   * Model Integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    enabled: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    enabled: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    type: number
    name: number
    configuration: number
    enabled: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    enabled?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    enabled?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    configuration?: true
    enabled?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integration to aggregate.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type IntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithAggregationInput | IntegrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: IntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: string
    type: string
    name: string
    configuration: JsonValue
    enabled: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends IntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    configuration?: boolean
    enabled?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    logs?: boolean | Integration$logsArgs<ExtArgs>
    _count?: boolean | IntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    configuration?: boolean
    enabled?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    configuration?: boolean
    enabled?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    configuration?: boolean
    enabled?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "configuration" | "enabled" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["integration"]>
  export type IntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    logs?: boolean | Integration$logsArgs<ExtArgs>
    _count?: boolean | IntegrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integration"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      logs: Prisma.$IntegrationLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      name: string
      configuration: Prisma.JsonValue
      enabled: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type IntegrationGetPayload<S extends boolean | null | undefined | IntegrationDefaultArgs> = $Result.GetResult<Prisma.$IntegrationPayload, S>

  type IntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface IntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integration'], meta: { name: 'Integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {IntegrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationFindUniqueArgs>(args: SelectSubset<T, IntegrationFindUniqueArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationFindFirstArgs>(args?: SelectSubset<T, IntegrationFindFirstArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationFindManyArgs>(args?: SelectSubset<T, IntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Integration.
     * @param {IntegrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends IntegrationCreateArgs>(args: SelectSubset<T, IntegrationCreateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Integrations.
     * @param {IntegrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCreateManyArgs>(args?: SelectSubset<T, IntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {IntegrationCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Integration.
     * @param {IntegrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends IntegrationDeleteArgs>(args: SelectSubset<T, IntegrationDeleteArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Integration.
     * @param {IntegrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationUpdateArgs>(args: SelectSubset<T, IntegrationUpdateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationDeleteManyArgs>(args?: SelectSubset<T, IntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationUpdateManyArgs>(args: SelectSubset<T, IntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations and returns the data updated in the database.
     * @param {IntegrationUpdateManyAndReturnArgs} args - Arguments to update many Integrations.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, IntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Integration.
     * @param {IntegrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationUpsertArgs>(args: SelectSubset<T, IntegrationUpsertArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCountArgs>(
      args?: Subset<T, IntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integration model
   */
  readonly fields: IntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    logs<T extends Integration$logsArgs<ExtArgs> = {}>(args?: Subset<T, Integration$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integration model
   */
  interface IntegrationFieldRefs {
    readonly id: FieldRef<"Integration", 'String'>
    readonly type: FieldRef<"Integration", 'String'>
    readonly name: FieldRef<"Integration", 'String'>
    readonly configuration: FieldRef<"Integration", 'Json'>
    readonly enabled: FieldRef<"Integration", 'Boolean'>
    readonly createdBy: FieldRef<"Integration", 'String'>
    readonly createdAt: FieldRef<"Integration", 'DateTime'>
    readonly updatedAt: FieldRef<"Integration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Integration findUnique
   */
  export type IntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findUniqueOrThrow
   */
  export type IntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findFirst
   */
  export type IntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findFirstOrThrow
   */
  export type IntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findMany
   */
  export type IntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration create
   */
  export type IntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a Integration.
     */
    data: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
  }

  /**
   * Integration createMany
   */
  export type IntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration createManyAndReturn
   */
  export type IntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration update
   */
  export type IntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a Integration.
     */
    data: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
    /**
     * Choose, which Integration to update.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration updateMany
   */
  export type IntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
  }

  /**
   * Integration updateManyAndReturn
   */
  export type IntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration upsert
   */
  export type IntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the Integration to update in case it exists.
     */
    where: IntegrationWhereUniqueInput
    /**
     * In case the Integration found by the `where` argument doesn't exist, create a new Integration with this data.
     */
    create: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
    /**
     * In case the Integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
  }

  /**
   * Integration delete
   */
  export type IntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter which Integration to delete.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration deleteMany
   */
  export type IntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to delete.
     */
    limit?: number
  }

  /**
   * Integration.logs
   */
  export type Integration$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogInclude<ExtArgs> | null
    where?: IntegrationLogWhereInput
    orderBy?: IntegrationLogOrderByWithRelationInput | IntegrationLogOrderByWithRelationInput[]
    cursor?: IntegrationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationLogScalarFieldEnum | IntegrationLogScalarFieldEnum[]
  }

  /**
   * Integration without action
   */
  export type IntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
  }


  /**
   * Model IntegrationLog
   */

  export type AggregateIntegrationLog = {
    _count: IntegrationLogCountAggregateOutputType | null
    _min: IntegrationLogMinAggregateOutputType | null
    _max: IntegrationLogMaxAggregateOutputType | null
  }

  export type IntegrationLogMinAggregateOutputType = {
    id: string | null
    integrationId: string | null
    action: string | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type IntegrationLogMaxAggregateOutputType = {
    id: string | null
    integrationId: string | null
    action: string | null
    status: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type IntegrationLogCountAggregateOutputType = {
    id: number
    integrationId: number
    action: number
    status: number
    requestData: number
    responseData: number
    errorMessage: number
    createdAt: number
    _all: number
  }


  export type IntegrationLogMinAggregateInputType = {
    id?: true
    integrationId?: true
    action?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type IntegrationLogMaxAggregateInputType = {
    id?: true
    integrationId?: true
    action?: true
    status?: true
    errorMessage?: true
    createdAt?: true
  }

  export type IntegrationLogCountAggregateInputType = {
    id?: true
    integrationId?: true
    action?: true
    status?: true
    requestData?: true
    responseData?: true
    errorMessage?: true
    createdAt?: true
    _all?: true
  }

  export type IntegrationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationLog to aggregate.
     */
    where?: IntegrationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationLogs to fetch.
     */
    orderBy?: IntegrationLogOrderByWithRelationInput | IntegrationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntegrationLogs
    **/
    _count?: true | IntegrationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationLogMaxAggregateInputType
  }

  export type GetIntegrationLogAggregateType<T extends IntegrationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegrationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegrationLog[P]>
      : GetScalarType<T[P], AggregateIntegrationLog[P]>
  }




  export type IntegrationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationLogWhereInput
    orderBy?: IntegrationLogOrderByWithAggregationInput | IntegrationLogOrderByWithAggregationInput[]
    by: IntegrationLogScalarFieldEnum[] | IntegrationLogScalarFieldEnum
    having?: IntegrationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationLogCountAggregateInputType | true
    _min?: IntegrationLogMinAggregateInputType
    _max?: IntegrationLogMaxAggregateInputType
  }

  export type IntegrationLogGroupByOutputType = {
    id: string
    integrationId: string
    action: string
    status: string
    requestData: JsonValue | null
    responseData: JsonValue | null
    errorMessage: string | null
    createdAt: Date
    _count: IntegrationLogCountAggregateOutputType | null
    _min: IntegrationLogMinAggregateOutputType | null
    _max: IntegrationLogMaxAggregateOutputType | null
  }

  type GetIntegrationLogGroupByPayload<T extends IntegrationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationLogGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationLogGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    action?: boolean
    status?: boolean
    requestData?: boolean
    responseData?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    integration?: boolean | IntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrationLog"]>

  export type IntegrationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    action?: boolean
    status?: boolean
    requestData?: boolean
    responseData?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    integration?: boolean | IntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrationLog"]>

  export type IntegrationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    integrationId?: boolean
    action?: boolean
    status?: boolean
    requestData?: boolean
    responseData?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    integration?: boolean | IntegrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrationLog"]>

  export type IntegrationLogSelectScalar = {
    id?: boolean
    integrationId?: boolean
    action?: boolean
    status?: boolean
    requestData?: boolean
    responseData?: boolean
    errorMessage?: boolean
    createdAt?: boolean
  }

  export type IntegrationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "integrationId" | "action" | "status" | "requestData" | "responseData" | "errorMessage" | "createdAt", ExtArgs["result"]["integrationLog"]>
  export type IntegrationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | IntegrationDefaultArgs<ExtArgs>
  }
  export type IntegrationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | IntegrationDefaultArgs<ExtArgs>
  }
  export type IntegrationLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integration?: boolean | IntegrationDefaultArgs<ExtArgs>
  }

  export type $IntegrationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntegrationLog"
    objects: {
      integration: Prisma.$IntegrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      integrationId: string
      action: string
      status: string
      requestData: Prisma.JsonValue | null
      responseData: Prisma.JsonValue | null
      errorMessage: string | null
      createdAt: Date
    }, ExtArgs["result"]["integrationLog"]>
    composites: {}
  }

  type IntegrationLogGetPayload<S extends boolean | null | undefined | IntegrationLogDefaultArgs> = $Result.GetResult<Prisma.$IntegrationLogPayload, S>

  type IntegrationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegrationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationLogCountAggregateInputType | true
    }

  export interface IntegrationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntegrationLog'], meta: { name: 'IntegrationLog' } }
    /**
     * Find zero or one IntegrationLog that matches the filter.
     * @param {IntegrationLogFindUniqueArgs} args - Arguments to find a IntegrationLog
     * @example
     * // Get one IntegrationLog
     * const integrationLog = await prisma.integrationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationLogFindUniqueArgs>(args: SelectSubset<T, IntegrationLogFindUniqueArgs<ExtArgs>>): Prisma__IntegrationLogClient<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IntegrationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegrationLogFindUniqueOrThrowArgs} args - Arguments to find a IntegrationLog
     * @example
     * // Get one IntegrationLog
     * const integrationLog = await prisma.integrationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationLogClient<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntegrationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationLogFindFirstArgs} args - Arguments to find a IntegrationLog
     * @example
     * // Get one IntegrationLog
     * const integrationLog = await prisma.integrationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationLogFindFirstArgs>(args?: SelectSubset<T, IntegrationLogFindFirstArgs<ExtArgs>>): Prisma__IntegrationLogClient<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IntegrationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationLogFindFirstOrThrowArgs} args - Arguments to find a IntegrationLog
     * @example
     * // Get one IntegrationLog
     * const integrationLog = await prisma.integrationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationLogClient<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IntegrationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntegrationLogs
     * const integrationLogs = await prisma.integrationLog.findMany()
     * 
     * // Get first 10 IntegrationLogs
     * const integrationLogs = await prisma.integrationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationLogWithIdOnly = await prisma.integrationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationLogFindManyArgs>(args?: SelectSubset<T, IntegrationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IntegrationLog.
     * @param {IntegrationLogCreateArgs} args - Arguments to create a IntegrationLog.
     * @example
     * // Create one IntegrationLog
     * const IntegrationLog = await prisma.integrationLog.create({
     *   data: {
     *     // ... data to create a IntegrationLog
     *   }
     * })
     * 
     */
    create<T extends IntegrationLogCreateArgs>(args: SelectSubset<T, IntegrationLogCreateArgs<ExtArgs>>): Prisma__IntegrationLogClient<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IntegrationLogs.
     * @param {IntegrationLogCreateManyArgs} args - Arguments to create many IntegrationLogs.
     * @example
     * // Create many IntegrationLogs
     * const integrationLog = await prisma.integrationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationLogCreateManyArgs>(args?: SelectSubset<T, IntegrationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntegrationLogs and returns the data saved in the database.
     * @param {IntegrationLogCreateManyAndReturnArgs} args - Arguments to create many IntegrationLogs.
     * @example
     * // Create many IntegrationLogs
     * const integrationLog = await prisma.integrationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntegrationLogs and only return the `id`
     * const integrationLogWithIdOnly = await prisma.integrationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IntegrationLog.
     * @param {IntegrationLogDeleteArgs} args - Arguments to delete one IntegrationLog.
     * @example
     * // Delete one IntegrationLog
     * const IntegrationLog = await prisma.integrationLog.delete({
     *   where: {
     *     // ... filter to delete one IntegrationLog
     *   }
     * })
     * 
     */
    delete<T extends IntegrationLogDeleteArgs>(args: SelectSubset<T, IntegrationLogDeleteArgs<ExtArgs>>): Prisma__IntegrationLogClient<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IntegrationLog.
     * @param {IntegrationLogUpdateArgs} args - Arguments to update one IntegrationLog.
     * @example
     * // Update one IntegrationLog
     * const integrationLog = await prisma.integrationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationLogUpdateArgs>(args: SelectSubset<T, IntegrationLogUpdateArgs<ExtArgs>>): Prisma__IntegrationLogClient<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IntegrationLogs.
     * @param {IntegrationLogDeleteManyArgs} args - Arguments to filter IntegrationLogs to delete.
     * @example
     * // Delete a few IntegrationLogs
     * const { count } = await prisma.integrationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationLogDeleteManyArgs>(args?: SelectSubset<T, IntegrationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegrationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntegrationLogs
     * const integrationLog = await prisma.integrationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationLogUpdateManyArgs>(args: SelectSubset<T, IntegrationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegrationLogs and returns the data updated in the database.
     * @param {IntegrationLogUpdateManyAndReturnArgs} args - Arguments to update many IntegrationLogs.
     * @example
     * // Update many IntegrationLogs
     * const integrationLog = await prisma.integrationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IntegrationLogs and only return the `id`
     * const integrationLogWithIdOnly = await prisma.integrationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntegrationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, IntegrationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IntegrationLog.
     * @param {IntegrationLogUpsertArgs} args - Arguments to update or create a IntegrationLog.
     * @example
     * // Update or create a IntegrationLog
     * const integrationLog = await prisma.integrationLog.upsert({
     *   create: {
     *     // ... data to create a IntegrationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntegrationLog we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationLogUpsertArgs>(args: SelectSubset<T, IntegrationLogUpsertArgs<ExtArgs>>): Prisma__IntegrationLogClient<$Result.GetResult<Prisma.$IntegrationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IntegrationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationLogCountArgs} args - Arguments to filter IntegrationLogs to count.
     * @example
     * // Count the number of IntegrationLogs
     * const count = await prisma.integrationLog.count({
     *   where: {
     *     // ... the filter for the IntegrationLogs we want to count
     *   }
     * })
    **/
    count<T extends IntegrationLogCountArgs>(
      args?: Subset<T, IntegrationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntegrationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationLogAggregateArgs>(args: Subset<T, IntegrationLogAggregateArgs>): Prisma.PrismaPromise<GetIntegrationLogAggregateType<T>>

    /**
     * Group by IntegrationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationLogGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntegrationLog model
   */
  readonly fields: IntegrationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntegrationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    integration<T extends IntegrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntegrationDefaultArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntegrationLog model
   */
  interface IntegrationLogFieldRefs {
    readonly id: FieldRef<"IntegrationLog", 'String'>
    readonly integrationId: FieldRef<"IntegrationLog", 'String'>
    readonly action: FieldRef<"IntegrationLog", 'String'>
    readonly status: FieldRef<"IntegrationLog", 'String'>
    readonly requestData: FieldRef<"IntegrationLog", 'Json'>
    readonly responseData: FieldRef<"IntegrationLog", 'Json'>
    readonly errorMessage: FieldRef<"IntegrationLog", 'String'>
    readonly createdAt: FieldRef<"IntegrationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IntegrationLog findUnique
   */
  export type IntegrationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationLog to fetch.
     */
    where: IntegrationLogWhereUniqueInput
  }

  /**
   * IntegrationLog findUniqueOrThrow
   */
  export type IntegrationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationLog to fetch.
     */
    where: IntegrationLogWhereUniqueInput
  }

  /**
   * IntegrationLog findFirst
   */
  export type IntegrationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationLog to fetch.
     */
    where?: IntegrationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationLogs to fetch.
     */
    orderBy?: IntegrationLogOrderByWithRelationInput | IntegrationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationLogs.
     */
    cursor?: IntegrationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationLogs.
     */
    distinct?: IntegrationLogScalarFieldEnum | IntegrationLogScalarFieldEnum[]
  }

  /**
   * IntegrationLog findFirstOrThrow
   */
  export type IntegrationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationLog to fetch.
     */
    where?: IntegrationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationLogs to fetch.
     */
    orderBy?: IntegrationLogOrderByWithRelationInput | IntegrationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationLogs.
     */
    cursor?: IntegrationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationLogs.
     */
    distinct?: IntegrationLogScalarFieldEnum | IntegrationLogScalarFieldEnum[]
  }

  /**
   * IntegrationLog findMany
   */
  export type IntegrationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationLogs to fetch.
     */
    where?: IntegrationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationLogs to fetch.
     */
    orderBy?: IntegrationLogOrderByWithRelationInput | IntegrationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntegrationLogs.
     */
    cursor?: IntegrationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationLogs.
     */
    skip?: number
    distinct?: IntegrationLogScalarFieldEnum | IntegrationLogScalarFieldEnum[]
  }

  /**
   * IntegrationLog create
   */
  export type IntegrationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a IntegrationLog.
     */
    data: XOR<IntegrationLogCreateInput, IntegrationLogUncheckedCreateInput>
  }

  /**
   * IntegrationLog createMany
   */
  export type IntegrationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntegrationLogs.
     */
    data: IntegrationLogCreateManyInput | IntegrationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntegrationLog createManyAndReturn
   */
  export type IntegrationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * The data used to create many IntegrationLogs.
     */
    data: IntegrationLogCreateManyInput | IntegrationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntegrationLog update
   */
  export type IntegrationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a IntegrationLog.
     */
    data: XOR<IntegrationLogUpdateInput, IntegrationLogUncheckedUpdateInput>
    /**
     * Choose, which IntegrationLog to update.
     */
    where: IntegrationLogWhereUniqueInput
  }

  /**
   * IntegrationLog updateMany
   */
  export type IntegrationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntegrationLogs.
     */
    data: XOR<IntegrationLogUpdateManyMutationInput, IntegrationLogUncheckedUpdateManyInput>
    /**
     * Filter which IntegrationLogs to update
     */
    where?: IntegrationLogWhereInput
    /**
     * Limit how many IntegrationLogs to update.
     */
    limit?: number
  }

  /**
   * IntegrationLog updateManyAndReturn
   */
  export type IntegrationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * The data used to update IntegrationLogs.
     */
    data: XOR<IntegrationLogUpdateManyMutationInput, IntegrationLogUncheckedUpdateManyInput>
    /**
     * Filter which IntegrationLogs to update
     */
    where?: IntegrationLogWhereInput
    /**
     * Limit how many IntegrationLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntegrationLog upsert
   */
  export type IntegrationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the IntegrationLog to update in case it exists.
     */
    where: IntegrationLogWhereUniqueInput
    /**
     * In case the IntegrationLog found by the `where` argument doesn't exist, create a new IntegrationLog with this data.
     */
    create: XOR<IntegrationLogCreateInput, IntegrationLogUncheckedCreateInput>
    /**
     * In case the IntegrationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationLogUpdateInput, IntegrationLogUncheckedUpdateInput>
  }

  /**
   * IntegrationLog delete
   */
  export type IntegrationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogInclude<ExtArgs> | null
    /**
     * Filter which IntegrationLog to delete.
     */
    where: IntegrationLogWhereUniqueInput
  }

  /**
   * IntegrationLog deleteMany
   */
  export type IntegrationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationLogs to delete
     */
    where?: IntegrationLogWhereInput
    /**
     * Limit how many IntegrationLogs to delete.
     */
    limit?: number
  }

  /**
   * IntegrationLog without action
   */
  export type IntegrationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationLog
     */
    select?: IntegrationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationLog
     */
    omit?: IntegrationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationLogInclude<ExtArgs> | null
  }


  /**
   * Model BidStatistics
   */

  export type AggregateBidStatistics = {
    _count: BidStatisticsCountAggregateOutputType | null
    _avg: BidStatisticsAvgAggregateOutputType | null
    _sum: BidStatisticsSumAggregateOutputType | null
    _min: BidStatisticsMinAggregateOutputType | null
    _max: BidStatisticsMaxAggregateOutputType | null
  }

  export type BidStatisticsAvgAggregateOutputType = {
    submittedBids: number | null
    wonBids: number | null
    totalValue: Decimal | null
    wonValue: Decimal | null
    successRate: number | null
    activeRfps: number | null
  }

  export type BidStatisticsSumAggregateOutputType = {
    submittedBids: number | null
    wonBids: number | null
    totalValue: Decimal | null
    wonValue: Decimal | null
    successRate: number | null
    activeRfps: number | null
  }

  export type BidStatisticsMinAggregateOutputType = {
    id: string | null
    periodStart: Date | null
    periodEnd: Date | null
    submittedBids: number | null
    wonBids: number | null
    totalValue: Decimal | null
    wonValue: Decimal | null
    successRate: number | null
    activeRfps: number | null
    calculatedAt: Date | null
  }

  export type BidStatisticsMaxAggregateOutputType = {
    id: string | null
    periodStart: Date | null
    periodEnd: Date | null
    submittedBids: number | null
    wonBids: number | null
    totalValue: Decimal | null
    wonValue: Decimal | null
    successRate: number | null
    activeRfps: number | null
    calculatedAt: Date | null
  }

  export type BidStatisticsCountAggregateOutputType = {
    id: number
    periodStart: number
    periodEnd: number
    submittedBids: number
    wonBids: number
    totalValue: number
    wonValue: number
    successRate: number
    activeRfps: number
    detailedMetrics: number
    calculatedAt: number
    _all: number
  }


  export type BidStatisticsAvgAggregateInputType = {
    submittedBids?: true
    wonBids?: true
    totalValue?: true
    wonValue?: true
    successRate?: true
    activeRfps?: true
  }

  export type BidStatisticsSumAggregateInputType = {
    submittedBids?: true
    wonBids?: true
    totalValue?: true
    wonValue?: true
    successRate?: true
    activeRfps?: true
  }

  export type BidStatisticsMinAggregateInputType = {
    id?: true
    periodStart?: true
    periodEnd?: true
    submittedBids?: true
    wonBids?: true
    totalValue?: true
    wonValue?: true
    successRate?: true
    activeRfps?: true
    calculatedAt?: true
  }

  export type BidStatisticsMaxAggregateInputType = {
    id?: true
    periodStart?: true
    periodEnd?: true
    submittedBids?: true
    wonBids?: true
    totalValue?: true
    wonValue?: true
    successRate?: true
    activeRfps?: true
    calculatedAt?: true
  }

  export type BidStatisticsCountAggregateInputType = {
    id?: true
    periodStart?: true
    periodEnd?: true
    submittedBids?: true
    wonBids?: true
    totalValue?: true
    wonValue?: true
    successRate?: true
    activeRfps?: true
    detailedMetrics?: true
    calculatedAt?: true
    _all?: true
  }

  export type BidStatisticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BidStatistics to aggregate.
     */
    where?: BidStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidStatistics to fetch.
     */
    orderBy?: BidStatisticsOrderByWithRelationInput | BidStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BidStatistics
    **/
    _count?: true | BidStatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BidStatisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BidStatisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidStatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidStatisticsMaxAggregateInputType
  }

  export type GetBidStatisticsAggregateType<T extends BidStatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateBidStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBidStatistics[P]>
      : GetScalarType<T[P], AggregateBidStatistics[P]>
  }




  export type BidStatisticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidStatisticsWhereInput
    orderBy?: BidStatisticsOrderByWithAggregationInput | BidStatisticsOrderByWithAggregationInput[]
    by: BidStatisticsScalarFieldEnum[] | BidStatisticsScalarFieldEnum
    having?: BidStatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidStatisticsCountAggregateInputType | true
    _avg?: BidStatisticsAvgAggregateInputType
    _sum?: BidStatisticsSumAggregateInputType
    _min?: BidStatisticsMinAggregateInputType
    _max?: BidStatisticsMaxAggregateInputType
  }

  export type BidStatisticsGroupByOutputType = {
    id: string
    periodStart: Date
    periodEnd: Date
    submittedBids: number
    wonBids: number
    totalValue: Decimal
    wonValue: Decimal
    successRate: number
    activeRfps: number
    detailedMetrics: JsonValue | null
    calculatedAt: Date
    _count: BidStatisticsCountAggregateOutputType | null
    _avg: BidStatisticsAvgAggregateOutputType | null
    _sum: BidStatisticsSumAggregateOutputType | null
    _min: BidStatisticsMinAggregateOutputType | null
    _max: BidStatisticsMaxAggregateOutputType | null
  }

  type GetBidStatisticsGroupByPayload<T extends BidStatisticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BidStatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidStatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidStatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], BidStatisticsGroupByOutputType[P]>
        }
      >
    >


  export type BidStatisticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    submittedBids?: boolean
    wonBids?: boolean
    totalValue?: boolean
    wonValue?: boolean
    successRate?: boolean
    activeRfps?: boolean
    detailedMetrics?: boolean
    calculatedAt?: boolean
  }, ExtArgs["result"]["bidStatistics"]>

  export type BidStatisticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    submittedBids?: boolean
    wonBids?: boolean
    totalValue?: boolean
    wonValue?: boolean
    successRate?: boolean
    activeRfps?: boolean
    detailedMetrics?: boolean
    calculatedAt?: boolean
  }, ExtArgs["result"]["bidStatistics"]>

  export type BidStatisticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    submittedBids?: boolean
    wonBids?: boolean
    totalValue?: boolean
    wonValue?: boolean
    successRate?: boolean
    activeRfps?: boolean
    detailedMetrics?: boolean
    calculatedAt?: boolean
  }, ExtArgs["result"]["bidStatistics"]>

  export type BidStatisticsSelectScalar = {
    id?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    submittedBids?: boolean
    wonBids?: boolean
    totalValue?: boolean
    wonValue?: boolean
    successRate?: boolean
    activeRfps?: boolean
    detailedMetrics?: boolean
    calculatedAt?: boolean
  }

  export type BidStatisticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "periodStart" | "periodEnd" | "submittedBids" | "wonBids" | "totalValue" | "wonValue" | "successRate" | "activeRfps" | "detailedMetrics" | "calculatedAt", ExtArgs["result"]["bidStatistics"]>

  export type $BidStatisticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BidStatistics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      periodStart: Date
      periodEnd: Date
      submittedBids: number
      wonBids: number
      totalValue: Prisma.Decimal
      wonValue: Prisma.Decimal
      successRate: number
      activeRfps: number
      detailedMetrics: Prisma.JsonValue | null
      calculatedAt: Date
    }, ExtArgs["result"]["bidStatistics"]>
    composites: {}
  }

  type BidStatisticsGetPayload<S extends boolean | null | undefined | BidStatisticsDefaultArgs> = $Result.GetResult<Prisma.$BidStatisticsPayload, S>

  type BidStatisticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BidStatisticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BidStatisticsCountAggregateInputType | true
    }

  export interface BidStatisticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BidStatistics'], meta: { name: 'BidStatistics' } }
    /**
     * Find zero or one BidStatistics that matches the filter.
     * @param {BidStatisticsFindUniqueArgs} args - Arguments to find a BidStatistics
     * @example
     * // Get one BidStatistics
     * const bidStatistics = await prisma.bidStatistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BidStatisticsFindUniqueArgs>(args: SelectSubset<T, BidStatisticsFindUniqueArgs<ExtArgs>>): Prisma__BidStatisticsClient<$Result.GetResult<Prisma.$BidStatisticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BidStatistics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BidStatisticsFindUniqueOrThrowArgs} args - Arguments to find a BidStatistics
     * @example
     * // Get one BidStatistics
     * const bidStatistics = await prisma.bidStatistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BidStatisticsFindUniqueOrThrowArgs>(args: SelectSubset<T, BidStatisticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BidStatisticsClient<$Result.GetResult<Prisma.$BidStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BidStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidStatisticsFindFirstArgs} args - Arguments to find a BidStatistics
     * @example
     * // Get one BidStatistics
     * const bidStatistics = await prisma.bidStatistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BidStatisticsFindFirstArgs>(args?: SelectSubset<T, BidStatisticsFindFirstArgs<ExtArgs>>): Prisma__BidStatisticsClient<$Result.GetResult<Prisma.$BidStatisticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BidStatistics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidStatisticsFindFirstOrThrowArgs} args - Arguments to find a BidStatistics
     * @example
     * // Get one BidStatistics
     * const bidStatistics = await prisma.bidStatistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BidStatisticsFindFirstOrThrowArgs>(args?: SelectSubset<T, BidStatisticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BidStatisticsClient<$Result.GetResult<Prisma.$BidStatisticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BidStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidStatisticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BidStatistics
     * const bidStatistics = await prisma.bidStatistics.findMany()
     * 
     * // Get first 10 BidStatistics
     * const bidStatistics = await prisma.bidStatistics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bidStatisticsWithIdOnly = await prisma.bidStatistics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BidStatisticsFindManyArgs>(args?: SelectSubset<T, BidStatisticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BidStatistics.
     * @param {BidStatisticsCreateArgs} args - Arguments to create a BidStatistics.
     * @example
     * // Create one BidStatistics
     * const BidStatistics = await prisma.bidStatistics.create({
     *   data: {
     *     // ... data to create a BidStatistics
     *   }
     * })
     * 
     */
    create<T extends BidStatisticsCreateArgs>(args: SelectSubset<T, BidStatisticsCreateArgs<ExtArgs>>): Prisma__BidStatisticsClient<$Result.GetResult<Prisma.$BidStatisticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BidStatistics.
     * @param {BidStatisticsCreateManyArgs} args - Arguments to create many BidStatistics.
     * @example
     * // Create many BidStatistics
     * const bidStatistics = await prisma.bidStatistics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BidStatisticsCreateManyArgs>(args?: SelectSubset<T, BidStatisticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BidStatistics and returns the data saved in the database.
     * @param {BidStatisticsCreateManyAndReturnArgs} args - Arguments to create many BidStatistics.
     * @example
     * // Create many BidStatistics
     * const bidStatistics = await prisma.bidStatistics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BidStatistics and only return the `id`
     * const bidStatisticsWithIdOnly = await prisma.bidStatistics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BidStatisticsCreateManyAndReturnArgs>(args?: SelectSubset<T, BidStatisticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidStatisticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BidStatistics.
     * @param {BidStatisticsDeleteArgs} args - Arguments to delete one BidStatistics.
     * @example
     * // Delete one BidStatistics
     * const BidStatistics = await prisma.bidStatistics.delete({
     *   where: {
     *     // ... filter to delete one BidStatistics
     *   }
     * })
     * 
     */
    delete<T extends BidStatisticsDeleteArgs>(args: SelectSubset<T, BidStatisticsDeleteArgs<ExtArgs>>): Prisma__BidStatisticsClient<$Result.GetResult<Prisma.$BidStatisticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BidStatistics.
     * @param {BidStatisticsUpdateArgs} args - Arguments to update one BidStatistics.
     * @example
     * // Update one BidStatistics
     * const bidStatistics = await prisma.bidStatistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BidStatisticsUpdateArgs>(args: SelectSubset<T, BidStatisticsUpdateArgs<ExtArgs>>): Prisma__BidStatisticsClient<$Result.GetResult<Prisma.$BidStatisticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BidStatistics.
     * @param {BidStatisticsDeleteManyArgs} args - Arguments to filter BidStatistics to delete.
     * @example
     * // Delete a few BidStatistics
     * const { count } = await prisma.bidStatistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BidStatisticsDeleteManyArgs>(args?: SelectSubset<T, BidStatisticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BidStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidStatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BidStatistics
     * const bidStatistics = await prisma.bidStatistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BidStatisticsUpdateManyArgs>(args: SelectSubset<T, BidStatisticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BidStatistics and returns the data updated in the database.
     * @param {BidStatisticsUpdateManyAndReturnArgs} args - Arguments to update many BidStatistics.
     * @example
     * // Update many BidStatistics
     * const bidStatistics = await prisma.bidStatistics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BidStatistics and only return the `id`
     * const bidStatisticsWithIdOnly = await prisma.bidStatistics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BidStatisticsUpdateManyAndReturnArgs>(args: SelectSubset<T, BidStatisticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidStatisticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BidStatistics.
     * @param {BidStatisticsUpsertArgs} args - Arguments to update or create a BidStatistics.
     * @example
     * // Update or create a BidStatistics
     * const bidStatistics = await prisma.bidStatistics.upsert({
     *   create: {
     *     // ... data to create a BidStatistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BidStatistics we want to update
     *   }
     * })
     */
    upsert<T extends BidStatisticsUpsertArgs>(args: SelectSubset<T, BidStatisticsUpsertArgs<ExtArgs>>): Prisma__BidStatisticsClient<$Result.GetResult<Prisma.$BidStatisticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BidStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidStatisticsCountArgs} args - Arguments to filter BidStatistics to count.
     * @example
     * // Count the number of BidStatistics
     * const count = await prisma.bidStatistics.count({
     *   where: {
     *     // ... the filter for the BidStatistics we want to count
     *   }
     * })
    **/
    count<T extends BidStatisticsCountArgs>(
      args?: Subset<T, BidStatisticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidStatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BidStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidStatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidStatisticsAggregateArgs>(args: Subset<T, BidStatisticsAggregateArgs>): Prisma.PrismaPromise<GetBidStatisticsAggregateType<T>>

    /**
     * Group by BidStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidStatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidStatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidStatisticsGroupByArgs['orderBy'] }
        : { orderBy?: BidStatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidStatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidStatisticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BidStatistics model
   */
  readonly fields: BidStatisticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BidStatistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BidStatisticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BidStatistics model
   */
  interface BidStatisticsFieldRefs {
    readonly id: FieldRef<"BidStatistics", 'String'>
    readonly periodStart: FieldRef<"BidStatistics", 'DateTime'>
    readonly periodEnd: FieldRef<"BidStatistics", 'DateTime'>
    readonly submittedBids: FieldRef<"BidStatistics", 'Int'>
    readonly wonBids: FieldRef<"BidStatistics", 'Int'>
    readonly totalValue: FieldRef<"BidStatistics", 'Decimal'>
    readonly wonValue: FieldRef<"BidStatistics", 'Decimal'>
    readonly successRate: FieldRef<"BidStatistics", 'Float'>
    readonly activeRfps: FieldRef<"BidStatistics", 'Int'>
    readonly detailedMetrics: FieldRef<"BidStatistics", 'Json'>
    readonly calculatedAt: FieldRef<"BidStatistics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BidStatistics findUnique
   */
  export type BidStatisticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
    /**
     * Filter, which BidStatistics to fetch.
     */
    where: BidStatisticsWhereUniqueInput
  }

  /**
   * BidStatistics findUniqueOrThrow
   */
  export type BidStatisticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
    /**
     * Filter, which BidStatistics to fetch.
     */
    where: BidStatisticsWhereUniqueInput
  }

  /**
   * BidStatistics findFirst
   */
  export type BidStatisticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
    /**
     * Filter, which BidStatistics to fetch.
     */
    where?: BidStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidStatistics to fetch.
     */
    orderBy?: BidStatisticsOrderByWithRelationInput | BidStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidStatistics.
     */
    cursor?: BidStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidStatistics.
     */
    distinct?: BidStatisticsScalarFieldEnum | BidStatisticsScalarFieldEnum[]
  }

  /**
   * BidStatistics findFirstOrThrow
   */
  export type BidStatisticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
    /**
     * Filter, which BidStatistics to fetch.
     */
    where?: BidStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidStatistics to fetch.
     */
    orderBy?: BidStatisticsOrderByWithRelationInput | BidStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BidStatistics.
     */
    cursor?: BidStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BidStatistics.
     */
    distinct?: BidStatisticsScalarFieldEnum | BidStatisticsScalarFieldEnum[]
  }

  /**
   * BidStatistics findMany
   */
  export type BidStatisticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
    /**
     * Filter, which BidStatistics to fetch.
     */
    where?: BidStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BidStatistics to fetch.
     */
    orderBy?: BidStatisticsOrderByWithRelationInput | BidStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BidStatistics.
     */
    cursor?: BidStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BidStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BidStatistics.
     */
    skip?: number
    distinct?: BidStatisticsScalarFieldEnum | BidStatisticsScalarFieldEnum[]
  }

  /**
   * BidStatistics create
   */
  export type BidStatisticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
    /**
     * The data needed to create a BidStatistics.
     */
    data: XOR<BidStatisticsCreateInput, BidStatisticsUncheckedCreateInput>
  }

  /**
   * BidStatistics createMany
   */
  export type BidStatisticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BidStatistics.
     */
    data: BidStatisticsCreateManyInput | BidStatisticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BidStatistics createManyAndReturn
   */
  export type BidStatisticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
    /**
     * The data used to create many BidStatistics.
     */
    data: BidStatisticsCreateManyInput | BidStatisticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BidStatistics update
   */
  export type BidStatisticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
    /**
     * The data needed to update a BidStatistics.
     */
    data: XOR<BidStatisticsUpdateInput, BidStatisticsUncheckedUpdateInput>
    /**
     * Choose, which BidStatistics to update.
     */
    where: BidStatisticsWhereUniqueInput
  }

  /**
   * BidStatistics updateMany
   */
  export type BidStatisticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BidStatistics.
     */
    data: XOR<BidStatisticsUpdateManyMutationInput, BidStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which BidStatistics to update
     */
    where?: BidStatisticsWhereInput
    /**
     * Limit how many BidStatistics to update.
     */
    limit?: number
  }

  /**
   * BidStatistics updateManyAndReturn
   */
  export type BidStatisticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
    /**
     * The data used to update BidStatistics.
     */
    data: XOR<BidStatisticsUpdateManyMutationInput, BidStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which BidStatistics to update
     */
    where?: BidStatisticsWhereInput
    /**
     * Limit how many BidStatistics to update.
     */
    limit?: number
  }

  /**
   * BidStatistics upsert
   */
  export type BidStatisticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
    /**
     * The filter to search for the BidStatistics to update in case it exists.
     */
    where: BidStatisticsWhereUniqueInput
    /**
     * In case the BidStatistics found by the `where` argument doesn't exist, create a new BidStatistics with this data.
     */
    create: XOR<BidStatisticsCreateInput, BidStatisticsUncheckedCreateInput>
    /**
     * In case the BidStatistics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidStatisticsUpdateInput, BidStatisticsUncheckedUpdateInput>
  }

  /**
   * BidStatistics delete
   */
  export type BidStatisticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
    /**
     * Filter which BidStatistics to delete.
     */
    where: BidStatisticsWhereUniqueInput
  }

  /**
   * BidStatistics deleteMany
   */
  export type BidStatisticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BidStatistics to delete
     */
    where?: BidStatisticsWhereInput
    /**
     * Limit how many BidStatistics to delete.
     */
    limit?: number
  }

  /**
   * BidStatistics without action
   */
  export type BidStatisticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BidStatistics
     */
    select?: BidStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BidStatistics
     */
    omit?: BidStatisticsOmit<ExtArgs> | null
  }


  /**
   * Model SubmissionRecord
   */

  export type AggregateSubmissionRecord = {
    _count: SubmissionRecordCountAggregateOutputType | null
    _min: SubmissionRecordMinAggregateOutputType | null
    _max: SubmissionRecordMaxAggregateOutputType | null
  }

  export type SubmissionRecordMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    artifactId: string | null
    portalName: string | null
    submissionId: string | null
    status: string | null
    submittedBy: string | null
    submittedAt: Date | null
  }

  export type SubmissionRecordMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    artifactId: string | null
    portalName: string | null
    submissionId: string | null
    status: string | null
    submittedBy: string | null
    submittedAt: Date | null
  }

  export type SubmissionRecordCountAggregateOutputType = {
    id: number
    projectId: number
    artifactId: number
    portalName: number
    submissionId: number
    status: number
    submittedBy: number
    submittedAt: number
    submissionMetadata: number
    _all: number
  }


  export type SubmissionRecordMinAggregateInputType = {
    id?: true
    projectId?: true
    artifactId?: true
    portalName?: true
    submissionId?: true
    status?: true
    submittedBy?: true
    submittedAt?: true
  }

  export type SubmissionRecordMaxAggregateInputType = {
    id?: true
    projectId?: true
    artifactId?: true
    portalName?: true
    submissionId?: true
    status?: true
    submittedBy?: true
    submittedAt?: true
  }

  export type SubmissionRecordCountAggregateInputType = {
    id?: true
    projectId?: true
    artifactId?: true
    portalName?: true
    submissionId?: true
    status?: true
    submittedBy?: true
    submittedAt?: true
    submissionMetadata?: true
    _all?: true
  }

  export type SubmissionRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubmissionRecord to aggregate.
     */
    where?: SubmissionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionRecords to fetch.
     */
    orderBy?: SubmissionRecordOrderByWithRelationInput | SubmissionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubmissionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubmissionRecords
    **/
    _count?: true | SubmissionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionRecordMaxAggregateInputType
  }

  export type GetSubmissionRecordAggregateType<T extends SubmissionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmissionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmissionRecord[P]>
      : GetScalarType<T[P], AggregateSubmissionRecord[P]>
  }




  export type SubmissionRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionRecordWhereInput
    orderBy?: SubmissionRecordOrderByWithAggregationInput | SubmissionRecordOrderByWithAggregationInput[]
    by: SubmissionRecordScalarFieldEnum[] | SubmissionRecordScalarFieldEnum
    having?: SubmissionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionRecordCountAggregateInputType | true
    _min?: SubmissionRecordMinAggregateInputType
    _max?: SubmissionRecordMaxAggregateInputType
  }

  export type SubmissionRecordGroupByOutputType = {
    id: string
    projectId: string
    artifactId: string
    portalName: string
    submissionId: string | null
    status: string
    submittedBy: string
    submittedAt: Date
    submissionMetadata: JsonValue | null
    _count: SubmissionRecordCountAggregateOutputType | null
    _min: SubmissionRecordMinAggregateOutputType | null
    _max: SubmissionRecordMaxAggregateOutputType | null
  }

  type GetSubmissionRecordGroupByPayload<T extends SubmissionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionRecordGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    artifactId?: boolean
    portalName?: boolean
    submissionId?: boolean
    status?: boolean
    submittedBy?: boolean
    submittedAt?: boolean
    submissionMetadata?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submissionRecord"]>

  export type SubmissionRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    artifactId?: boolean
    portalName?: boolean
    submissionId?: boolean
    status?: boolean
    submittedBy?: boolean
    submittedAt?: boolean
    submissionMetadata?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submissionRecord"]>

  export type SubmissionRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    artifactId?: boolean
    portalName?: boolean
    submissionId?: boolean
    status?: boolean
    submittedBy?: boolean
    submittedAt?: boolean
    submissionMetadata?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submissionRecord"]>

  export type SubmissionRecordSelectScalar = {
    id?: boolean
    projectId?: boolean
    artifactId?: boolean
    portalName?: boolean
    submissionId?: boolean
    status?: boolean
    submittedBy?: boolean
    submittedAt?: boolean
    submissionMetadata?: boolean
  }

  export type SubmissionRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "artifactId" | "portalName" | "submissionId" | "status" | "submittedBy" | "submittedAt" | "submissionMetadata", ExtArgs["result"]["submissionRecord"]>
  export type SubmissionRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubmissionRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubmissionRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    artifact?: boolean | ArtifactDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubmissionRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubmissionRecord"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      artifact: Prisma.$ArtifactPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      artifactId: string
      portalName: string
      submissionId: string | null
      status: string
      submittedBy: string
      submittedAt: Date
      submissionMetadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["submissionRecord"]>
    composites: {}
  }

  type SubmissionRecordGetPayload<S extends boolean | null | undefined | SubmissionRecordDefaultArgs> = $Result.GetResult<Prisma.$SubmissionRecordPayload, S>

  type SubmissionRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubmissionRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubmissionRecordCountAggregateInputType | true
    }

  export interface SubmissionRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubmissionRecord'], meta: { name: 'SubmissionRecord' } }
    /**
     * Find zero or one SubmissionRecord that matches the filter.
     * @param {SubmissionRecordFindUniqueArgs} args - Arguments to find a SubmissionRecord
     * @example
     * // Get one SubmissionRecord
     * const submissionRecord = await prisma.submissionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmissionRecordFindUniqueArgs>(args: SelectSubset<T, SubmissionRecordFindUniqueArgs<ExtArgs>>): Prisma__SubmissionRecordClient<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubmissionRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubmissionRecordFindUniqueOrThrowArgs} args - Arguments to find a SubmissionRecord
     * @example
     * // Get one SubmissionRecord
     * const submissionRecord = await prisma.submissionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmissionRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, SubmissionRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubmissionRecordClient<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubmissionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionRecordFindFirstArgs} args - Arguments to find a SubmissionRecord
     * @example
     * // Get one SubmissionRecord
     * const submissionRecord = await prisma.submissionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmissionRecordFindFirstArgs>(args?: SelectSubset<T, SubmissionRecordFindFirstArgs<ExtArgs>>): Prisma__SubmissionRecordClient<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubmissionRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionRecordFindFirstOrThrowArgs} args - Arguments to find a SubmissionRecord
     * @example
     * // Get one SubmissionRecord
     * const submissionRecord = await prisma.submissionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmissionRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, SubmissionRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubmissionRecordClient<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubmissionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubmissionRecords
     * const submissionRecords = await prisma.submissionRecord.findMany()
     * 
     * // Get first 10 SubmissionRecords
     * const submissionRecords = await prisma.submissionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionRecordWithIdOnly = await prisma.submissionRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubmissionRecordFindManyArgs>(args?: SelectSubset<T, SubmissionRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubmissionRecord.
     * @param {SubmissionRecordCreateArgs} args - Arguments to create a SubmissionRecord.
     * @example
     * // Create one SubmissionRecord
     * const SubmissionRecord = await prisma.submissionRecord.create({
     *   data: {
     *     // ... data to create a SubmissionRecord
     *   }
     * })
     * 
     */
    create<T extends SubmissionRecordCreateArgs>(args: SelectSubset<T, SubmissionRecordCreateArgs<ExtArgs>>): Prisma__SubmissionRecordClient<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubmissionRecords.
     * @param {SubmissionRecordCreateManyArgs} args - Arguments to create many SubmissionRecords.
     * @example
     * // Create many SubmissionRecords
     * const submissionRecord = await prisma.submissionRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubmissionRecordCreateManyArgs>(args?: SelectSubset<T, SubmissionRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubmissionRecords and returns the data saved in the database.
     * @param {SubmissionRecordCreateManyAndReturnArgs} args - Arguments to create many SubmissionRecords.
     * @example
     * // Create many SubmissionRecords
     * const submissionRecord = await prisma.submissionRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubmissionRecords and only return the `id`
     * const submissionRecordWithIdOnly = await prisma.submissionRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubmissionRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, SubmissionRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubmissionRecord.
     * @param {SubmissionRecordDeleteArgs} args - Arguments to delete one SubmissionRecord.
     * @example
     * // Delete one SubmissionRecord
     * const SubmissionRecord = await prisma.submissionRecord.delete({
     *   where: {
     *     // ... filter to delete one SubmissionRecord
     *   }
     * })
     * 
     */
    delete<T extends SubmissionRecordDeleteArgs>(args: SelectSubset<T, SubmissionRecordDeleteArgs<ExtArgs>>): Prisma__SubmissionRecordClient<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubmissionRecord.
     * @param {SubmissionRecordUpdateArgs} args - Arguments to update one SubmissionRecord.
     * @example
     * // Update one SubmissionRecord
     * const submissionRecord = await prisma.submissionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubmissionRecordUpdateArgs>(args: SelectSubset<T, SubmissionRecordUpdateArgs<ExtArgs>>): Prisma__SubmissionRecordClient<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubmissionRecords.
     * @param {SubmissionRecordDeleteManyArgs} args - Arguments to filter SubmissionRecords to delete.
     * @example
     * // Delete a few SubmissionRecords
     * const { count } = await prisma.submissionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubmissionRecordDeleteManyArgs>(args?: SelectSubset<T, SubmissionRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubmissionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubmissionRecords
     * const submissionRecord = await prisma.submissionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubmissionRecordUpdateManyArgs>(args: SelectSubset<T, SubmissionRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubmissionRecords and returns the data updated in the database.
     * @param {SubmissionRecordUpdateManyAndReturnArgs} args - Arguments to update many SubmissionRecords.
     * @example
     * // Update many SubmissionRecords
     * const submissionRecord = await prisma.submissionRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubmissionRecords and only return the `id`
     * const submissionRecordWithIdOnly = await prisma.submissionRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubmissionRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, SubmissionRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubmissionRecord.
     * @param {SubmissionRecordUpsertArgs} args - Arguments to update or create a SubmissionRecord.
     * @example
     * // Update or create a SubmissionRecord
     * const submissionRecord = await prisma.submissionRecord.upsert({
     *   create: {
     *     // ... data to create a SubmissionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubmissionRecord we want to update
     *   }
     * })
     */
    upsert<T extends SubmissionRecordUpsertArgs>(args: SelectSubset<T, SubmissionRecordUpsertArgs<ExtArgs>>): Prisma__SubmissionRecordClient<$Result.GetResult<Prisma.$SubmissionRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubmissionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionRecordCountArgs} args - Arguments to filter SubmissionRecords to count.
     * @example
     * // Count the number of SubmissionRecords
     * const count = await prisma.submissionRecord.count({
     *   where: {
     *     // ... the filter for the SubmissionRecords we want to count
     *   }
     * })
    **/
    count<T extends SubmissionRecordCountArgs>(
      args?: Subset<T, SubmissionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubmissionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionRecordAggregateArgs>(args: Subset<T, SubmissionRecordAggregateArgs>): Prisma.PrismaPromise<GetSubmissionRecordAggregateType<T>>

    /**
     * Group by SubmissionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionRecordGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubmissionRecord model
   */
  readonly fields: SubmissionRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubmissionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmissionRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    artifact<T extends ArtifactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArtifactDefaultArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubmissionRecord model
   */
  interface SubmissionRecordFieldRefs {
    readonly id: FieldRef<"SubmissionRecord", 'String'>
    readonly projectId: FieldRef<"SubmissionRecord", 'String'>
    readonly artifactId: FieldRef<"SubmissionRecord", 'String'>
    readonly portalName: FieldRef<"SubmissionRecord", 'String'>
    readonly submissionId: FieldRef<"SubmissionRecord", 'String'>
    readonly status: FieldRef<"SubmissionRecord", 'String'>
    readonly submittedBy: FieldRef<"SubmissionRecord", 'String'>
    readonly submittedAt: FieldRef<"SubmissionRecord", 'DateTime'>
    readonly submissionMetadata: FieldRef<"SubmissionRecord", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * SubmissionRecord findUnique
   */
  export type SubmissionRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionRecord to fetch.
     */
    where: SubmissionRecordWhereUniqueInput
  }

  /**
   * SubmissionRecord findUniqueOrThrow
   */
  export type SubmissionRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionRecord to fetch.
     */
    where: SubmissionRecordWhereUniqueInput
  }

  /**
   * SubmissionRecord findFirst
   */
  export type SubmissionRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionRecord to fetch.
     */
    where?: SubmissionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionRecords to fetch.
     */
    orderBy?: SubmissionRecordOrderByWithRelationInput | SubmissionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubmissionRecords.
     */
    cursor?: SubmissionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubmissionRecords.
     */
    distinct?: SubmissionRecordScalarFieldEnum | SubmissionRecordScalarFieldEnum[]
  }

  /**
   * SubmissionRecord findFirstOrThrow
   */
  export type SubmissionRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionRecord to fetch.
     */
    where?: SubmissionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionRecords to fetch.
     */
    orderBy?: SubmissionRecordOrderByWithRelationInput | SubmissionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubmissionRecords.
     */
    cursor?: SubmissionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubmissionRecords.
     */
    distinct?: SubmissionRecordScalarFieldEnum | SubmissionRecordScalarFieldEnum[]
  }

  /**
   * SubmissionRecord findMany
   */
  export type SubmissionRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    /**
     * Filter, which SubmissionRecords to fetch.
     */
    where?: SubmissionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubmissionRecords to fetch.
     */
    orderBy?: SubmissionRecordOrderByWithRelationInput | SubmissionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubmissionRecords.
     */
    cursor?: SubmissionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubmissionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubmissionRecords.
     */
    skip?: number
    distinct?: SubmissionRecordScalarFieldEnum | SubmissionRecordScalarFieldEnum[]
  }

  /**
   * SubmissionRecord create
   */
  export type SubmissionRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a SubmissionRecord.
     */
    data: XOR<SubmissionRecordCreateInput, SubmissionRecordUncheckedCreateInput>
  }

  /**
   * SubmissionRecord createMany
   */
  export type SubmissionRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubmissionRecords.
     */
    data: SubmissionRecordCreateManyInput | SubmissionRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubmissionRecord createManyAndReturn
   */
  export type SubmissionRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * The data used to create many SubmissionRecords.
     */
    data: SubmissionRecordCreateManyInput | SubmissionRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubmissionRecord update
   */
  export type SubmissionRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a SubmissionRecord.
     */
    data: XOR<SubmissionRecordUpdateInput, SubmissionRecordUncheckedUpdateInput>
    /**
     * Choose, which SubmissionRecord to update.
     */
    where: SubmissionRecordWhereUniqueInput
  }

  /**
   * SubmissionRecord updateMany
   */
  export type SubmissionRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubmissionRecords.
     */
    data: XOR<SubmissionRecordUpdateManyMutationInput, SubmissionRecordUncheckedUpdateManyInput>
    /**
     * Filter which SubmissionRecords to update
     */
    where?: SubmissionRecordWhereInput
    /**
     * Limit how many SubmissionRecords to update.
     */
    limit?: number
  }

  /**
   * SubmissionRecord updateManyAndReturn
   */
  export type SubmissionRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * The data used to update SubmissionRecords.
     */
    data: XOR<SubmissionRecordUpdateManyMutationInput, SubmissionRecordUncheckedUpdateManyInput>
    /**
     * Filter which SubmissionRecords to update
     */
    where?: SubmissionRecordWhereInput
    /**
     * Limit how many SubmissionRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubmissionRecord upsert
   */
  export type SubmissionRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the SubmissionRecord to update in case it exists.
     */
    where: SubmissionRecordWhereUniqueInput
    /**
     * In case the SubmissionRecord found by the `where` argument doesn't exist, create a new SubmissionRecord with this data.
     */
    create: XOR<SubmissionRecordCreateInput, SubmissionRecordUncheckedCreateInput>
    /**
     * In case the SubmissionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmissionRecordUpdateInput, SubmissionRecordUncheckedUpdateInput>
  }

  /**
   * SubmissionRecord delete
   */
  export type SubmissionRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
    /**
     * Filter which SubmissionRecord to delete.
     */
    where: SubmissionRecordWhereUniqueInput
  }

  /**
   * SubmissionRecord deleteMany
   */
  export type SubmissionRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubmissionRecords to delete
     */
    where?: SubmissionRecordWhereInput
    /**
     * Limit how many SubmissionRecords to delete.
     */
    limit?: number
  }

  /**
   * SubmissionRecord without action
   */
  export type SubmissionRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubmissionRecord
     */
    select?: SubmissionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubmissionRecord
     */
    omit?: SubmissionRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionRecordInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    profileImageUrl: 'profileImageUrl',
    preferredLanguage: 'preferredLanguage',
    themePreference: 'themePreference',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLogin: 'lastLogin',
    cognitoUserId: 'cognitoUserId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roleId: 'roleId',
    assignedAt: 'assignedAt',
    assignedBy: 'assignedBy'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    resource: 'resource',
    action: 'action',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    value: 'value',
    deadline: 'deadline',
    progressPercentage: 'progressPercentage',
    createdBy: 'createdBy',
    completedBy: 'completedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt',
    metadata: 'metadata'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectDocumentScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileType: 'fileType',
    fileSize: 'fileSize',
    rawFileLocation: 'rawFileLocation',
    processedFileLocation: 'processedFileLocation',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    metadata: 'metadata'
  };

  export type ProjectDocumentScalarFieldEnum = (typeof ProjectDocumentScalarFieldEnum)[keyof typeof ProjectDocumentScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    addedById: 'addedById',
    joinedAt: 'joinedAt'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const WorkflowExecutionScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    status: 'status',
    initiatedBy: 'initiatedBy',
    handledBy: 'handledBy',
    completedBy: 'completedBy',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    lastUpdatedAt: 'lastUpdatedAt',
    workflowConfig: 'workflowConfig',
    errorLog: 'errorLog',
    errorMessage: 'errorMessage',
    results: 'results'
  };

  export type WorkflowExecutionScalarFieldEnum = (typeof WorkflowExecutionScalarFieldEnum)[keyof typeof WorkflowExecutionScalarFieldEnum]


  export const AgentTaskScalarFieldEnum: {
    id: 'id',
    workflowExecutionId: 'workflowExecutionId',
    initiatedBy: 'initiatedBy',
    handledBy: 'handledBy',
    completedBy: 'completedBy',
    agent: 'agent',
    status: 'status',
    sequenceOrder: 'sequenceOrder',
    inputData: 'inputData',
    outputData: 'outputData',
    taskConfig: 'taskConfig',
    errorLog: 'errorLog',
    errorMessage: 'errorMessage',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    executionTimeSeconds: 'executionTimeSeconds'
  };

  export type AgentTaskScalarFieldEnum = (typeof AgentTaskScalarFieldEnum)[keyof typeof AgentTaskScalarFieldEnum]


  export const ArtifactScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    type: 'type',
    category: 'category',
    status: 'status',
    createdBy: 'createdBy',
    approvedBy: 'approvedBy',
    createdAt: 'createdAt',
    approvedAt: 'approvedAt'
  };

  export type ArtifactScalarFieldEnum = (typeof ArtifactScalarFieldEnum)[keyof typeof ArtifactScalarFieldEnum]


  export const ArtifactVersionScalarFieldEnum: {
    id: 'id',
    artifactId: 'artifactId',
    versionNumber: 'versionNumber',
    content: 'content',
    location: 'location',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type ArtifactVersionScalarFieldEnum = (typeof ArtifactVersionScalarFieldEnum)[keyof typeof ArtifactVersionScalarFieldEnum]


  export const KnowledgeBaseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    scope: 'scope',
    projectId: 'projectId',
    documentCount: 'documentCount',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    vectorStoreId: 'vectorStoreId'
  };

  export type KnowledgeBaseScalarFieldEnum = (typeof KnowledgeBaseScalarFieldEnum)[keyof typeof KnowledgeBaseScalarFieldEnum]


  export const KnowledgeBaseDocumentScalarFieldEnum: {
    id: 'id',
    knowledgeBaseId: 'knowledgeBaseId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileType: 'fileType',
    fileSize: 'fileSize',
    s3Bucket: 's3Bucket',
    s3Key: 's3Key',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt',
    metadata: 'metadata',
    vectorIds: 'vectorIds'
  };

  export type KnowledgeBaseDocumentScalarFieldEnum = (typeof KnowledgeBaseDocumentScalarFieldEnum)[keyof typeof KnowledgeBaseDocumentScalarFieldEnum]


  export const KnowledgeBasePermissionScalarFieldEnum: {
    id: 'id',
    knowledgeBaseId: 'knowledgeBaseId',
    userId: 'userId',
    roleId: 'roleId',
    permissionType: 'permissionType',
    grantedAt: 'grantedAt'
  };

  export type KnowledgeBasePermissionScalarFieldEnum = (typeof KnowledgeBasePermissionScalarFieldEnum)[keyof typeof KnowledgeBasePermissionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    read: 'read',
    metadata: 'metadata',
    createdAt: 'createdAt',
    readAt: 'readAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resourceType: 'resourceType',
    resourceId: 'resourceId',
    previousState: 'previousState',
    newState: 'newState',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AgentConfigurationScalarFieldEnum: {
    id: 'id',
    agentType: 'agentType',
    modelName: 'modelName',
    temperature: 'temperature',
    maxTokens: 'maxTokens',
    systemPrompt: 'systemPrompt',
    additionalParameters: 'additionalParameters',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type AgentConfigurationScalarFieldEnum = (typeof AgentConfigurationScalarFieldEnum)[keyof typeof AgentConfigurationScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    configuration: 'configuration',
    enabled: 'enabled',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const IntegrationLogScalarFieldEnum: {
    id: 'id',
    integrationId: 'integrationId',
    action: 'action',
    status: 'status',
    requestData: 'requestData',
    responseData: 'responseData',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt'
  };

  export type IntegrationLogScalarFieldEnum = (typeof IntegrationLogScalarFieldEnum)[keyof typeof IntegrationLogScalarFieldEnum]


  export const BidStatisticsScalarFieldEnum: {
    id: 'id',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    submittedBids: 'submittedBids',
    wonBids: 'wonBids',
    totalValue: 'totalValue',
    wonValue: 'wonValue',
    successRate: 'successRate',
    activeRfps: 'activeRfps',
    detailedMetrics: 'detailedMetrics',
    calculatedAt: 'calculatedAt'
  };

  export type BidStatisticsScalarFieldEnum = (typeof BidStatisticsScalarFieldEnum)[keyof typeof BidStatisticsScalarFieldEnum]


  export const SubmissionRecordScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    artifactId: 'artifactId',
    portalName: 'portalName',
    submissionId: 'submissionId',
    status: 'status',
    submittedBy: 'submittedBy',
    submittedAt: 'submittedAt',
    submissionMetadata: 'submissionMetadata'
  };

  export type SubmissionRecordScalarFieldEnum = (typeof SubmissionRecordScalarFieldEnum)[keyof typeof SubmissionRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    preferredLanguage?: StringNullableFilter<"User"> | string | null
    themePreference?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    cognitoUserId?: StringFilter<"User"> | string
    roles?: UserRoleListRelationFilter
    projectMemberships?: ProjectMemberListRelationFilter
    createdProjects?: ProjectListRelationFilter
    completedProjects?: ProjectListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    uploadedDocuments?: ProjectDocumentListRelationFilter
    createdKnowledgeBases?: KnowledgeBaseListRelationFilter
    createdArtifacts?: ArtifactListRelationFilter
    approvedArtifacts?: ArtifactListRelationFilter
    submissions?: SubmissionRecordListRelationFilter
    createdIntegrations?: IntegrationListRelationFilter
    uploadedKBDocuments?: KnowledgeBaseDocumentListRelationFilter
    createdArtifactVersions?: ArtifactVersionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrderInput | SortOrder
    themePreference?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    cognitoUserId?: SortOrder
    roles?: UserRoleOrderByRelationAggregateInput
    projectMemberships?: ProjectMemberOrderByRelationAggregateInput
    createdProjects?: ProjectOrderByRelationAggregateInput
    completedProjects?: ProjectOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    uploadedDocuments?: ProjectDocumentOrderByRelationAggregateInput
    createdKnowledgeBases?: KnowledgeBaseOrderByRelationAggregateInput
    createdArtifacts?: ArtifactOrderByRelationAggregateInput
    approvedArtifacts?: ArtifactOrderByRelationAggregateInput
    submissions?: SubmissionRecordOrderByRelationAggregateInput
    createdIntegrations?: IntegrationOrderByRelationAggregateInput
    uploadedKBDocuments?: KnowledgeBaseDocumentOrderByRelationAggregateInput
    createdArtifactVersions?: ArtifactVersionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    cognitoUserId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profileImageUrl?: StringNullableFilter<"User"> | string | null
    preferredLanguage?: StringNullableFilter<"User"> | string | null
    themePreference?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    roles?: UserRoleListRelationFilter
    projectMemberships?: ProjectMemberListRelationFilter
    createdProjects?: ProjectListRelationFilter
    completedProjects?: ProjectListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    uploadedDocuments?: ProjectDocumentListRelationFilter
    createdKnowledgeBases?: KnowledgeBaseListRelationFilter
    createdArtifacts?: ArtifactListRelationFilter
    approvedArtifacts?: ArtifactListRelationFilter
    submissions?: SubmissionRecordListRelationFilter
    createdIntegrations?: IntegrationListRelationFilter
    uploadedKBDocuments?: KnowledgeBaseDocumentListRelationFilter
    createdArtifactVersions?: ArtifactVersionListRelationFilter
  }, "id" | "email" | "username" | "cognitoUserId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrderInput | SortOrder
    themePreference?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    cognitoUserId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    profileImageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferredLanguage?: StringNullableWithAggregatesFilter<"User"> | string | null
    themePreference?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    cognitoUserId?: StringWithAggregatesFilter<"User"> | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: UuidFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
    permissions?: PermissionListRelationFilter
    kbPermissions?: KnowledgeBasePermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
    permissions?: PermissionOrderByRelationAggregateInput
    kbPermissions?: KnowledgeBasePermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
    permissions?: PermissionListRelationFilter
    kbPermissions?: KnowledgeBasePermissionListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: UuidFilter<"UserRole"> | string
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: UuidNullableFilter<"UserRole"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: UuidNullableFilter<"UserRole"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserRole"> | string
    userId?: UuidWithAggregatesFilter<"UserRole"> | string
    roleId?: UuidWithAggregatesFilter<"UserRole"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
    assignedBy?: UuidNullableWithAggregatesFilter<"UserRole"> | string | null
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: UuidFilter<"Permission"> | string
    roleId?: UuidFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_resource_action?: PermissionRoleIdResourceActionCompoundUniqueInput
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    roleId?: UuidFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "roleId_resource_action">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Permission"> | string
    roleId?: UuidWithAggregatesFilter<"Permission"> | string
    resource?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: UuidFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    value?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    deadline?: DateTimeNullableFilter<"Project"> | Date | string | null
    progressPercentage?: IntFilter<"Project"> | number
    createdBy?: UuidFilter<"Project"> | string
    completedBy?: UuidNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    completedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    metadata?: JsonNullableFilter<"Project">
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    completer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    members?: ProjectMemberListRelationFilter
    documents?: ProjectDocumentListRelationFilter
    knowledgeBases?: KnowledgeBaseListRelationFilter
    artifacts?: ArtifactListRelationFilter
    workflowExecutions?: WorkflowExecutionListRelationFilter
    submissions?: SubmissionRecordListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    value?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    progressPercentage?: SortOrder
    createdBy?: SortOrder
    completedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    completer?: UserOrderByWithRelationInput
    members?: ProjectMemberOrderByRelationAggregateInput
    documents?: ProjectDocumentOrderByRelationAggregateInput
    knowledgeBases?: KnowledgeBaseOrderByRelationAggregateInput
    artifacts?: ArtifactOrderByRelationAggregateInput
    workflowExecutions?: WorkflowExecutionOrderByRelationAggregateInput
    submissions?: SubmissionRecordOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    value?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    deadline?: DateTimeNullableFilter<"Project"> | Date | string | null
    progressPercentage?: IntFilter<"Project"> | number
    createdBy?: UuidFilter<"Project"> | string
    completedBy?: UuidNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    completedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    metadata?: JsonNullableFilter<"Project">
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    completer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    members?: ProjectMemberListRelationFilter
    documents?: ProjectDocumentListRelationFilter
    knowledgeBases?: KnowledgeBaseListRelationFilter
    artifacts?: ArtifactListRelationFilter
    workflowExecutions?: WorkflowExecutionListRelationFilter
    submissions?: SubmissionRecordListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    value?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    progressPercentage?: SortOrder
    createdBy?: SortOrder
    completedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    status?: StringWithAggregatesFilter<"Project"> | string
    value?: DecimalNullableWithAggregatesFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    deadline?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    progressPercentage?: IntWithAggregatesFilter<"Project"> | number
    createdBy?: UuidWithAggregatesFilter<"Project"> | string
    completedBy?: UuidNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Project">
  }

  export type ProjectDocumentWhereInput = {
    AND?: ProjectDocumentWhereInput | ProjectDocumentWhereInput[]
    OR?: ProjectDocumentWhereInput[]
    NOT?: ProjectDocumentWhereInput | ProjectDocumentWhereInput[]
    id?: UuidFilter<"ProjectDocument"> | string
    projectId?: UuidFilter<"ProjectDocument"> | string
    fileName?: StringFilter<"ProjectDocument"> | string
    filePath?: StringFilter<"ProjectDocument"> | string
    fileType?: StringFilter<"ProjectDocument"> | string
    fileSize?: BigIntFilter<"ProjectDocument"> | bigint | number
    rawFileLocation?: StringFilter<"ProjectDocument"> | string
    processedFileLocation?: StringNullableFilter<"ProjectDocument"> | string | null
    uploadedBy?: UuidFilter<"ProjectDocument"> | string
    uploadedAt?: DateTimeFilter<"ProjectDocument"> | Date | string
    metadata?: JsonNullableFilter<"ProjectDocument">
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectDocumentOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    rawFileLocation?: SortOrder
    processedFileLocation?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
  }

  export type ProjectDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectDocumentWhereInput | ProjectDocumentWhereInput[]
    OR?: ProjectDocumentWhereInput[]
    NOT?: ProjectDocumentWhereInput | ProjectDocumentWhereInput[]
    projectId?: UuidFilter<"ProjectDocument"> | string
    fileName?: StringFilter<"ProjectDocument"> | string
    filePath?: StringFilter<"ProjectDocument"> | string
    fileType?: StringFilter<"ProjectDocument"> | string
    fileSize?: BigIntFilter<"ProjectDocument"> | bigint | number
    rawFileLocation?: StringFilter<"ProjectDocument"> | string
    processedFileLocation?: StringNullableFilter<"ProjectDocument"> | string | null
    uploadedBy?: UuidFilter<"ProjectDocument"> | string
    uploadedAt?: DateTimeFilter<"ProjectDocument"> | Date | string
    metadata?: JsonNullableFilter<"ProjectDocument">
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ProjectDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    rawFileLocation?: SortOrder
    processedFileLocation?: SortOrderInput | SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ProjectDocumentCountOrderByAggregateInput
    _avg?: ProjectDocumentAvgOrderByAggregateInput
    _max?: ProjectDocumentMaxOrderByAggregateInput
    _min?: ProjectDocumentMinOrderByAggregateInput
    _sum?: ProjectDocumentSumOrderByAggregateInput
  }

  export type ProjectDocumentScalarWhereWithAggregatesInput = {
    AND?: ProjectDocumentScalarWhereWithAggregatesInput | ProjectDocumentScalarWhereWithAggregatesInput[]
    OR?: ProjectDocumentScalarWhereWithAggregatesInput[]
    NOT?: ProjectDocumentScalarWhereWithAggregatesInput | ProjectDocumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProjectDocument"> | string
    projectId?: UuidWithAggregatesFilter<"ProjectDocument"> | string
    fileName?: StringWithAggregatesFilter<"ProjectDocument"> | string
    filePath?: StringWithAggregatesFilter<"ProjectDocument"> | string
    fileType?: StringWithAggregatesFilter<"ProjectDocument"> | string
    fileSize?: BigIntWithAggregatesFilter<"ProjectDocument"> | bigint | number
    rawFileLocation?: StringWithAggregatesFilter<"ProjectDocument"> | string
    processedFileLocation?: StringNullableWithAggregatesFilter<"ProjectDocument"> | string | null
    uploadedBy?: UuidWithAggregatesFilter<"ProjectDocument"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"ProjectDocument"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"ProjectDocument">
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: UuidFilter<"ProjectMember"> | string
    projectId?: UuidFilter<"ProjectMember"> | string
    userId?: UuidFilter<"ProjectMember"> | string
    addedById?: UuidFilter<"ProjectMember"> | string
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrder
    joinedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_userId?: ProjectMemberProjectIdUserIdCompoundUniqueInput
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    projectId?: UuidFilter<"ProjectMember"> | string
    userId?: UuidFilter<"ProjectMember"> | string
    addedById?: UuidFilter<"ProjectMember"> | string
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "projectId_userId">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrder
    joinedAt?: SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProjectMember"> | string
    projectId?: UuidWithAggregatesFilter<"ProjectMember"> | string
    userId?: UuidWithAggregatesFilter<"ProjectMember"> | string
    addedById?: UuidWithAggregatesFilter<"ProjectMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
  }

  export type WorkflowExecutionWhereInput = {
    AND?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[]
    OR?: WorkflowExecutionWhereInput[]
    NOT?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[]
    id?: UuidFilter<"WorkflowExecution"> | string
    projectId?: UuidFilter<"WorkflowExecution"> | string
    status?: StringFilter<"WorkflowExecution"> | string
    initiatedBy?: UuidFilter<"WorkflowExecution"> | string
    handledBy?: UuidNullableFilter<"WorkflowExecution"> | string | null
    completedBy?: UuidNullableFilter<"WorkflowExecution"> | string | null
    startedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowExecution"> | Date | string | null
    lastUpdatedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    workflowConfig?: JsonNullableFilter<"WorkflowExecution">
    errorLog?: JsonNullableFilter<"WorkflowExecution">
    errorMessage?: StringNullableFilter<"WorkflowExecution"> | string | null
    results?: JsonNullableFilter<"WorkflowExecution">
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    agentTasks?: AgentTaskListRelationFilter
  }

  export type WorkflowExecutionOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    initiatedBy?: SortOrder
    handledBy?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastUpdatedAt?: SortOrder
    workflowConfig?: SortOrderInput | SortOrder
    errorLog?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    results?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    agentTasks?: AgentTaskOrderByRelationAggregateInput
  }

  export type WorkflowExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[]
    OR?: WorkflowExecutionWhereInput[]
    NOT?: WorkflowExecutionWhereInput | WorkflowExecutionWhereInput[]
    projectId?: UuidFilter<"WorkflowExecution"> | string
    status?: StringFilter<"WorkflowExecution"> | string
    initiatedBy?: UuidFilter<"WorkflowExecution"> | string
    handledBy?: UuidNullableFilter<"WorkflowExecution"> | string | null
    completedBy?: UuidNullableFilter<"WorkflowExecution"> | string | null
    startedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowExecution"> | Date | string | null
    lastUpdatedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    workflowConfig?: JsonNullableFilter<"WorkflowExecution">
    errorLog?: JsonNullableFilter<"WorkflowExecution">
    errorMessage?: StringNullableFilter<"WorkflowExecution"> | string | null
    results?: JsonNullableFilter<"WorkflowExecution">
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    agentTasks?: AgentTaskListRelationFilter
  }, "id">

  export type WorkflowExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    initiatedBy?: SortOrder
    handledBy?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    lastUpdatedAt?: SortOrder
    workflowConfig?: SortOrderInput | SortOrder
    errorLog?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    results?: SortOrderInput | SortOrder
    _count?: WorkflowExecutionCountOrderByAggregateInput
    _max?: WorkflowExecutionMaxOrderByAggregateInput
    _min?: WorkflowExecutionMinOrderByAggregateInput
  }

  export type WorkflowExecutionScalarWhereWithAggregatesInput = {
    AND?: WorkflowExecutionScalarWhereWithAggregatesInput | WorkflowExecutionScalarWhereWithAggregatesInput[]
    OR?: WorkflowExecutionScalarWhereWithAggregatesInput[]
    NOT?: WorkflowExecutionScalarWhereWithAggregatesInput | WorkflowExecutionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WorkflowExecution"> | string
    projectId?: UuidWithAggregatesFilter<"WorkflowExecution"> | string
    status?: StringWithAggregatesFilter<"WorkflowExecution"> | string
    initiatedBy?: UuidWithAggregatesFilter<"WorkflowExecution"> | string
    handledBy?: UuidNullableWithAggregatesFilter<"WorkflowExecution"> | string | null
    completedBy?: UuidNullableWithAggregatesFilter<"WorkflowExecution"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"WorkflowExecution"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"WorkflowExecution"> | Date | string | null
    lastUpdatedAt?: DateTimeWithAggregatesFilter<"WorkflowExecution"> | Date | string
    workflowConfig?: JsonNullableWithAggregatesFilter<"WorkflowExecution">
    errorLog?: JsonNullableWithAggregatesFilter<"WorkflowExecution">
    errorMessage?: StringNullableWithAggregatesFilter<"WorkflowExecution"> | string | null
    results?: JsonNullableWithAggregatesFilter<"WorkflowExecution">
  }

  export type AgentTaskWhereInput = {
    AND?: AgentTaskWhereInput | AgentTaskWhereInput[]
    OR?: AgentTaskWhereInput[]
    NOT?: AgentTaskWhereInput | AgentTaskWhereInput[]
    id?: UuidFilter<"AgentTask"> | string
    workflowExecutionId?: UuidFilter<"AgentTask"> | string
    initiatedBy?: UuidFilter<"AgentTask"> | string
    handledBy?: UuidNullableFilter<"AgentTask"> | string | null
    completedBy?: UuidNullableFilter<"AgentTask"> | string | null
    agent?: StringFilter<"AgentTask"> | string
    status?: StringFilter<"AgentTask"> | string
    sequenceOrder?: IntFilter<"AgentTask"> | number
    inputData?: JsonNullableFilter<"AgentTask">
    outputData?: JsonNullableFilter<"AgentTask">
    taskConfig?: JsonNullableFilter<"AgentTask">
    errorLog?: JsonNullableFilter<"AgentTask">
    errorMessage?: StringNullableFilter<"AgentTask"> | string | null
    startedAt?: DateTimeNullableFilter<"AgentTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AgentTask"> | Date | string | null
    executionTimeSeconds?: FloatNullableFilter<"AgentTask"> | number | null
    workflowExecution?: XOR<WorkflowExecutionScalarRelationFilter, WorkflowExecutionWhereInput>
  }

  export type AgentTaskOrderByWithRelationInput = {
    id?: SortOrder
    workflowExecutionId?: SortOrder
    initiatedBy?: SortOrder
    handledBy?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    agent?: SortOrder
    status?: SortOrder
    sequenceOrder?: SortOrder
    inputData?: SortOrderInput | SortOrder
    outputData?: SortOrderInput | SortOrder
    taskConfig?: SortOrderInput | SortOrder
    errorLog?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    executionTimeSeconds?: SortOrderInput | SortOrder
    workflowExecution?: WorkflowExecutionOrderByWithRelationInput
  }

  export type AgentTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentTaskWhereInput | AgentTaskWhereInput[]
    OR?: AgentTaskWhereInput[]
    NOT?: AgentTaskWhereInput | AgentTaskWhereInput[]
    workflowExecutionId?: UuidFilter<"AgentTask"> | string
    initiatedBy?: UuidFilter<"AgentTask"> | string
    handledBy?: UuidNullableFilter<"AgentTask"> | string | null
    completedBy?: UuidNullableFilter<"AgentTask"> | string | null
    agent?: StringFilter<"AgentTask"> | string
    status?: StringFilter<"AgentTask"> | string
    sequenceOrder?: IntFilter<"AgentTask"> | number
    inputData?: JsonNullableFilter<"AgentTask">
    outputData?: JsonNullableFilter<"AgentTask">
    taskConfig?: JsonNullableFilter<"AgentTask">
    errorLog?: JsonNullableFilter<"AgentTask">
    errorMessage?: StringNullableFilter<"AgentTask"> | string | null
    startedAt?: DateTimeNullableFilter<"AgentTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AgentTask"> | Date | string | null
    executionTimeSeconds?: FloatNullableFilter<"AgentTask"> | number | null
    workflowExecution?: XOR<WorkflowExecutionScalarRelationFilter, WorkflowExecutionWhereInput>
  }, "id">

  export type AgentTaskOrderByWithAggregationInput = {
    id?: SortOrder
    workflowExecutionId?: SortOrder
    initiatedBy?: SortOrder
    handledBy?: SortOrderInput | SortOrder
    completedBy?: SortOrderInput | SortOrder
    agent?: SortOrder
    status?: SortOrder
    sequenceOrder?: SortOrder
    inputData?: SortOrderInput | SortOrder
    outputData?: SortOrderInput | SortOrder
    taskConfig?: SortOrderInput | SortOrder
    errorLog?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    executionTimeSeconds?: SortOrderInput | SortOrder
    _count?: AgentTaskCountOrderByAggregateInput
    _avg?: AgentTaskAvgOrderByAggregateInput
    _max?: AgentTaskMaxOrderByAggregateInput
    _min?: AgentTaskMinOrderByAggregateInput
    _sum?: AgentTaskSumOrderByAggregateInput
  }

  export type AgentTaskScalarWhereWithAggregatesInput = {
    AND?: AgentTaskScalarWhereWithAggregatesInput | AgentTaskScalarWhereWithAggregatesInput[]
    OR?: AgentTaskScalarWhereWithAggregatesInput[]
    NOT?: AgentTaskScalarWhereWithAggregatesInput | AgentTaskScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AgentTask"> | string
    workflowExecutionId?: UuidWithAggregatesFilter<"AgentTask"> | string
    initiatedBy?: UuidWithAggregatesFilter<"AgentTask"> | string
    handledBy?: UuidNullableWithAggregatesFilter<"AgentTask"> | string | null
    completedBy?: UuidNullableWithAggregatesFilter<"AgentTask"> | string | null
    agent?: StringWithAggregatesFilter<"AgentTask"> | string
    status?: StringWithAggregatesFilter<"AgentTask"> | string
    sequenceOrder?: IntWithAggregatesFilter<"AgentTask"> | number
    inputData?: JsonNullableWithAggregatesFilter<"AgentTask">
    outputData?: JsonNullableWithAggregatesFilter<"AgentTask">
    taskConfig?: JsonNullableWithAggregatesFilter<"AgentTask">
    errorLog?: JsonNullableWithAggregatesFilter<"AgentTask">
    errorMessage?: StringNullableWithAggregatesFilter<"AgentTask"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"AgentTask"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"AgentTask"> | Date | string | null
    executionTimeSeconds?: FloatNullableWithAggregatesFilter<"AgentTask"> | number | null
  }

  export type ArtifactWhereInput = {
    AND?: ArtifactWhereInput | ArtifactWhereInput[]
    OR?: ArtifactWhereInput[]
    NOT?: ArtifactWhereInput | ArtifactWhereInput[]
    id?: UuidFilter<"Artifact"> | string
    projectId?: UuidFilter<"Artifact"> | string
    name?: StringFilter<"Artifact"> | string
    type?: StringFilter<"Artifact"> | string
    category?: StringFilter<"Artifact"> | string
    status?: StringFilter<"Artifact"> | string
    createdBy?: UuidFilter<"Artifact"> | string
    approvedBy?: UuidNullableFilter<"Artifact"> | string | null
    createdAt?: DateTimeFilter<"Artifact"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Artifact"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    versions?: ArtifactVersionListRelationFilter
    submissions?: SubmissionRecordListRelationFilter
  }

  export type ArtifactOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    versions?: ArtifactVersionOrderByRelationAggregateInput
    submissions?: SubmissionRecordOrderByRelationAggregateInput
  }

  export type ArtifactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArtifactWhereInput | ArtifactWhereInput[]
    OR?: ArtifactWhereInput[]
    NOT?: ArtifactWhereInput | ArtifactWhereInput[]
    projectId?: UuidFilter<"Artifact"> | string
    name?: StringFilter<"Artifact"> | string
    type?: StringFilter<"Artifact"> | string
    category?: StringFilter<"Artifact"> | string
    status?: StringFilter<"Artifact"> | string
    createdBy?: UuidFilter<"Artifact"> | string
    approvedBy?: UuidNullableFilter<"Artifact"> | string | null
    createdAt?: DateTimeFilter<"Artifact"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Artifact"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    versions?: ArtifactVersionListRelationFilter
    submissions?: SubmissionRecordListRelationFilter
  }, "id">

  export type ArtifactOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    _count?: ArtifactCountOrderByAggregateInput
    _max?: ArtifactMaxOrderByAggregateInput
    _min?: ArtifactMinOrderByAggregateInput
  }

  export type ArtifactScalarWhereWithAggregatesInput = {
    AND?: ArtifactScalarWhereWithAggregatesInput | ArtifactScalarWhereWithAggregatesInput[]
    OR?: ArtifactScalarWhereWithAggregatesInput[]
    NOT?: ArtifactScalarWhereWithAggregatesInput | ArtifactScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Artifact"> | string
    projectId?: UuidWithAggregatesFilter<"Artifact"> | string
    name?: StringWithAggregatesFilter<"Artifact"> | string
    type?: StringWithAggregatesFilter<"Artifact"> | string
    category?: StringWithAggregatesFilter<"Artifact"> | string
    status?: StringWithAggregatesFilter<"Artifact"> | string
    createdBy?: UuidWithAggregatesFilter<"Artifact"> | string
    approvedBy?: UuidNullableWithAggregatesFilter<"Artifact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Artifact"> | Date | string
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Artifact"> | Date | string | null
  }

  export type ArtifactVersionWhereInput = {
    AND?: ArtifactVersionWhereInput | ArtifactVersionWhereInput[]
    OR?: ArtifactVersionWhereInput[]
    NOT?: ArtifactVersionWhereInput | ArtifactVersionWhereInput[]
    id?: UuidFilter<"ArtifactVersion"> | string
    artifactId?: UuidFilter<"ArtifactVersion"> | string
    versionNumber?: IntFilter<"ArtifactVersion"> | number
    content?: JsonFilter<"ArtifactVersion">
    location?: StringNullableFilter<"ArtifactVersion"> | string | null
    createdBy?: UuidFilter<"ArtifactVersion"> | string
    createdAt?: DateTimeFilter<"ArtifactVersion"> | Date | string
    artifact?: XOR<ArtifactScalarRelationFilter, ArtifactWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ArtifactVersionOrderByWithRelationInput = {
    id?: SortOrder
    artifactId?: SortOrder
    versionNumber?: SortOrder
    content?: SortOrder
    location?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    artifact?: ArtifactOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type ArtifactVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    artifactId_versionNumber?: ArtifactVersionArtifactIdVersionNumberCompoundUniqueInput
    AND?: ArtifactVersionWhereInput | ArtifactVersionWhereInput[]
    OR?: ArtifactVersionWhereInput[]
    NOT?: ArtifactVersionWhereInput | ArtifactVersionWhereInput[]
    artifactId?: UuidFilter<"ArtifactVersion"> | string
    versionNumber?: IntFilter<"ArtifactVersion"> | number
    content?: JsonFilter<"ArtifactVersion">
    location?: StringNullableFilter<"ArtifactVersion"> | string | null
    createdBy?: UuidFilter<"ArtifactVersion"> | string
    createdAt?: DateTimeFilter<"ArtifactVersion"> | Date | string
    artifact?: XOR<ArtifactScalarRelationFilter, ArtifactWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "artifactId_versionNumber">

  export type ArtifactVersionOrderByWithAggregationInput = {
    id?: SortOrder
    artifactId?: SortOrder
    versionNumber?: SortOrder
    content?: SortOrder
    location?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: ArtifactVersionCountOrderByAggregateInput
    _avg?: ArtifactVersionAvgOrderByAggregateInput
    _max?: ArtifactVersionMaxOrderByAggregateInput
    _min?: ArtifactVersionMinOrderByAggregateInput
    _sum?: ArtifactVersionSumOrderByAggregateInput
  }

  export type ArtifactVersionScalarWhereWithAggregatesInput = {
    AND?: ArtifactVersionScalarWhereWithAggregatesInput | ArtifactVersionScalarWhereWithAggregatesInput[]
    OR?: ArtifactVersionScalarWhereWithAggregatesInput[]
    NOT?: ArtifactVersionScalarWhereWithAggregatesInput | ArtifactVersionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ArtifactVersion"> | string
    artifactId?: UuidWithAggregatesFilter<"ArtifactVersion"> | string
    versionNumber?: IntWithAggregatesFilter<"ArtifactVersion"> | number
    content?: JsonWithAggregatesFilter<"ArtifactVersion">
    location?: StringNullableWithAggregatesFilter<"ArtifactVersion"> | string | null
    createdBy?: UuidWithAggregatesFilter<"ArtifactVersion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ArtifactVersion"> | Date | string
  }

  export type KnowledgeBaseWhereInput = {
    AND?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    OR?: KnowledgeBaseWhereInput[]
    NOT?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    id?: UuidFilter<"KnowledgeBase"> | string
    name?: StringFilter<"KnowledgeBase"> | string
    description?: StringNullableFilter<"KnowledgeBase"> | string | null
    scope?: StringFilter<"KnowledgeBase"> | string
    projectId?: UuidNullableFilter<"KnowledgeBase"> | string | null
    documentCount?: IntFilter<"KnowledgeBase"> | number
    createdBy?: UuidFilter<"KnowledgeBase"> | string
    createdAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    vectorStoreId?: StringNullableFilter<"KnowledgeBase"> | string | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    documents?: KnowledgeBaseDocumentListRelationFilter
    permissions?: KnowledgeBasePermissionListRelationFilter
  }

  export type KnowledgeBaseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    scope?: SortOrder
    projectId?: SortOrderInput | SortOrder
    documentCount?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vectorStoreId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    documents?: KnowledgeBaseDocumentOrderByRelationAggregateInput
    permissions?: KnowledgeBasePermissionOrderByRelationAggregateInput
  }

  export type KnowledgeBaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    OR?: KnowledgeBaseWhereInput[]
    NOT?: KnowledgeBaseWhereInput | KnowledgeBaseWhereInput[]
    name?: StringFilter<"KnowledgeBase"> | string
    description?: StringNullableFilter<"KnowledgeBase"> | string | null
    scope?: StringFilter<"KnowledgeBase"> | string
    projectId?: UuidNullableFilter<"KnowledgeBase"> | string | null
    documentCount?: IntFilter<"KnowledgeBase"> | number
    createdBy?: UuidFilter<"KnowledgeBase"> | string
    createdAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    vectorStoreId?: StringNullableFilter<"KnowledgeBase"> | string | null
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    documents?: KnowledgeBaseDocumentListRelationFilter
    permissions?: KnowledgeBasePermissionListRelationFilter
  }, "id">

  export type KnowledgeBaseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    scope?: SortOrder
    projectId?: SortOrderInput | SortOrder
    documentCount?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vectorStoreId?: SortOrderInput | SortOrder
    _count?: KnowledgeBaseCountOrderByAggregateInput
    _avg?: KnowledgeBaseAvgOrderByAggregateInput
    _max?: KnowledgeBaseMaxOrderByAggregateInput
    _min?: KnowledgeBaseMinOrderByAggregateInput
    _sum?: KnowledgeBaseSumOrderByAggregateInput
  }

  export type KnowledgeBaseScalarWhereWithAggregatesInput = {
    AND?: KnowledgeBaseScalarWhereWithAggregatesInput | KnowledgeBaseScalarWhereWithAggregatesInput[]
    OR?: KnowledgeBaseScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeBaseScalarWhereWithAggregatesInput | KnowledgeBaseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"KnowledgeBase"> | string
    name?: StringWithAggregatesFilter<"KnowledgeBase"> | string
    description?: StringNullableWithAggregatesFilter<"KnowledgeBase"> | string | null
    scope?: StringWithAggregatesFilter<"KnowledgeBase"> | string
    projectId?: UuidNullableWithAggregatesFilter<"KnowledgeBase"> | string | null
    documentCount?: IntWithAggregatesFilter<"KnowledgeBase"> | number
    createdBy?: UuidWithAggregatesFilter<"KnowledgeBase"> | string
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeBase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeBase"> | Date | string
    vectorStoreId?: StringNullableWithAggregatesFilter<"KnowledgeBase"> | string | null
  }

  export type KnowledgeBaseDocumentWhereInput = {
    AND?: KnowledgeBaseDocumentWhereInput | KnowledgeBaseDocumentWhereInput[]
    OR?: KnowledgeBaseDocumentWhereInput[]
    NOT?: KnowledgeBaseDocumentWhereInput | KnowledgeBaseDocumentWhereInput[]
    id?: UuidFilter<"KnowledgeBaseDocument"> | string
    knowledgeBaseId?: UuidFilter<"KnowledgeBaseDocument"> | string
    fileName?: StringFilter<"KnowledgeBaseDocument"> | string
    filePath?: StringFilter<"KnowledgeBaseDocument"> | string
    fileType?: StringFilter<"KnowledgeBaseDocument"> | string
    fileSize?: BigIntFilter<"KnowledgeBaseDocument"> | bigint | number
    s3Bucket?: StringFilter<"KnowledgeBaseDocument"> | string
    s3Key?: StringFilter<"KnowledgeBaseDocument"> | string
    uploadedBy?: UuidFilter<"KnowledgeBaseDocument"> | string
    uploadedAt?: DateTimeFilter<"KnowledgeBaseDocument"> | Date | string
    metadata?: JsonNullableFilter<"KnowledgeBaseDocument">
    vectorIds?: StringNullableFilter<"KnowledgeBaseDocument"> | string | null
    knowledgeBase?: XOR<KnowledgeBaseScalarRelationFilter, KnowledgeBaseWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type KnowledgeBaseDocumentOrderByWithRelationInput = {
    id?: SortOrder
    knowledgeBaseId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    s3Bucket?: SortOrder
    s3Key?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    vectorIds?: SortOrderInput | SortOrder
    knowledgeBase?: KnowledgeBaseOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
  }

  export type KnowledgeBaseDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeBaseDocumentWhereInput | KnowledgeBaseDocumentWhereInput[]
    OR?: KnowledgeBaseDocumentWhereInput[]
    NOT?: KnowledgeBaseDocumentWhereInput | KnowledgeBaseDocumentWhereInput[]
    knowledgeBaseId?: UuidFilter<"KnowledgeBaseDocument"> | string
    fileName?: StringFilter<"KnowledgeBaseDocument"> | string
    filePath?: StringFilter<"KnowledgeBaseDocument"> | string
    fileType?: StringFilter<"KnowledgeBaseDocument"> | string
    fileSize?: BigIntFilter<"KnowledgeBaseDocument"> | bigint | number
    s3Bucket?: StringFilter<"KnowledgeBaseDocument"> | string
    s3Key?: StringFilter<"KnowledgeBaseDocument"> | string
    uploadedBy?: UuidFilter<"KnowledgeBaseDocument"> | string
    uploadedAt?: DateTimeFilter<"KnowledgeBaseDocument"> | Date | string
    metadata?: JsonNullableFilter<"KnowledgeBaseDocument">
    vectorIds?: StringNullableFilter<"KnowledgeBaseDocument"> | string | null
    knowledgeBase?: XOR<KnowledgeBaseScalarRelationFilter, KnowledgeBaseWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type KnowledgeBaseDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    knowledgeBaseId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    s3Bucket?: SortOrder
    s3Key?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    vectorIds?: SortOrderInput | SortOrder
    _count?: KnowledgeBaseDocumentCountOrderByAggregateInput
    _avg?: KnowledgeBaseDocumentAvgOrderByAggregateInput
    _max?: KnowledgeBaseDocumentMaxOrderByAggregateInput
    _min?: KnowledgeBaseDocumentMinOrderByAggregateInput
    _sum?: KnowledgeBaseDocumentSumOrderByAggregateInput
  }

  export type KnowledgeBaseDocumentScalarWhereWithAggregatesInput = {
    AND?: KnowledgeBaseDocumentScalarWhereWithAggregatesInput | KnowledgeBaseDocumentScalarWhereWithAggregatesInput[]
    OR?: KnowledgeBaseDocumentScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeBaseDocumentScalarWhereWithAggregatesInput | KnowledgeBaseDocumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"KnowledgeBaseDocument"> | string
    knowledgeBaseId?: UuidWithAggregatesFilter<"KnowledgeBaseDocument"> | string
    fileName?: StringWithAggregatesFilter<"KnowledgeBaseDocument"> | string
    filePath?: StringWithAggregatesFilter<"KnowledgeBaseDocument"> | string
    fileType?: StringWithAggregatesFilter<"KnowledgeBaseDocument"> | string
    fileSize?: BigIntWithAggregatesFilter<"KnowledgeBaseDocument"> | bigint | number
    s3Bucket?: StringWithAggregatesFilter<"KnowledgeBaseDocument"> | string
    s3Key?: StringWithAggregatesFilter<"KnowledgeBaseDocument"> | string
    uploadedBy?: UuidWithAggregatesFilter<"KnowledgeBaseDocument"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"KnowledgeBaseDocument"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"KnowledgeBaseDocument">
    vectorIds?: StringNullableWithAggregatesFilter<"KnowledgeBaseDocument"> | string | null
  }

  export type KnowledgeBasePermissionWhereInput = {
    AND?: KnowledgeBasePermissionWhereInput | KnowledgeBasePermissionWhereInput[]
    OR?: KnowledgeBasePermissionWhereInput[]
    NOT?: KnowledgeBasePermissionWhereInput | KnowledgeBasePermissionWhereInput[]
    id?: UuidFilter<"KnowledgeBasePermission"> | string
    knowledgeBaseId?: UuidFilter<"KnowledgeBasePermission"> | string
    userId?: UuidNullableFilter<"KnowledgeBasePermission"> | string | null
    roleId?: UuidNullableFilter<"KnowledgeBasePermission"> | string | null
    permissionType?: StringFilter<"KnowledgeBasePermission"> | string
    grantedAt?: DateTimeFilter<"KnowledgeBasePermission"> | Date | string
    knowledgeBase?: XOR<KnowledgeBaseScalarRelationFilter, KnowledgeBaseWhereInput>
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
  }

  export type KnowledgeBasePermissionOrderByWithRelationInput = {
    id?: SortOrder
    knowledgeBaseId?: SortOrder
    userId?: SortOrderInput | SortOrder
    roleId?: SortOrderInput | SortOrder
    permissionType?: SortOrder
    grantedAt?: SortOrder
    knowledgeBase?: KnowledgeBaseOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type KnowledgeBasePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeBasePermissionWhereInput | KnowledgeBasePermissionWhereInput[]
    OR?: KnowledgeBasePermissionWhereInput[]
    NOT?: KnowledgeBasePermissionWhereInput | KnowledgeBasePermissionWhereInput[]
    knowledgeBaseId?: UuidFilter<"KnowledgeBasePermission"> | string
    userId?: UuidNullableFilter<"KnowledgeBasePermission"> | string | null
    roleId?: UuidNullableFilter<"KnowledgeBasePermission"> | string | null
    permissionType?: StringFilter<"KnowledgeBasePermission"> | string
    grantedAt?: DateTimeFilter<"KnowledgeBasePermission"> | Date | string
    knowledgeBase?: XOR<KnowledgeBaseScalarRelationFilter, KnowledgeBaseWhereInput>
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
  }, "id">

  export type KnowledgeBasePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    knowledgeBaseId?: SortOrder
    userId?: SortOrderInput | SortOrder
    roleId?: SortOrderInput | SortOrder
    permissionType?: SortOrder
    grantedAt?: SortOrder
    _count?: KnowledgeBasePermissionCountOrderByAggregateInput
    _max?: KnowledgeBasePermissionMaxOrderByAggregateInput
    _min?: KnowledgeBasePermissionMinOrderByAggregateInput
  }

  export type KnowledgeBasePermissionScalarWhereWithAggregatesInput = {
    AND?: KnowledgeBasePermissionScalarWhereWithAggregatesInput | KnowledgeBasePermissionScalarWhereWithAggregatesInput[]
    OR?: KnowledgeBasePermissionScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeBasePermissionScalarWhereWithAggregatesInput | KnowledgeBasePermissionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"KnowledgeBasePermission"> | string
    knowledgeBaseId?: UuidWithAggregatesFilter<"KnowledgeBasePermission"> | string
    userId?: UuidNullableWithAggregatesFilter<"KnowledgeBasePermission"> | string | null
    roleId?: UuidNullableWithAggregatesFilter<"KnowledgeBasePermission"> | string | null
    permissionType?: StringWithAggregatesFilter<"KnowledgeBasePermission"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"KnowledgeBasePermission"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: UuidFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Notification"> | string
    userId?: UuidWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    userId?: UuidFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: UuidFilter<"AuditLog"> | string
    previousState?: JsonNullableFilter<"AuditLog">
    newState?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    previousState?: SortOrderInput | SortOrder
    newState?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: UuidFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: UuidFilter<"AuditLog"> | string
    previousState?: JsonNullableFilter<"AuditLog">
    newState?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    previousState?: SortOrderInput | SortOrder
    newState?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AuditLog"> | string
    userId?: UuidWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceType?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: UuidWithAggregatesFilter<"AuditLog"> | string
    previousState?: JsonNullableWithAggregatesFilter<"AuditLog">
    newState?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AgentConfigurationWhereInput = {
    AND?: AgentConfigurationWhereInput | AgentConfigurationWhereInput[]
    OR?: AgentConfigurationWhereInput[]
    NOT?: AgentConfigurationWhereInput | AgentConfigurationWhereInput[]
    id?: UuidFilter<"AgentConfiguration"> | string
    agentType?: StringFilter<"AgentConfiguration"> | string
    modelName?: StringFilter<"AgentConfiguration"> | string
    temperature?: FloatFilter<"AgentConfiguration"> | number
    maxTokens?: IntFilter<"AgentConfiguration"> | number
    systemPrompt?: JsonFilter<"AgentConfiguration">
    additionalParameters?: JsonNullableFilter<"AgentConfiguration">
    enabled?: BoolFilter<"AgentConfiguration"> | boolean
    createdAt?: DateTimeFilter<"AgentConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"AgentConfiguration"> | Date | string
    updatedBy?: UuidNullableFilter<"AgentConfiguration"> | string | null
  }

  export type AgentConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    agentType?: SortOrder
    modelName?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    systemPrompt?: SortOrder
    additionalParameters?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type AgentConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agentType?: string
    AND?: AgentConfigurationWhereInput | AgentConfigurationWhereInput[]
    OR?: AgentConfigurationWhereInput[]
    NOT?: AgentConfigurationWhereInput | AgentConfigurationWhereInput[]
    modelName?: StringFilter<"AgentConfiguration"> | string
    temperature?: FloatFilter<"AgentConfiguration"> | number
    maxTokens?: IntFilter<"AgentConfiguration"> | number
    systemPrompt?: JsonFilter<"AgentConfiguration">
    additionalParameters?: JsonNullableFilter<"AgentConfiguration">
    enabled?: BoolFilter<"AgentConfiguration"> | boolean
    createdAt?: DateTimeFilter<"AgentConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"AgentConfiguration"> | Date | string
    updatedBy?: UuidNullableFilter<"AgentConfiguration"> | string | null
  }, "id" | "agentType">

  export type AgentConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    agentType?: SortOrder
    modelName?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    systemPrompt?: SortOrder
    additionalParameters?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: AgentConfigurationCountOrderByAggregateInput
    _avg?: AgentConfigurationAvgOrderByAggregateInput
    _max?: AgentConfigurationMaxOrderByAggregateInput
    _min?: AgentConfigurationMinOrderByAggregateInput
    _sum?: AgentConfigurationSumOrderByAggregateInput
  }

  export type AgentConfigurationScalarWhereWithAggregatesInput = {
    AND?: AgentConfigurationScalarWhereWithAggregatesInput | AgentConfigurationScalarWhereWithAggregatesInput[]
    OR?: AgentConfigurationScalarWhereWithAggregatesInput[]
    NOT?: AgentConfigurationScalarWhereWithAggregatesInput | AgentConfigurationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AgentConfiguration"> | string
    agentType?: StringWithAggregatesFilter<"AgentConfiguration"> | string
    modelName?: StringWithAggregatesFilter<"AgentConfiguration"> | string
    temperature?: FloatWithAggregatesFilter<"AgentConfiguration"> | number
    maxTokens?: IntWithAggregatesFilter<"AgentConfiguration"> | number
    systemPrompt?: JsonWithAggregatesFilter<"AgentConfiguration">
    additionalParameters?: JsonNullableWithAggregatesFilter<"AgentConfiguration">
    enabled?: BoolWithAggregatesFilter<"AgentConfiguration"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AgentConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentConfiguration"> | Date | string
    updatedBy?: UuidNullableWithAggregatesFilter<"AgentConfiguration"> | string | null
  }

  export type IntegrationWhereInput = {
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    id?: UuidFilter<"Integration"> | string
    type?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    configuration?: JsonFilter<"Integration">
    enabled?: BoolFilter<"Integration"> | boolean
    createdBy?: UuidFilter<"Integration"> | string
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    logs?: IntegrationLogListRelationFilter
  }

  export type IntegrationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    configuration?: SortOrder
    enabled?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    logs?: IntegrationLogOrderByRelationAggregateInput
  }

  export type IntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    type?: string
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    name?: StringFilter<"Integration"> | string
    configuration?: JsonFilter<"Integration">
    enabled?: BoolFilter<"Integration"> | boolean
    createdBy?: UuidFilter<"Integration"> | string
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    logs?: IntegrationLogListRelationFilter
  }, "id" | "type">

  export type IntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    configuration?: SortOrder
    enabled?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationCountOrderByAggregateInput
    _max?: IntegrationMaxOrderByAggregateInput
    _min?: IntegrationMinOrderByAggregateInput
  }

  export type IntegrationScalarWhereWithAggregatesInput = {
    AND?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    OR?: IntegrationScalarWhereWithAggregatesInput[]
    NOT?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Integration"> | string
    type?: StringWithAggregatesFilter<"Integration"> | string
    name?: StringWithAggregatesFilter<"Integration"> | string
    configuration?: JsonWithAggregatesFilter<"Integration">
    enabled?: BoolWithAggregatesFilter<"Integration"> | boolean
    createdBy?: UuidWithAggregatesFilter<"Integration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
  }

  export type IntegrationLogWhereInput = {
    AND?: IntegrationLogWhereInput | IntegrationLogWhereInput[]
    OR?: IntegrationLogWhereInput[]
    NOT?: IntegrationLogWhereInput | IntegrationLogWhereInput[]
    id?: UuidFilter<"IntegrationLog"> | string
    integrationId?: UuidFilter<"IntegrationLog"> | string
    action?: StringFilter<"IntegrationLog"> | string
    status?: StringFilter<"IntegrationLog"> | string
    requestData?: JsonNullableFilter<"IntegrationLog">
    responseData?: JsonNullableFilter<"IntegrationLog">
    errorMessage?: StringNullableFilter<"IntegrationLog"> | string | null
    createdAt?: DateTimeFilter<"IntegrationLog"> | Date | string
    integration?: XOR<IntegrationScalarRelationFilter, IntegrationWhereInput>
  }

  export type IntegrationLogOrderByWithRelationInput = {
    id?: SortOrder
    integrationId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    requestData?: SortOrderInput | SortOrder
    responseData?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    integration?: IntegrationOrderByWithRelationInput
  }

  export type IntegrationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntegrationLogWhereInput | IntegrationLogWhereInput[]
    OR?: IntegrationLogWhereInput[]
    NOT?: IntegrationLogWhereInput | IntegrationLogWhereInput[]
    integrationId?: UuidFilter<"IntegrationLog"> | string
    action?: StringFilter<"IntegrationLog"> | string
    status?: StringFilter<"IntegrationLog"> | string
    requestData?: JsonNullableFilter<"IntegrationLog">
    responseData?: JsonNullableFilter<"IntegrationLog">
    errorMessage?: StringNullableFilter<"IntegrationLog"> | string | null
    createdAt?: DateTimeFilter<"IntegrationLog"> | Date | string
    integration?: XOR<IntegrationScalarRelationFilter, IntegrationWhereInput>
  }, "id">

  export type IntegrationLogOrderByWithAggregationInput = {
    id?: SortOrder
    integrationId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    requestData?: SortOrderInput | SortOrder
    responseData?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: IntegrationLogCountOrderByAggregateInput
    _max?: IntegrationLogMaxOrderByAggregateInput
    _min?: IntegrationLogMinOrderByAggregateInput
  }

  export type IntegrationLogScalarWhereWithAggregatesInput = {
    AND?: IntegrationLogScalarWhereWithAggregatesInput | IntegrationLogScalarWhereWithAggregatesInput[]
    OR?: IntegrationLogScalarWhereWithAggregatesInput[]
    NOT?: IntegrationLogScalarWhereWithAggregatesInput | IntegrationLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"IntegrationLog"> | string
    integrationId?: UuidWithAggregatesFilter<"IntegrationLog"> | string
    action?: StringWithAggregatesFilter<"IntegrationLog"> | string
    status?: StringWithAggregatesFilter<"IntegrationLog"> | string
    requestData?: JsonNullableWithAggregatesFilter<"IntegrationLog">
    responseData?: JsonNullableWithAggregatesFilter<"IntegrationLog">
    errorMessage?: StringNullableWithAggregatesFilter<"IntegrationLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"IntegrationLog"> | Date | string
  }

  export type BidStatisticsWhereInput = {
    AND?: BidStatisticsWhereInput | BidStatisticsWhereInput[]
    OR?: BidStatisticsWhereInput[]
    NOT?: BidStatisticsWhereInput | BidStatisticsWhereInput[]
    id?: UuidFilter<"BidStatistics"> | string
    periodStart?: DateTimeFilter<"BidStatistics"> | Date | string
    periodEnd?: DateTimeFilter<"BidStatistics"> | Date | string
    submittedBids?: IntFilter<"BidStatistics"> | number
    wonBids?: IntFilter<"BidStatistics"> | number
    totalValue?: DecimalFilter<"BidStatistics"> | Decimal | DecimalJsLike | number | string
    wonValue?: DecimalFilter<"BidStatistics"> | Decimal | DecimalJsLike | number | string
    successRate?: FloatFilter<"BidStatistics"> | number
    activeRfps?: IntFilter<"BidStatistics"> | number
    detailedMetrics?: JsonNullableFilter<"BidStatistics">
    calculatedAt?: DateTimeFilter<"BidStatistics"> | Date | string
  }

  export type BidStatisticsOrderByWithRelationInput = {
    id?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    submittedBids?: SortOrder
    wonBids?: SortOrder
    totalValue?: SortOrder
    wonValue?: SortOrder
    successRate?: SortOrder
    activeRfps?: SortOrder
    detailedMetrics?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
  }

  export type BidStatisticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    periodStart_periodEnd?: BidStatisticsPeriodStartPeriodEndCompoundUniqueInput
    AND?: BidStatisticsWhereInput | BidStatisticsWhereInput[]
    OR?: BidStatisticsWhereInput[]
    NOT?: BidStatisticsWhereInput | BidStatisticsWhereInput[]
    periodStart?: DateTimeFilter<"BidStatistics"> | Date | string
    periodEnd?: DateTimeFilter<"BidStatistics"> | Date | string
    submittedBids?: IntFilter<"BidStatistics"> | number
    wonBids?: IntFilter<"BidStatistics"> | number
    totalValue?: DecimalFilter<"BidStatistics"> | Decimal | DecimalJsLike | number | string
    wonValue?: DecimalFilter<"BidStatistics"> | Decimal | DecimalJsLike | number | string
    successRate?: FloatFilter<"BidStatistics"> | number
    activeRfps?: IntFilter<"BidStatistics"> | number
    detailedMetrics?: JsonNullableFilter<"BidStatistics">
    calculatedAt?: DateTimeFilter<"BidStatistics"> | Date | string
  }, "id" | "periodStart_periodEnd">

  export type BidStatisticsOrderByWithAggregationInput = {
    id?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    submittedBids?: SortOrder
    wonBids?: SortOrder
    totalValue?: SortOrder
    wonValue?: SortOrder
    successRate?: SortOrder
    activeRfps?: SortOrder
    detailedMetrics?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    _count?: BidStatisticsCountOrderByAggregateInput
    _avg?: BidStatisticsAvgOrderByAggregateInput
    _max?: BidStatisticsMaxOrderByAggregateInput
    _min?: BidStatisticsMinOrderByAggregateInput
    _sum?: BidStatisticsSumOrderByAggregateInput
  }

  export type BidStatisticsScalarWhereWithAggregatesInput = {
    AND?: BidStatisticsScalarWhereWithAggregatesInput | BidStatisticsScalarWhereWithAggregatesInput[]
    OR?: BidStatisticsScalarWhereWithAggregatesInput[]
    NOT?: BidStatisticsScalarWhereWithAggregatesInput | BidStatisticsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BidStatistics"> | string
    periodStart?: DateTimeWithAggregatesFilter<"BidStatistics"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"BidStatistics"> | Date | string
    submittedBids?: IntWithAggregatesFilter<"BidStatistics"> | number
    wonBids?: IntWithAggregatesFilter<"BidStatistics"> | number
    totalValue?: DecimalWithAggregatesFilter<"BidStatistics"> | Decimal | DecimalJsLike | number | string
    wonValue?: DecimalWithAggregatesFilter<"BidStatistics"> | Decimal | DecimalJsLike | number | string
    successRate?: FloatWithAggregatesFilter<"BidStatistics"> | number
    activeRfps?: IntWithAggregatesFilter<"BidStatistics"> | number
    detailedMetrics?: JsonNullableWithAggregatesFilter<"BidStatistics">
    calculatedAt?: DateTimeWithAggregatesFilter<"BidStatistics"> | Date | string
  }

  export type SubmissionRecordWhereInput = {
    AND?: SubmissionRecordWhereInput | SubmissionRecordWhereInput[]
    OR?: SubmissionRecordWhereInput[]
    NOT?: SubmissionRecordWhereInput | SubmissionRecordWhereInput[]
    id?: UuidFilter<"SubmissionRecord"> | string
    projectId?: UuidFilter<"SubmissionRecord"> | string
    artifactId?: UuidFilter<"SubmissionRecord"> | string
    portalName?: StringFilter<"SubmissionRecord"> | string
    submissionId?: StringNullableFilter<"SubmissionRecord"> | string | null
    status?: StringFilter<"SubmissionRecord"> | string
    submittedBy?: UuidFilter<"SubmissionRecord"> | string
    submittedAt?: DateTimeFilter<"SubmissionRecord"> | Date | string
    submissionMetadata?: JsonNullableFilter<"SubmissionRecord">
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    artifact?: XOR<ArtifactScalarRelationFilter, ArtifactWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SubmissionRecordOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    artifactId?: SortOrder
    portalName?: SortOrder
    submissionId?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedBy?: SortOrder
    submittedAt?: SortOrder
    submissionMetadata?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    artifact?: ArtifactOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SubmissionRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubmissionRecordWhereInput | SubmissionRecordWhereInput[]
    OR?: SubmissionRecordWhereInput[]
    NOT?: SubmissionRecordWhereInput | SubmissionRecordWhereInput[]
    projectId?: UuidFilter<"SubmissionRecord"> | string
    artifactId?: UuidFilter<"SubmissionRecord"> | string
    portalName?: StringFilter<"SubmissionRecord"> | string
    submissionId?: StringNullableFilter<"SubmissionRecord"> | string | null
    status?: StringFilter<"SubmissionRecord"> | string
    submittedBy?: UuidFilter<"SubmissionRecord"> | string
    submittedAt?: DateTimeFilter<"SubmissionRecord"> | Date | string
    submissionMetadata?: JsonNullableFilter<"SubmissionRecord">
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    artifact?: XOR<ArtifactScalarRelationFilter, ArtifactWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SubmissionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    artifactId?: SortOrder
    portalName?: SortOrder
    submissionId?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedBy?: SortOrder
    submittedAt?: SortOrder
    submissionMetadata?: SortOrderInput | SortOrder
    _count?: SubmissionRecordCountOrderByAggregateInput
    _max?: SubmissionRecordMaxOrderByAggregateInput
    _min?: SubmissionRecordMinOrderByAggregateInput
  }

  export type SubmissionRecordScalarWhereWithAggregatesInput = {
    AND?: SubmissionRecordScalarWhereWithAggregatesInput | SubmissionRecordScalarWhereWithAggregatesInput[]
    OR?: SubmissionRecordScalarWhereWithAggregatesInput[]
    NOT?: SubmissionRecordScalarWhereWithAggregatesInput | SubmissionRecordScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SubmissionRecord"> | string
    projectId?: UuidWithAggregatesFilter<"SubmissionRecord"> | string
    artifactId?: UuidWithAggregatesFilter<"SubmissionRecord"> | string
    portalName?: StringWithAggregatesFilter<"SubmissionRecord"> | string
    submissionId?: StringNullableWithAggregatesFilter<"SubmissionRecord"> | string | null
    status?: StringWithAggregatesFilter<"SubmissionRecord"> | string
    submittedBy?: UuidWithAggregatesFilter<"SubmissionRecord"> | string
    submittedAt?: DateTimeWithAggregatesFilter<"SubmissionRecord"> | Date | string
    submissionMetadata?: JsonNullableWithAggregatesFilter<"SubmissionRecord">
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
    permissions?: PermissionCreateNestedManyWithoutRoleInput
    kbPermissions?: KnowledgeBasePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutRoleInput
    kbPermissions?: KnowledgeBasePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUpdateManyWithoutRoleNestedInput
    kbPermissions?: KnowledgeBasePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutRoleNestedInput
    kbPermissions?: KnowledgeBasePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    id?: string
    assignedAt?: Date | string
    assignedBy?: string | null
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    roleId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCreateInput = {
    id?: string
    resource: string
    action: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    resource: string
    action: string
    createdAt?: Date | string
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateManyInput = {
    id?: string
    roleId: string
    resource: string
    action: string
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator: UserCreateNestedOneWithoutCreatedProjectsInput
    completer?: UserCreateNestedOneWithoutCompletedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdBy: string
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    completer?: UserUpdateOneWithoutCompletedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdBy: string
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectDocumentCreateInput = {
    id?: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    rawFileLocation: string
    processedFileLocation?: string | null
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type ProjectDocumentUncheckedCreateInput = {
    id?: string
    projectId: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    rawFileLocation: string
    processedFileLocation?: string | null
    uploadedBy: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    rawFileLocation?: StringFieldUpdateOperationsInput | string
    processedFileLocation?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type ProjectDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    rawFileLocation?: StringFieldUpdateOperationsInput | string
    processedFileLocation?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectDocumentCreateManyInput = {
    id?: string
    projectId: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    rawFileLocation: string
    processedFileLocation?: string | null
    uploadedBy: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    rawFileLocation?: StringFieldUpdateOperationsInput | string
    processedFileLocation?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    rawFileLocation?: StringFieldUpdateOperationsInput | string
    processedFileLocation?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectMemberCreateInput = {
    id?: string
    addedById: string
    joinedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    addedById: string
    joinedAt?: Date | string
  }

  export type ProjectMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedById?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedById?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    addedById: string
    joinedAt?: Date | string
  }

  export type ProjectMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedById?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedById?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowExecutionCreateInput = {
    id?: string
    status?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastUpdatedAt?: Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutWorkflowExecutionsInput
    agentTasks?: AgentTaskCreateNestedManyWithoutWorkflowExecutionInput
  }

  export type WorkflowExecutionUncheckedCreateInput = {
    id?: string
    projectId: string
    status?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastUpdatedAt?: Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    agentTasks?: AgentTaskUncheckedCreateNestedManyWithoutWorkflowExecutionInput
  }

  export type WorkflowExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutWorkflowExecutionsNestedInput
    agentTasks?: AgentTaskUpdateManyWithoutWorkflowExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    agentTasks?: AgentTaskUncheckedUpdateManyWithoutWorkflowExecutionNestedInput
  }

  export type WorkflowExecutionCreateManyInput = {
    id?: string
    projectId: string
    status?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastUpdatedAt?: Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentTaskCreateInput = {
    id?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    agent: string
    status?: string
    sequenceOrder: number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    executionTimeSeconds?: number | null
    workflowExecution: WorkflowExecutionCreateNestedOneWithoutAgentTasksInput
  }

  export type AgentTaskUncheckedCreateInput = {
    id?: string
    workflowExecutionId: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    agent: string
    status?: string
    sequenceOrder: number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    executionTimeSeconds?: number | null
  }

  export type AgentTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionTimeSeconds?: NullableFloatFieldUpdateOperationsInput | number | null
    workflowExecution?: WorkflowExecutionUpdateOneRequiredWithoutAgentTasksNestedInput
  }

  export type AgentTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowExecutionId?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionTimeSeconds?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AgentTaskCreateManyInput = {
    id?: string
    workflowExecutionId: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    agent: string
    status?: string
    sequenceOrder: number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    executionTimeSeconds?: number | null
  }

  export type AgentTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionTimeSeconds?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AgentTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowExecutionId?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionTimeSeconds?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ArtifactCreateInput = {
    id?: string
    name: string
    type: string
    category: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutArtifactsInput
    creator: UserCreateNestedOneWithoutCreatedArtifactsInput
    approver?: UserCreateNestedOneWithoutApprovedArtifactsInput
    versions?: ArtifactVersionCreateNestedManyWithoutArtifactInput
    submissions?: SubmissionRecordCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    type: string
    category: string
    status?: string
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
    versions?: ArtifactVersionUncheckedCreateNestedManyWithoutArtifactInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutArtifactsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedArtifactsNestedInput
    approver?: UserUpdateOneWithoutApprovedArtifactsNestedInput
    versions?: ArtifactVersionUpdateManyWithoutArtifactNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutArtifactNestedInput
  }

  export type ArtifactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versions?: ArtifactVersionUncheckedUpdateManyWithoutArtifactNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type ArtifactCreateManyInput = {
    id?: string
    projectId: string
    name: string
    type: string
    category: string
    status?: string
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type ArtifactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArtifactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArtifactVersionCreateInput = {
    id?: string
    versionNumber: number
    content: JsonNullValueInput | InputJsonValue
    location?: string | null
    createdAt?: Date | string
    artifact: ArtifactCreateNestedOneWithoutVersionsInput
    creator: UserCreateNestedOneWithoutCreatedArtifactVersionsInput
  }

  export type ArtifactVersionUncheckedCreateInput = {
    id?: string
    artifactId: string
    versionNumber: number
    content: JsonNullValueInput | InputJsonValue
    location?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ArtifactVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifact?: ArtifactUpdateOneRequiredWithoutVersionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedArtifactVersionsNestedInput
  }

  export type ArtifactVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactVersionCreateManyInput = {
    id?: string
    artifactId: string
    versionNumber: number
    content: JsonNullValueInput | InputJsonValue
    location?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ArtifactVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseCreateInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    documentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
    project?: ProjectCreateNestedOneWithoutKnowledgeBasesInput
    creator: UserCreateNestedOneWithoutCreatedKnowledgeBasesInput
    documents?: KnowledgeBaseDocumentCreateNestedManyWithoutKnowledgeBaseInput
    permissions?: KnowledgeBasePermissionCreateNestedManyWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    projectId?: string | null
    documentCount?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
    documents?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutKnowledgeBaseInput
    permissions?: KnowledgeBasePermissionUncheckedCreateNestedManyWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    documentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneWithoutKnowledgeBasesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedKnowledgeBasesNestedInput
    documents?: KnowledgeBaseDocumentUpdateManyWithoutKnowledgeBaseNestedInput
    permissions?: KnowledgeBasePermissionUpdateManyWithoutKnowledgeBaseNestedInput
  }

  export type KnowledgeBaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    documentCount?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutKnowledgeBaseNestedInput
    permissions?: KnowledgeBasePermissionUncheckedUpdateManyWithoutKnowledgeBaseNestedInput
  }

  export type KnowledgeBaseCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    projectId?: string | null
    documentCount?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
  }

  export type KnowledgeBaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    documentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KnowledgeBaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    documentCount?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KnowledgeBaseDocumentCreateInput = {
    id?: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    s3Bucket: string
    s3Key: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: string | null
    knowledgeBase: KnowledgeBaseCreateNestedOneWithoutDocumentsInput
    uploader: UserCreateNestedOneWithoutUploadedKBDocumentsInput
  }

  export type KnowledgeBaseDocumentUncheckedCreateInput = {
    id?: string
    knowledgeBaseId: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    s3Bucket: string
    s3Key: string
    uploadedBy: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: string | null
  }

  export type KnowledgeBaseDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: NullableStringFieldUpdateOperationsInput | string | null
    knowledgeBase?: KnowledgeBaseUpdateOneRequiredWithoutDocumentsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedKBDocumentsNestedInput
  }

  export type KnowledgeBaseDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeBaseId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KnowledgeBaseDocumentCreateManyInput = {
    id?: string
    knowledgeBaseId: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    s3Bucket: string
    s3Key: string
    uploadedBy: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: string | null
  }

  export type KnowledgeBaseDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KnowledgeBaseDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeBaseId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KnowledgeBasePermissionCreateInput = {
    id?: string
    userId?: string | null
    permissionType: string
    grantedAt?: Date | string
    knowledgeBase: KnowledgeBaseCreateNestedOneWithoutPermissionsInput
    role?: RoleCreateNestedOneWithoutKbPermissionsInput
  }

  export type KnowledgeBasePermissionUncheckedCreateInput = {
    id?: string
    knowledgeBaseId: string
    userId?: string | null
    roleId?: string | null
    permissionType: string
    grantedAt?: Date | string
  }

  export type KnowledgeBasePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionType?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeBase?: KnowledgeBaseUpdateOneRequiredWithoutPermissionsNestedInput
    role?: RoleUpdateOneWithoutKbPermissionsNestedInput
  }

  export type KnowledgeBasePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeBaseId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionType?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBasePermissionCreateManyInput = {
    id?: string
    knowledgeBaseId: string
    userId?: string | null
    roleId?: string | null
    permissionType: string
    grantedAt?: Date | string
  }

  export type KnowledgeBasePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionType?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBasePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeBaseId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionType?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resourceType: string
    resourceId: string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    resourceType: string
    resourceId: string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    resourceType: string
    resourceId: string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentConfigurationCreateInput = {
    id?: string
    agentType: string
    modelName: string
    temperature?: number
    maxTokens: number
    systemPrompt: JsonNullValueInput | InputJsonValue
    additionalParameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type AgentConfigurationUncheckedCreateInput = {
    id?: string
    agentType: string
    modelName: string
    temperature?: number
    maxTokens: number
    systemPrompt: JsonNullValueInput | InputJsonValue
    additionalParameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type AgentConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    systemPrompt?: JsonNullValueInput | InputJsonValue
    additionalParameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    systemPrompt?: JsonNullValueInput | InputJsonValue
    additionalParameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentConfigurationCreateManyInput = {
    id?: string
    agentType: string
    modelName: string
    temperature?: number
    maxTokens: number
    systemPrompt: JsonNullValueInput | InputJsonValue
    additionalParameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type AgentConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    systemPrompt?: JsonNullValueInput | InputJsonValue
    additionalParameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    temperature?: FloatFieldUpdateOperationsInput | number
    maxTokens?: IntFieldUpdateOperationsInput | number
    systemPrompt?: JsonNullValueInput | InputJsonValue
    additionalParameters?: NullableJsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntegrationCreateInput = {
    id?: string
    type: string
    name: string
    configuration: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedIntegrationsInput
    logs?: IntegrationLogCreateNestedManyWithoutIntegrationInput
  }

  export type IntegrationUncheckedCreateInput = {
    id?: string
    type: string
    name: string
    configuration: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: IntegrationLogUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type IntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    configuration?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedIntegrationsNestedInput
    logs?: IntegrationLogUpdateManyWithoutIntegrationNestedInput
  }

  export type IntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    configuration?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: IntegrationLogUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type IntegrationCreateManyInput = {
    id?: string
    type: string
    name: string
    configuration: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    configuration?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    configuration?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationLogCreateInput = {
    id?: string
    action: string
    status: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
    integration: IntegrationCreateNestedOneWithoutLogsInput
  }

  export type IntegrationLogUncheckedCreateInput = {
    id?: string
    integrationId: string
    action: string
    status: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type IntegrationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integration?: IntegrationUpdateOneRequiredWithoutLogsNestedInput
  }

  export type IntegrationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationLogCreateManyInput = {
    id?: string
    integrationId: string
    action: string
    status: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type IntegrationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    integrationId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidStatisticsCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    submittedBids: number
    wonBids: number
    totalValue: Decimal | DecimalJsLike | number | string
    wonValue: Decimal | DecimalJsLike | number | string
    successRate: number
    activeRfps: number
    detailedMetrics?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: Date | string
  }

  export type BidStatisticsUncheckedCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    submittedBids: number
    wonBids: number
    totalValue: Decimal | DecimalJsLike | number | string
    wonValue: Decimal | DecimalJsLike | number | string
    successRate: number
    activeRfps: number
    detailedMetrics?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: Date | string
  }

  export type BidStatisticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedBids?: IntFieldUpdateOperationsInput | number
    wonBids?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    successRate?: FloatFieldUpdateOperationsInput | number
    activeRfps?: IntFieldUpdateOperationsInput | number
    detailedMetrics?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidStatisticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedBids?: IntFieldUpdateOperationsInput | number
    wonBids?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    successRate?: FloatFieldUpdateOperationsInput | number
    activeRfps?: IntFieldUpdateOperationsInput | number
    detailedMetrics?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidStatisticsCreateManyInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    submittedBids: number
    wonBids: number
    totalValue: Decimal | DecimalJsLike | number | string
    wonValue: Decimal | DecimalJsLike | number | string
    successRate: number
    activeRfps: number
    detailedMetrics?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: Date | string
  }

  export type BidStatisticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedBids?: IntFieldUpdateOperationsInput | number
    wonBids?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    successRate?: FloatFieldUpdateOperationsInput | number
    activeRfps?: IntFieldUpdateOperationsInput | number
    detailedMetrics?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidStatisticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedBids?: IntFieldUpdateOperationsInput | number
    wonBids?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    successRate?: FloatFieldUpdateOperationsInput | number
    activeRfps?: IntFieldUpdateOperationsInput | number
    detailedMetrics?: NullableJsonNullValueInput | InputJsonValue
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionRecordCreateInput = {
    id?: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutSubmissionsInput
    artifact: ArtifactCreateNestedOneWithoutSubmissionsInput
    user: UserCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionRecordUncheckedCreateInput = {
    id?: string
    projectId: string
    artifactId: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedBy: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutSubmissionsNestedInput
    artifact?: ArtifactUpdateOneRequiredWithoutSubmissionsNestedInput
    user?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordCreateManyInput = {
    id?: string
    projectId: string
    artifactId: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedBy: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type ProjectDocumentListRelationFilter = {
    every?: ProjectDocumentWhereInput
    some?: ProjectDocumentWhereInput
    none?: ProjectDocumentWhereInput
  }

  export type KnowledgeBaseListRelationFilter = {
    every?: KnowledgeBaseWhereInput
    some?: KnowledgeBaseWhereInput
    none?: KnowledgeBaseWhereInput
  }

  export type ArtifactListRelationFilter = {
    every?: ArtifactWhereInput
    some?: ArtifactWhereInput
    none?: ArtifactWhereInput
  }

  export type SubmissionRecordListRelationFilter = {
    every?: SubmissionRecordWhereInput
    some?: SubmissionRecordWhereInput
    none?: SubmissionRecordWhereInput
  }

  export type IntegrationListRelationFilter = {
    every?: IntegrationWhereInput
    some?: IntegrationWhereInput
    none?: IntegrationWhereInput
  }

  export type KnowledgeBaseDocumentListRelationFilter = {
    every?: KnowledgeBaseDocumentWhereInput
    some?: KnowledgeBaseDocumentWhereInput
    none?: KnowledgeBaseDocumentWhereInput
  }

  export type ArtifactVersionListRelationFilter = {
    every?: ArtifactVersionWhereInput
    some?: ArtifactVersionWhereInput
    none?: ArtifactVersionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeBaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtifactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubmissionRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeBaseDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtifactVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrder
    preferredLanguage?: SortOrder
    themePreference?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    cognitoUserId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrder
    preferredLanguage?: SortOrder
    themePreference?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    cognitoUserId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImageUrl?: SortOrder
    preferredLanguage?: SortOrder
    themePreference?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    cognitoUserId?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type KnowledgeBasePermissionListRelationFilter = {
    every?: KnowledgeBasePermissionWhereInput
    some?: KnowledgeBasePermissionWhereInput
    none?: KnowledgeBasePermissionWhereInput
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeBasePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    assignedBy?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PermissionRoleIdResourceActionCompoundUniqueInput = {
    roleId: string
    resource: string
    action: string
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type WorkflowExecutionListRelationFilter = {
    every?: WorkflowExecutionWhereInput
    some?: WorkflowExecutionWhereInput
    none?: WorkflowExecutionWhereInput
  }

  export type WorkflowExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    value?: SortOrder
    deadline?: SortOrder
    progressPercentage?: SortOrder
    createdBy?: SortOrder
    completedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
    metadata?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    value?: SortOrder
    progressPercentage?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    value?: SortOrder
    deadline?: SortOrder
    progressPercentage?: SortOrder
    createdBy?: SortOrder
    completedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    value?: SortOrder
    deadline?: SortOrder
    progressPercentage?: SortOrder
    createdBy?: SortOrder
    completedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    value?: SortOrder
    progressPercentage?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    rawFileLocation?: SortOrder
    processedFileLocation?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    metadata?: SortOrder
  }

  export type ProjectDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ProjectDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    rawFileLocation?: SortOrder
    processedFileLocation?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ProjectDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    rawFileLocation?: SortOrder
    processedFileLocation?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ProjectDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type ProjectMemberProjectIdUserIdCompoundUniqueInput = {
    projectId: string
    userId: string
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrder
    joinedAt?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    addedById?: SortOrder
    joinedAt?: SortOrder
  }

  export type AgentTaskListRelationFilter = {
    every?: AgentTaskWhereInput
    some?: AgentTaskWhereInput
    none?: AgentTaskWhereInput
  }

  export type AgentTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    initiatedBy?: SortOrder
    handledBy?: SortOrder
    completedBy?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    workflowConfig?: SortOrder
    errorLog?: SortOrder
    errorMessage?: SortOrder
    results?: SortOrder
  }

  export type WorkflowExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    initiatedBy?: SortOrder
    handledBy?: SortOrder
    completedBy?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type WorkflowExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    status?: SortOrder
    initiatedBy?: SortOrder
    handledBy?: SortOrder
    completedBy?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    errorMessage?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type WorkflowExecutionScalarRelationFilter = {
    is?: WorkflowExecutionWhereInput
    isNot?: WorkflowExecutionWhereInput
  }

  export type AgentTaskCountOrderByAggregateInput = {
    id?: SortOrder
    workflowExecutionId?: SortOrder
    initiatedBy?: SortOrder
    handledBy?: SortOrder
    completedBy?: SortOrder
    agent?: SortOrder
    status?: SortOrder
    sequenceOrder?: SortOrder
    inputData?: SortOrder
    outputData?: SortOrder
    taskConfig?: SortOrder
    errorLog?: SortOrder
    errorMessage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    executionTimeSeconds?: SortOrder
  }

  export type AgentTaskAvgOrderByAggregateInput = {
    sequenceOrder?: SortOrder
    executionTimeSeconds?: SortOrder
  }

  export type AgentTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowExecutionId?: SortOrder
    initiatedBy?: SortOrder
    handledBy?: SortOrder
    completedBy?: SortOrder
    agent?: SortOrder
    status?: SortOrder
    sequenceOrder?: SortOrder
    errorMessage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    executionTimeSeconds?: SortOrder
  }

  export type AgentTaskMinOrderByAggregateInput = {
    id?: SortOrder
    workflowExecutionId?: SortOrder
    initiatedBy?: SortOrder
    handledBy?: SortOrder
    completedBy?: SortOrder
    agent?: SortOrder
    status?: SortOrder
    sequenceOrder?: SortOrder
    errorMessage?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    executionTimeSeconds?: SortOrder
  }

  export type AgentTaskSumOrderByAggregateInput = {
    sequenceOrder?: SortOrder
    executionTimeSeconds?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ArtifactCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type ArtifactMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
  }

  export type ArtifactMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    category?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    createdAt?: SortOrder
    approvedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ArtifactScalarRelationFilter = {
    is?: ArtifactWhereInput
    isNot?: ArtifactWhereInput
  }

  export type ArtifactVersionArtifactIdVersionNumberCompoundUniqueInput = {
    artifactId: string
    versionNumber: number
  }

  export type ArtifactVersionCountOrderByAggregateInput = {
    id?: SortOrder
    artifactId?: SortOrder
    versionNumber?: SortOrder
    content?: SortOrder
    location?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ArtifactVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type ArtifactVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    artifactId?: SortOrder
    versionNumber?: SortOrder
    location?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ArtifactVersionMinOrderByAggregateInput = {
    id?: SortOrder
    artifactId?: SortOrder
    versionNumber?: SortOrder
    location?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ArtifactVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type KnowledgeBaseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scope?: SortOrder
    projectId?: SortOrder
    documentCount?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vectorStoreId?: SortOrder
  }

  export type KnowledgeBaseAvgOrderByAggregateInput = {
    documentCount?: SortOrder
  }

  export type KnowledgeBaseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scope?: SortOrder
    projectId?: SortOrder
    documentCount?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vectorStoreId?: SortOrder
  }

  export type KnowledgeBaseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scope?: SortOrder
    projectId?: SortOrder
    documentCount?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vectorStoreId?: SortOrder
  }

  export type KnowledgeBaseSumOrderByAggregateInput = {
    documentCount?: SortOrder
  }

  export type KnowledgeBaseScalarRelationFilter = {
    is?: KnowledgeBaseWhereInput
    isNot?: KnowledgeBaseWhereInput
  }

  export type KnowledgeBaseDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    knowledgeBaseId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    s3Bucket?: SortOrder
    s3Key?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    metadata?: SortOrder
    vectorIds?: SortOrder
  }

  export type KnowledgeBaseDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type KnowledgeBaseDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    knowledgeBaseId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    s3Bucket?: SortOrder
    s3Key?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    vectorIds?: SortOrder
  }

  export type KnowledgeBaseDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    knowledgeBaseId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    s3Bucket?: SortOrder
    s3Key?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    vectorIds?: SortOrder
  }

  export type KnowledgeBaseDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type RoleNullableScalarRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type KnowledgeBasePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    knowledgeBaseId?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    permissionType?: SortOrder
    grantedAt?: SortOrder
  }

  export type KnowledgeBasePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    knowledgeBaseId?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    permissionType?: SortOrder
    grantedAt?: SortOrder
  }

  export type KnowledgeBasePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    knowledgeBaseId?: SortOrder
    userId?: SortOrder
    roleId?: SortOrder
    permissionType?: SortOrder
    grantedAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    previousState?: SortOrder
    newState?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceType?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AgentConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    agentType?: SortOrder
    modelName?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    systemPrompt?: SortOrder
    additionalParameters?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type AgentConfigurationAvgOrderByAggregateInput = {
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type AgentConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    agentType?: SortOrder
    modelName?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type AgentConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    agentType?: SortOrder
    modelName?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type AgentConfigurationSumOrderByAggregateInput = {
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntegrationLogListRelationFilter = {
    every?: IntegrationLogWhereInput
    some?: IntegrationLogWhereInput
    none?: IntegrationLogWhereInput
  }

  export type IntegrationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    configuration?: SortOrder
    enabled?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationScalarRelationFilter = {
    is?: IntegrationWhereInput
    isNot?: IntegrationWhereInput
  }

  export type IntegrationLogCountOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    requestData?: SortOrder
    responseData?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type IntegrationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type IntegrationLogMinOrderByAggregateInput = {
    id?: SortOrder
    integrationId?: SortOrder
    action?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BidStatisticsPeriodStartPeriodEndCompoundUniqueInput = {
    periodStart: Date | string
    periodEnd: Date | string
  }

  export type BidStatisticsCountOrderByAggregateInput = {
    id?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    submittedBids?: SortOrder
    wonBids?: SortOrder
    totalValue?: SortOrder
    wonValue?: SortOrder
    successRate?: SortOrder
    activeRfps?: SortOrder
    detailedMetrics?: SortOrder
    calculatedAt?: SortOrder
  }

  export type BidStatisticsAvgOrderByAggregateInput = {
    submittedBids?: SortOrder
    wonBids?: SortOrder
    totalValue?: SortOrder
    wonValue?: SortOrder
    successRate?: SortOrder
    activeRfps?: SortOrder
  }

  export type BidStatisticsMaxOrderByAggregateInput = {
    id?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    submittedBids?: SortOrder
    wonBids?: SortOrder
    totalValue?: SortOrder
    wonValue?: SortOrder
    successRate?: SortOrder
    activeRfps?: SortOrder
    calculatedAt?: SortOrder
  }

  export type BidStatisticsMinOrderByAggregateInput = {
    id?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    submittedBids?: SortOrder
    wonBids?: SortOrder
    totalValue?: SortOrder
    wonValue?: SortOrder
    successRate?: SortOrder
    activeRfps?: SortOrder
    calculatedAt?: SortOrder
  }

  export type BidStatisticsSumOrderByAggregateInput = {
    submittedBids?: SortOrder
    wonBids?: SortOrder
    totalValue?: SortOrder
    wonValue?: SortOrder
    successRate?: SortOrder
    activeRfps?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type SubmissionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    artifactId?: SortOrder
    portalName?: SortOrder
    submissionId?: SortOrder
    status?: SortOrder
    submittedBy?: SortOrder
    submittedAt?: SortOrder
    submissionMetadata?: SortOrder
  }

  export type SubmissionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    artifactId?: SortOrder
    portalName?: SortOrder
    submissionId?: SortOrder
    status?: SortOrder
    submittedBy?: SortOrder
    submittedAt?: SortOrder
  }

  export type SubmissionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    artifactId?: SortOrder
    portalName?: SortOrder
    submissionId?: SortOrder
    status?: SortOrder
    submittedBy?: SortOrder
    submittedAt?: SortOrder
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutCompleterInput = {
    create?: XOR<ProjectCreateWithoutCompleterInput, ProjectUncheckedCreateWithoutCompleterInput> | ProjectCreateWithoutCompleterInput[] | ProjectUncheckedCreateWithoutCompleterInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompleterInput | ProjectCreateOrConnectWithoutCompleterInput[]
    createMany?: ProjectCreateManyCompleterInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ProjectDocumentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<ProjectDocumentCreateWithoutUploaderInput, ProjectDocumentUncheckedCreateWithoutUploaderInput> | ProjectDocumentCreateWithoutUploaderInput[] | ProjectDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutUploaderInput | ProjectDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: ProjectDocumentCreateManyUploaderInputEnvelope
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
  }

  export type KnowledgeBaseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<KnowledgeBaseCreateWithoutCreatorInput, KnowledgeBaseUncheckedCreateWithoutCreatorInput> | KnowledgeBaseCreateWithoutCreatorInput[] | KnowledgeBaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutCreatorInput | KnowledgeBaseCreateOrConnectWithoutCreatorInput[]
    createMany?: KnowledgeBaseCreateManyCreatorInputEnvelope
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
  }

  export type ArtifactCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ArtifactCreateWithoutCreatorInput, ArtifactUncheckedCreateWithoutCreatorInput> | ArtifactCreateWithoutCreatorInput[] | ArtifactUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutCreatorInput | ArtifactCreateOrConnectWithoutCreatorInput[]
    createMany?: ArtifactCreateManyCreatorInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type ArtifactCreateNestedManyWithoutApproverInput = {
    create?: XOR<ArtifactCreateWithoutApproverInput, ArtifactUncheckedCreateWithoutApproverInput> | ArtifactCreateWithoutApproverInput[] | ArtifactUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutApproverInput | ArtifactCreateOrConnectWithoutApproverInput[]
    createMany?: ArtifactCreateManyApproverInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type SubmissionRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<SubmissionRecordCreateWithoutUserInput, SubmissionRecordUncheckedCreateWithoutUserInput> | SubmissionRecordCreateWithoutUserInput[] | SubmissionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutUserInput | SubmissionRecordCreateOrConnectWithoutUserInput[]
    createMany?: SubmissionRecordCreateManyUserInputEnvelope
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
  }

  export type IntegrationCreateNestedManyWithoutCreatorInput = {
    create?: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput> | IntegrationCreateWithoutCreatorInput[] | IntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutCreatorInput | IntegrationCreateOrConnectWithoutCreatorInput[]
    createMany?: IntegrationCreateManyCreatorInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<KnowledgeBaseDocumentCreateWithoutUploaderInput, KnowledgeBaseDocumentUncheckedCreateWithoutUploaderInput> | KnowledgeBaseDocumentCreateWithoutUploaderInput[] | KnowledgeBaseDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: KnowledgeBaseDocumentCreateOrConnectWithoutUploaderInput | KnowledgeBaseDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: KnowledgeBaseDocumentCreateManyUploaderInputEnvelope
    connect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
  }

  export type ArtifactVersionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ArtifactVersionCreateWithoutCreatorInput, ArtifactVersionUncheckedCreateWithoutCreatorInput> | ArtifactVersionCreateWithoutCreatorInput[] | ArtifactVersionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArtifactVersionCreateOrConnectWithoutCreatorInput | ArtifactVersionCreateOrConnectWithoutCreatorInput[]
    createMany?: ArtifactVersionCreateManyCreatorInputEnvelope
    connect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCompleterInput = {
    create?: XOR<ProjectCreateWithoutCompleterInput, ProjectUncheckedCreateWithoutCompleterInput> | ProjectCreateWithoutCompleterInput[] | ProjectUncheckedCreateWithoutCompleterInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompleterInput | ProjectCreateOrConnectWithoutCompleterInput[]
    createMany?: ProjectCreateManyCompleterInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<ProjectDocumentCreateWithoutUploaderInput, ProjectDocumentUncheckedCreateWithoutUploaderInput> | ProjectDocumentCreateWithoutUploaderInput[] | ProjectDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutUploaderInput | ProjectDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: ProjectDocumentCreateManyUploaderInputEnvelope
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
  }

  export type KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<KnowledgeBaseCreateWithoutCreatorInput, KnowledgeBaseUncheckedCreateWithoutCreatorInput> | KnowledgeBaseCreateWithoutCreatorInput[] | KnowledgeBaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutCreatorInput | KnowledgeBaseCreateOrConnectWithoutCreatorInput[]
    createMany?: KnowledgeBaseCreateManyCreatorInputEnvelope
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
  }

  export type ArtifactUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ArtifactCreateWithoutCreatorInput, ArtifactUncheckedCreateWithoutCreatorInput> | ArtifactCreateWithoutCreatorInput[] | ArtifactUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutCreatorInput | ArtifactCreateOrConnectWithoutCreatorInput[]
    createMany?: ArtifactCreateManyCreatorInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type ArtifactUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<ArtifactCreateWithoutApproverInput, ArtifactUncheckedCreateWithoutApproverInput> | ArtifactCreateWithoutApproverInput[] | ArtifactUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutApproverInput | ArtifactCreateOrConnectWithoutApproverInput[]
    createMany?: ArtifactCreateManyApproverInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type SubmissionRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubmissionRecordCreateWithoutUserInput, SubmissionRecordUncheckedCreateWithoutUserInput> | SubmissionRecordCreateWithoutUserInput[] | SubmissionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutUserInput | SubmissionRecordCreateOrConnectWithoutUserInput[]
    createMany?: SubmissionRecordCreateManyUserInputEnvelope
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
  }

  export type IntegrationUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput> | IntegrationCreateWithoutCreatorInput[] | IntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutCreatorInput | IntegrationCreateOrConnectWithoutCreatorInput[]
    createMany?: IntegrationCreateManyCreatorInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<KnowledgeBaseDocumentCreateWithoutUploaderInput, KnowledgeBaseDocumentUncheckedCreateWithoutUploaderInput> | KnowledgeBaseDocumentCreateWithoutUploaderInput[] | KnowledgeBaseDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: KnowledgeBaseDocumentCreateOrConnectWithoutUploaderInput | KnowledgeBaseDocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: KnowledgeBaseDocumentCreateManyUploaderInputEnvelope
    connect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
  }

  export type ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ArtifactVersionCreateWithoutCreatorInput, ArtifactVersionUncheckedCreateWithoutCreatorInput> | ArtifactVersionCreateWithoutCreatorInput[] | ArtifactVersionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArtifactVersionCreateOrConnectWithoutCreatorInput | ArtifactVersionCreateOrConnectWithoutCreatorInput[]
    createMany?: ArtifactVersionCreateManyCreatorInputEnvelope
    connect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatorInput | ProjectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatorInput | ProjectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatorInput | ProjectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutCompleterNestedInput = {
    create?: XOR<ProjectCreateWithoutCompleterInput, ProjectUncheckedCreateWithoutCompleterInput> | ProjectCreateWithoutCompleterInput[] | ProjectUncheckedCreateWithoutCompleterInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompleterInput | ProjectCreateOrConnectWithoutCompleterInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCompleterInput | ProjectUpsertWithWhereUniqueWithoutCompleterInput[]
    createMany?: ProjectCreateManyCompleterInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCompleterInput | ProjectUpdateWithWhereUniqueWithoutCompleterInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCompleterInput | ProjectUpdateManyWithWhereWithoutCompleterInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ProjectDocumentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<ProjectDocumentCreateWithoutUploaderInput, ProjectDocumentUncheckedCreateWithoutUploaderInput> | ProjectDocumentCreateWithoutUploaderInput[] | ProjectDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutUploaderInput | ProjectDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: ProjectDocumentUpsertWithWhereUniqueWithoutUploaderInput | ProjectDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: ProjectDocumentCreateManyUploaderInputEnvelope
    set?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    disconnect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    delete?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    update?: ProjectDocumentUpdateWithWhereUniqueWithoutUploaderInput | ProjectDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: ProjectDocumentUpdateManyWithWhereWithoutUploaderInput | ProjectDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: ProjectDocumentScalarWhereInput | ProjectDocumentScalarWhereInput[]
  }

  export type KnowledgeBaseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<KnowledgeBaseCreateWithoutCreatorInput, KnowledgeBaseUncheckedCreateWithoutCreatorInput> | KnowledgeBaseCreateWithoutCreatorInput[] | KnowledgeBaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutCreatorInput | KnowledgeBaseCreateOrConnectWithoutCreatorInput[]
    upsert?: KnowledgeBaseUpsertWithWhereUniqueWithoutCreatorInput | KnowledgeBaseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: KnowledgeBaseCreateManyCreatorInputEnvelope
    set?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    disconnect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    delete?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    update?: KnowledgeBaseUpdateWithWhereUniqueWithoutCreatorInput | KnowledgeBaseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: KnowledgeBaseUpdateManyWithWhereWithoutCreatorInput | KnowledgeBaseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
  }

  export type ArtifactUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ArtifactCreateWithoutCreatorInput, ArtifactUncheckedCreateWithoutCreatorInput> | ArtifactCreateWithoutCreatorInput[] | ArtifactUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutCreatorInput | ArtifactCreateOrConnectWithoutCreatorInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutCreatorInput | ArtifactUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ArtifactCreateManyCreatorInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutCreatorInput | ArtifactUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutCreatorInput | ArtifactUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type ArtifactUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ArtifactCreateWithoutApproverInput, ArtifactUncheckedCreateWithoutApproverInput> | ArtifactCreateWithoutApproverInput[] | ArtifactUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutApproverInput | ArtifactCreateOrConnectWithoutApproverInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutApproverInput | ArtifactUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ArtifactCreateManyApproverInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutApproverInput | ArtifactUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutApproverInput | ArtifactUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type SubmissionRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubmissionRecordCreateWithoutUserInput, SubmissionRecordUncheckedCreateWithoutUserInput> | SubmissionRecordCreateWithoutUserInput[] | SubmissionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutUserInput | SubmissionRecordCreateOrConnectWithoutUserInput[]
    upsert?: SubmissionRecordUpsertWithWhereUniqueWithoutUserInput | SubmissionRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubmissionRecordCreateManyUserInputEnvelope
    set?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    disconnect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    delete?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    update?: SubmissionRecordUpdateWithWhereUniqueWithoutUserInput | SubmissionRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubmissionRecordUpdateManyWithWhereWithoutUserInput | SubmissionRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubmissionRecordScalarWhereInput | SubmissionRecordScalarWhereInput[]
  }

  export type IntegrationUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput> | IntegrationCreateWithoutCreatorInput[] | IntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutCreatorInput | IntegrationCreateOrConnectWithoutCreatorInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutCreatorInput | IntegrationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: IntegrationCreateManyCreatorInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutCreatorInput | IntegrationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutCreatorInput | IntegrationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<KnowledgeBaseDocumentCreateWithoutUploaderInput, KnowledgeBaseDocumentUncheckedCreateWithoutUploaderInput> | KnowledgeBaseDocumentCreateWithoutUploaderInput[] | KnowledgeBaseDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: KnowledgeBaseDocumentCreateOrConnectWithoutUploaderInput | KnowledgeBaseDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: KnowledgeBaseDocumentUpsertWithWhereUniqueWithoutUploaderInput | KnowledgeBaseDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: KnowledgeBaseDocumentCreateManyUploaderInputEnvelope
    set?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    disconnect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    delete?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    connect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    update?: KnowledgeBaseDocumentUpdateWithWhereUniqueWithoutUploaderInput | KnowledgeBaseDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: KnowledgeBaseDocumentUpdateManyWithWhereWithoutUploaderInput | KnowledgeBaseDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: KnowledgeBaseDocumentScalarWhereInput | KnowledgeBaseDocumentScalarWhereInput[]
  }

  export type ArtifactVersionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ArtifactVersionCreateWithoutCreatorInput, ArtifactVersionUncheckedCreateWithoutCreatorInput> | ArtifactVersionCreateWithoutCreatorInput[] | ArtifactVersionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArtifactVersionCreateOrConnectWithoutCreatorInput | ArtifactVersionCreateOrConnectWithoutCreatorInput[]
    upsert?: ArtifactVersionUpsertWithWhereUniqueWithoutCreatorInput | ArtifactVersionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ArtifactVersionCreateManyCreatorInputEnvelope
    set?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    disconnect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    delete?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    connect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    update?: ArtifactVersionUpdateWithWhereUniqueWithoutCreatorInput | ArtifactVersionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ArtifactVersionUpdateManyWithWhereWithoutCreatorInput | ArtifactVersionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ArtifactVersionScalarWhereInput | ArtifactVersionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatorInput | ProjectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatorInput | ProjectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatorInput | ProjectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCompleterNestedInput = {
    create?: XOR<ProjectCreateWithoutCompleterInput, ProjectUncheckedCreateWithoutCompleterInput> | ProjectCreateWithoutCompleterInput[] | ProjectUncheckedCreateWithoutCompleterInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCompleterInput | ProjectCreateOrConnectWithoutCompleterInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCompleterInput | ProjectUpsertWithWhereUniqueWithoutCompleterInput[]
    createMany?: ProjectCreateManyCompleterInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCompleterInput | ProjectUpdateWithWhereUniqueWithoutCompleterInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCompleterInput | ProjectUpdateManyWithWhereWithoutCompleterInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<ProjectDocumentCreateWithoutUploaderInput, ProjectDocumentUncheckedCreateWithoutUploaderInput> | ProjectDocumentCreateWithoutUploaderInput[] | ProjectDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutUploaderInput | ProjectDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: ProjectDocumentUpsertWithWhereUniqueWithoutUploaderInput | ProjectDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: ProjectDocumentCreateManyUploaderInputEnvelope
    set?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    disconnect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    delete?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    update?: ProjectDocumentUpdateWithWhereUniqueWithoutUploaderInput | ProjectDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: ProjectDocumentUpdateManyWithWhereWithoutUploaderInput | ProjectDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: ProjectDocumentScalarWhereInput | ProjectDocumentScalarWhereInput[]
  }

  export type KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<KnowledgeBaseCreateWithoutCreatorInput, KnowledgeBaseUncheckedCreateWithoutCreatorInput> | KnowledgeBaseCreateWithoutCreatorInput[] | KnowledgeBaseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutCreatorInput | KnowledgeBaseCreateOrConnectWithoutCreatorInput[]
    upsert?: KnowledgeBaseUpsertWithWhereUniqueWithoutCreatorInput | KnowledgeBaseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: KnowledgeBaseCreateManyCreatorInputEnvelope
    set?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    disconnect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    delete?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    update?: KnowledgeBaseUpdateWithWhereUniqueWithoutCreatorInput | KnowledgeBaseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: KnowledgeBaseUpdateManyWithWhereWithoutCreatorInput | KnowledgeBaseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
  }

  export type ArtifactUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ArtifactCreateWithoutCreatorInput, ArtifactUncheckedCreateWithoutCreatorInput> | ArtifactCreateWithoutCreatorInput[] | ArtifactUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutCreatorInput | ArtifactCreateOrConnectWithoutCreatorInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutCreatorInput | ArtifactUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ArtifactCreateManyCreatorInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutCreatorInput | ArtifactUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutCreatorInput | ArtifactUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type ArtifactUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ArtifactCreateWithoutApproverInput, ArtifactUncheckedCreateWithoutApproverInput> | ArtifactCreateWithoutApproverInput[] | ArtifactUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutApproverInput | ArtifactCreateOrConnectWithoutApproverInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutApproverInput | ArtifactUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ArtifactCreateManyApproverInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutApproverInput | ArtifactUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutApproverInput | ArtifactUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubmissionRecordCreateWithoutUserInput, SubmissionRecordUncheckedCreateWithoutUserInput> | SubmissionRecordCreateWithoutUserInput[] | SubmissionRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutUserInput | SubmissionRecordCreateOrConnectWithoutUserInput[]
    upsert?: SubmissionRecordUpsertWithWhereUniqueWithoutUserInput | SubmissionRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubmissionRecordCreateManyUserInputEnvelope
    set?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    disconnect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    delete?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    update?: SubmissionRecordUpdateWithWhereUniqueWithoutUserInput | SubmissionRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubmissionRecordUpdateManyWithWhereWithoutUserInput | SubmissionRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubmissionRecordScalarWhereInput | SubmissionRecordScalarWhereInput[]
  }

  export type IntegrationUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput> | IntegrationCreateWithoutCreatorInput[] | IntegrationUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutCreatorInput | IntegrationCreateOrConnectWithoutCreatorInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutCreatorInput | IntegrationUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: IntegrationCreateManyCreatorInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutCreatorInput | IntegrationUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutCreatorInput | IntegrationUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<KnowledgeBaseDocumentCreateWithoutUploaderInput, KnowledgeBaseDocumentUncheckedCreateWithoutUploaderInput> | KnowledgeBaseDocumentCreateWithoutUploaderInput[] | KnowledgeBaseDocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: KnowledgeBaseDocumentCreateOrConnectWithoutUploaderInput | KnowledgeBaseDocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: KnowledgeBaseDocumentUpsertWithWhereUniqueWithoutUploaderInput | KnowledgeBaseDocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: KnowledgeBaseDocumentCreateManyUploaderInputEnvelope
    set?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    disconnect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    delete?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    connect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    update?: KnowledgeBaseDocumentUpdateWithWhereUniqueWithoutUploaderInput | KnowledgeBaseDocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: KnowledgeBaseDocumentUpdateManyWithWhereWithoutUploaderInput | KnowledgeBaseDocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: KnowledgeBaseDocumentScalarWhereInput | KnowledgeBaseDocumentScalarWhereInput[]
  }

  export type ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ArtifactVersionCreateWithoutCreatorInput, ArtifactVersionUncheckedCreateWithoutCreatorInput> | ArtifactVersionCreateWithoutCreatorInput[] | ArtifactVersionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ArtifactVersionCreateOrConnectWithoutCreatorInput | ArtifactVersionCreateOrConnectWithoutCreatorInput[]
    upsert?: ArtifactVersionUpsertWithWhereUniqueWithoutCreatorInput | ArtifactVersionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ArtifactVersionCreateManyCreatorInputEnvelope
    set?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    disconnect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    delete?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    connect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    update?: ArtifactVersionUpdateWithWhereUniqueWithoutCreatorInput | ArtifactVersionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ArtifactVersionUpdateManyWithWhereWithoutCreatorInput | ArtifactVersionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ArtifactVersionScalarWhereInput | ArtifactVersionScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type PermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    createMany?: PermissionCreateManyRoleInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type KnowledgeBasePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<KnowledgeBasePermissionCreateWithoutRoleInput, KnowledgeBasePermissionUncheckedCreateWithoutRoleInput> | KnowledgeBasePermissionCreateWithoutRoleInput[] | KnowledgeBasePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: KnowledgeBasePermissionCreateOrConnectWithoutRoleInput | KnowledgeBasePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: KnowledgeBasePermissionCreateManyRoleInputEnvelope
    connect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    createMany?: PermissionCreateManyRoleInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type KnowledgeBasePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<KnowledgeBasePermissionCreateWithoutRoleInput, KnowledgeBasePermissionUncheckedCreateWithoutRoleInput> | KnowledgeBasePermissionCreateWithoutRoleInput[] | KnowledgeBasePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: KnowledgeBasePermissionCreateOrConnectWithoutRoleInput | KnowledgeBasePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: KnowledgeBasePermissionCreateManyRoleInputEnvelope
    connect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type PermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRoleInput | PermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: PermissionCreateManyRoleInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRoleInput | PermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRoleInput | PermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type KnowledgeBasePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<KnowledgeBasePermissionCreateWithoutRoleInput, KnowledgeBasePermissionUncheckedCreateWithoutRoleInput> | KnowledgeBasePermissionCreateWithoutRoleInput[] | KnowledgeBasePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: KnowledgeBasePermissionCreateOrConnectWithoutRoleInput | KnowledgeBasePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: KnowledgeBasePermissionUpsertWithWhereUniqueWithoutRoleInput | KnowledgeBasePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: KnowledgeBasePermissionCreateManyRoleInputEnvelope
    set?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    disconnect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    delete?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    connect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    update?: KnowledgeBasePermissionUpdateWithWhereUniqueWithoutRoleInput | KnowledgeBasePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: KnowledgeBasePermissionUpdateManyWithWhereWithoutRoleInput | KnowledgeBasePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: KnowledgeBasePermissionScalarWhereInput | KnowledgeBasePermissionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput> | PermissionCreateWithoutRoleInput[] | PermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRoleInput | PermissionCreateOrConnectWithoutRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRoleInput | PermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: PermissionCreateManyRoleInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRoleInput | PermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRoleInput | PermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type KnowledgeBasePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<KnowledgeBasePermissionCreateWithoutRoleInput, KnowledgeBasePermissionUncheckedCreateWithoutRoleInput> | KnowledgeBasePermissionCreateWithoutRoleInput[] | KnowledgeBasePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: KnowledgeBasePermissionCreateOrConnectWithoutRoleInput | KnowledgeBasePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: KnowledgeBasePermissionUpsertWithWhereUniqueWithoutRoleInput | KnowledgeBasePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: KnowledgeBasePermissionCreateManyRoleInputEnvelope
    set?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    disconnect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    delete?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    connect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    update?: KnowledgeBasePermissionUpdateWithWhereUniqueWithoutRoleInput | KnowledgeBasePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: KnowledgeBasePermissionUpdateManyWithWhereWithoutRoleInput | KnowledgeBasePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: KnowledgeBasePermissionScalarWhereInput | KnowledgeBasePermissionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserCreateNestedOneWithoutCreatedProjectsInput = {
    create?: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCompletedProjectsInput = {
    create?: XOR<UserCreateWithoutCompletedProjectsInput, UserUncheckedCreateWithoutCompletedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompletedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectDocumentCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput> | ProjectDocumentCreateWithoutProjectInput[] | ProjectDocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutProjectInput | ProjectDocumentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectDocumentCreateManyProjectInputEnvelope
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
  }

  export type KnowledgeBaseCreateNestedManyWithoutProjectInput = {
    create?: XOR<KnowledgeBaseCreateWithoutProjectInput, KnowledgeBaseUncheckedCreateWithoutProjectInput> | KnowledgeBaseCreateWithoutProjectInput[] | KnowledgeBaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutProjectInput | KnowledgeBaseCreateOrConnectWithoutProjectInput[]
    createMany?: KnowledgeBaseCreateManyProjectInputEnvelope
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
  }

  export type ArtifactCreateNestedManyWithoutProjectInput = {
    create?: XOR<ArtifactCreateWithoutProjectInput, ArtifactUncheckedCreateWithoutProjectInput> | ArtifactCreateWithoutProjectInput[] | ArtifactUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutProjectInput | ArtifactCreateOrConnectWithoutProjectInput[]
    createMany?: ArtifactCreateManyProjectInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type WorkflowExecutionCreateNestedManyWithoutProjectInput = {
    create?: XOR<WorkflowExecutionCreateWithoutProjectInput, WorkflowExecutionUncheckedCreateWithoutProjectInput> | WorkflowExecutionCreateWithoutProjectInput[] | WorkflowExecutionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutProjectInput | WorkflowExecutionCreateOrConnectWithoutProjectInput[]
    createMany?: WorkflowExecutionCreateManyProjectInputEnvelope
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
  }

  export type SubmissionRecordCreateNestedManyWithoutProjectInput = {
    create?: XOR<SubmissionRecordCreateWithoutProjectInput, SubmissionRecordUncheckedCreateWithoutProjectInput> | SubmissionRecordCreateWithoutProjectInput[] | SubmissionRecordUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutProjectInput | SubmissionRecordCreateOrConnectWithoutProjectInput[]
    createMany?: SubmissionRecordCreateManyProjectInputEnvelope
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput> | ProjectDocumentCreateWithoutProjectInput[] | ProjectDocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutProjectInput | ProjectDocumentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectDocumentCreateManyProjectInputEnvelope
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
  }

  export type KnowledgeBaseUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<KnowledgeBaseCreateWithoutProjectInput, KnowledgeBaseUncheckedCreateWithoutProjectInput> | KnowledgeBaseCreateWithoutProjectInput[] | KnowledgeBaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutProjectInput | KnowledgeBaseCreateOrConnectWithoutProjectInput[]
    createMany?: KnowledgeBaseCreateManyProjectInputEnvelope
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
  }

  export type ArtifactUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ArtifactCreateWithoutProjectInput, ArtifactUncheckedCreateWithoutProjectInput> | ArtifactCreateWithoutProjectInput[] | ArtifactUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutProjectInput | ArtifactCreateOrConnectWithoutProjectInput[]
    createMany?: ArtifactCreateManyProjectInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type WorkflowExecutionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<WorkflowExecutionCreateWithoutProjectInput, WorkflowExecutionUncheckedCreateWithoutProjectInput> | WorkflowExecutionCreateWithoutProjectInput[] | WorkflowExecutionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutProjectInput | WorkflowExecutionCreateOrConnectWithoutProjectInput[]
    createMany?: WorkflowExecutionCreateManyProjectInputEnvelope
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
  }

  export type SubmissionRecordUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SubmissionRecordCreateWithoutProjectInput, SubmissionRecordUncheckedCreateWithoutProjectInput> | SubmissionRecordCreateWithoutProjectInput[] | SubmissionRecordUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutProjectInput | SubmissionRecordCreateOrConnectWithoutProjectInput[]
    createMany?: SubmissionRecordCreateManyProjectInputEnvelope
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCreatedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProjectsInput
    upsert?: UserUpsertWithoutCreatedProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedProjectsInput, UserUpdateWithoutCreatedProjectsInput>, UserUncheckedUpdateWithoutCreatedProjectsInput>
  }

  export type UserUpdateOneWithoutCompletedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutCompletedProjectsInput, UserUncheckedCreateWithoutCompletedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompletedProjectsInput
    upsert?: UserUpsertWithoutCompletedProjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompletedProjectsInput, UserUpdateWithoutCompletedProjectsInput>, UserUncheckedUpdateWithoutCompletedProjectsInput>
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectDocumentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput> | ProjectDocumentCreateWithoutProjectInput[] | ProjectDocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutProjectInput | ProjectDocumentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectDocumentUpsertWithWhereUniqueWithoutProjectInput | ProjectDocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectDocumentCreateManyProjectInputEnvelope
    set?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    disconnect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    delete?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    update?: ProjectDocumentUpdateWithWhereUniqueWithoutProjectInput | ProjectDocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectDocumentUpdateManyWithWhereWithoutProjectInput | ProjectDocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectDocumentScalarWhereInput | ProjectDocumentScalarWhereInput[]
  }

  export type KnowledgeBaseUpdateManyWithoutProjectNestedInput = {
    create?: XOR<KnowledgeBaseCreateWithoutProjectInput, KnowledgeBaseUncheckedCreateWithoutProjectInput> | KnowledgeBaseCreateWithoutProjectInput[] | KnowledgeBaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutProjectInput | KnowledgeBaseCreateOrConnectWithoutProjectInput[]
    upsert?: KnowledgeBaseUpsertWithWhereUniqueWithoutProjectInput | KnowledgeBaseUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: KnowledgeBaseCreateManyProjectInputEnvelope
    set?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    disconnect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    delete?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    update?: KnowledgeBaseUpdateWithWhereUniqueWithoutProjectInput | KnowledgeBaseUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: KnowledgeBaseUpdateManyWithWhereWithoutProjectInput | KnowledgeBaseUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
  }

  export type ArtifactUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ArtifactCreateWithoutProjectInput, ArtifactUncheckedCreateWithoutProjectInput> | ArtifactCreateWithoutProjectInput[] | ArtifactUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutProjectInput | ArtifactCreateOrConnectWithoutProjectInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutProjectInput | ArtifactUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ArtifactCreateManyProjectInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutProjectInput | ArtifactUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutProjectInput | ArtifactUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type WorkflowExecutionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutProjectInput, WorkflowExecutionUncheckedCreateWithoutProjectInput> | WorkflowExecutionCreateWithoutProjectInput[] | WorkflowExecutionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutProjectInput | WorkflowExecutionCreateOrConnectWithoutProjectInput[]
    upsert?: WorkflowExecutionUpsertWithWhereUniqueWithoutProjectInput | WorkflowExecutionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WorkflowExecutionCreateManyProjectInputEnvelope
    set?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    disconnect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    delete?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    update?: WorkflowExecutionUpdateWithWhereUniqueWithoutProjectInput | WorkflowExecutionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WorkflowExecutionUpdateManyWithWhereWithoutProjectInput | WorkflowExecutionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[]
  }

  export type SubmissionRecordUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SubmissionRecordCreateWithoutProjectInput, SubmissionRecordUncheckedCreateWithoutProjectInput> | SubmissionRecordCreateWithoutProjectInput[] | SubmissionRecordUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutProjectInput | SubmissionRecordCreateOrConnectWithoutProjectInput[]
    upsert?: SubmissionRecordUpsertWithWhereUniqueWithoutProjectInput | SubmissionRecordUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SubmissionRecordCreateManyProjectInputEnvelope
    set?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    disconnect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    delete?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    update?: SubmissionRecordUpdateWithWhereUniqueWithoutProjectInput | SubmissionRecordUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SubmissionRecordUpdateManyWithWhereWithoutProjectInput | SubmissionRecordUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SubmissionRecordScalarWhereInput | SubmissionRecordScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput> | ProjectDocumentCreateWithoutProjectInput[] | ProjectDocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutProjectInput | ProjectDocumentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectDocumentUpsertWithWhereUniqueWithoutProjectInput | ProjectDocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectDocumentCreateManyProjectInputEnvelope
    set?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    disconnect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    delete?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    update?: ProjectDocumentUpdateWithWhereUniqueWithoutProjectInput | ProjectDocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectDocumentUpdateManyWithWhereWithoutProjectInput | ProjectDocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectDocumentScalarWhereInput | ProjectDocumentScalarWhereInput[]
  }

  export type KnowledgeBaseUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<KnowledgeBaseCreateWithoutProjectInput, KnowledgeBaseUncheckedCreateWithoutProjectInput> | KnowledgeBaseCreateWithoutProjectInput[] | KnowledgeBaseUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutProjectInput | KnowledgeBaseCreateOrConnectWithoutProjectInput[]
    upsert?: KnowledgeBaseUpsertWithWhereUniqueWithoutProjectInput | KnowledgeBaseUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: KnowledgeBaseCreateManyProjectInputEnvelope
    set?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    disconnect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    delete?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    connect?: KnowledgeBaseWhereUniqueInput | KnowledgeBaseWhereUniqueInput[]
    update?: KnowledgeBaseUpdateWithWhereUniqueWithoutProjectInput | KnowledgeBaseUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: KnowledgeBaseUpdateManyWithWhereWithoutProjectInput | KnowledgeBaseUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
  }

  export type ArtifactUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ArtifactCreateWithoutProjectInput, ArtifactUncheckedCreateWithoutProjectInput> | ArtifactCreateWithoutProjectInput[] | ArtifactUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutProjectInput | ArtifactCreateOrConnectWithoutProjectInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutProjectInput | ArtifactUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ArtifactCreateManyProjectInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutProjectInput | ArtifactUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutProjectInput | ArtifactUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type WorkflowExecutionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutProjectInput, WorkflowExecutionUncheckedCreateWithoutProjectInput> | WorkflowExecutionCreateWithoutProjectInput[] | WorkflowExecutionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutProjectInput | WorkflowExecutionCreateOrConnectWithoutProjectInput[]
    upsert?: WorkflowExecutionUpsertWithWhereUniqueWithoutProjectInput | WorkflowExecutionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: WorkflowExecutionCreateManyProjectInputEnvelope
    set?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    disconnect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    delete?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    connect?: WorkflowExecutionWhereUniqueInput | WorkflowExecutionWhereUniqueInput[]
    update?: WorkflowExecutionUpdateWithWhereUniqueWithoutProjectInput | WorkflowExecutionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: WorkflowExecutionUpdateManyWithWhereWithoutProjectInput | WorkflowExecutionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[]
  }

  export type SubmissionRecordUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SubmissionRecordCreateWithoutProjectInput, SubmissionRecordUncheckedCreateWithoutProjectInput> | SubmissionRecordCreateWithoutProjectInput[] | SubmissionRecordUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutProjectInput | SubmissionRecordCreateOrConnectWithoutProjectInput[]
    upsert?: SubmissionRecordUpsertWithWhereUniqueWithoutProjectInput | SubmissionRecordUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SubmissionRecordCreateManyProjectInputEnvelope
    set?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    disconnect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    delete?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    update?: SubmissionRecordUpdateWithWhereUniqueWithoutProjectInput | SubmissionRecordUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SubmissionRecordUpdateManyWithWhereWithoutProjectInput | SubmissionRecordUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SubmissionRecordScalarWhereInput | SubmissionRecordScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedDocumentsInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type ProjectUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentsInput
    upsert?: ProjectUpsertWithoutDocumentsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDocumentsInput, ProjectUpdateWithoutDocumentsInput>, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedDocumentsInput
    upsert?: UserUpsertWithoutUploadedDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedDocumentsInput, UserUpdateWithoutUploadedDocumentsInput>, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMembershipsInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembershipsInput
    upsert?: UserUpsertWithoutProjectMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMembershipsInput, UserUpdateWithoutProjectMembershipsInput>, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type ProjectCreateNestedOneWithoutWorkflowExecutionsInput = {
    create?: XOR<ProjectCreateWithoutWorkflowExecutionsInput, ProjectUncheckedCreateWithoutWorkflowExecutionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkflowExecutionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type AgentTaskCreateNestedManyWithoutWorkflowExecutionInput = {
    create?: XOR<AgentTaskCreateWithoutWorkflowExecutionInput, AgentTaskUncheckedCreateWithoutWorkflowExecutionInput> | AgentTaskCreateWithoutWorkflowExecutionInput[] | AgentTaskUncheckedCreateWithoutWorkflowExecutionInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutWorkflowExecutionInput | AgentTaskCreateOrConnectWithoutWorkflowExecutionInput[]
    createMany?: AgentTaskCreateManyWorkflowExecutionInputEnvelope
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
  }

  export type AgentTaskUncheckedCreateNestedManyWithoutWorkflowExecutionInput = {
    create?: XOR<AgentTaskCreateWithoutWorkflowExecutionInput, AgentTaskUncheckedCreateWithoutWorkflowExecutionInput> | AgentTaskCreateWithoutWorkflowExecutionInput[] | AgentTaskUncheckedCreateWithoutWorkflowExecutionInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutWorkflowExecutionInput | AgentTaskCreateOrConnectWithoutWorkflowExecutionInput[]
    createMany?: AgentTaskCreateManyWorkflowExecutionInputEnvelope
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutWorkflowExecutionsNestedInput = {
    create?: XOR<ProjectCreateWithoutWorkflowExecutionsInput, ProjectUncheckedCreateWithoutWorkflowExecutionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkflowExecutionsInput
    upsert?: ProjectUpsertWithoutWorkflowExecutionsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutWorkflowExecutionsInput, ProjectUpdateWithoutWorkflowExecutionsInput>, ProjectUncheckedUpdateWithoutWorkflowExecutionsInput>
  }

  export type AgentTaskUpdateManyWithoutWorkflowExecutionNestedInput = {
    create?: XOR<AgentTaskCreateWithoutWorkflowExecutionInput, AgentTaskUncheckedCreateWithoutWorkflowExecutionInput> | AgentTaskCreateWithoutWorkflowExecutionInput[] | AgentTaskUncheckedCreateWithoutWorkflowExecutionInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutWorkflowExecutionInput | AgentTaskCreateOrConnectWithoutWorkflowExecutionInput[]
    upsert?: AgentTaskUpsertWithWhereUniqueWithoutWorkflowExecutionInput | AgentTaskUpsertWithWhereUniqueWithoutWorkflowExecutionInput[]
    createMany?: AgentTaskCreateManyWorkflowExecutionInputEnvelope
    set?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    disconnect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    delete?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    update?: AgentTaskUpdateWithWhereUniqueWithoutWorkflowExecutionInput | AgentTaskUpdateWithWhereUniqueWithoutWorkflowExecutionInput[]
    updateMany?: AgentTaskUpdateManyWithWhereWithoutWorkflowExecutionInput | AgentTaskUpdateManyWithWhereWithoutWorkflowExecutionInput[]
    deleteMany?: AgentTaskScalarWhereInput | AgentTaskScalarWhereInput[]
  }

  export type AgentTaskUncheckedUpdateManyWithoutWorkflowExecutionNestedInput = {
    create?: XOR<AgentTaskCreateWithoutWorkflowExecutionInput, AgentTaskUncheckedCreateWithoutWorkflowExecutionInput> | AgentTaskCreateWithoutWorkflowExecutionInput[] | AgentTaskUncheckedCreateWithoutWorkflowExecutionInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutWorkflowExecutionInput | AgentTaskCreateOrConnectWithoutWorkflowExecutionInput[]
    upsert?: AgentTaskUpsertWithWhereUniqueWithoutWorkflowExecutionInput | AgentTaskUpsertWithWhereUniqueWithoutWorkflowExecutionInput[]
    createMany?: AgentTaskCreateManyWorkflowExecutionInputEnvelope
    set?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    disconnect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    delete?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    update?: AgentTaskUpdateWithWhereUniqueWithoutWorkflowExecutionInput | AgentTaskUpdateWithWhereUniqueWithoutWorkflowExecutionInput[]
    updateMany?: AgentTaskUpdateManyWithWhereWithoutWorkflowExecutionInput | AgentTaskUpdateManyWithWhereWithoutWorkflowExecutionInput[]
    deleteMany?: AgentTaskScalarWhereInput | AgentTaskScalarWhereInput[]
  }

  export type WorkflowExecutionCreateNestedOneWithoutAgentTasksInput = {
    create?: XOR<WorkflowExecutionCreateWithoutAgentTasksInput, WorkflowExecutionUncheckedCreateWithoutAgentTasksInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutAgentTasksInput
    connect?: WorkflowExecutionWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkflowExecutionUpdateOneRequiredWithoutAgentTasksNestedInput = {
    create?: XOR<WorkflowExecutionCreateWithoutAgentTasksInput, WorkflowExecutionUncheckedCreateWithoutAgentTasksInput>
    connectOrCreate?: WorkflowExecutionCreateOrConnectWithoutAgentTasksInput
    upsert?: WorkflowExecutionUpsertWithoutAgentTasksInput
    connect?: WorkflowExecutionWhereUniqueInput
    update?: XOR<XOR<WorkflowExecutionUpdateToOneWithWhereWithoutAgentTasksInput, WorkflowExecutionUpdateWithoutAgentTasksInput>, WorkflowExecutionUncheckedUpdateWithoutAgentTasksInput>
  }

  export type ProjectCreateNestedOneWithoutArtifactsInput = {
    create?: XOR<ProjectCreateWithoutArtifactsInput, ProjectUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutArtifactsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedArtifactsInput = {
    create?: XOR<UserCreateWithoutCreatedArtifactsInput, UserUncheckedCreateWithoutCreatedArtifactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedArtifactsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedArtifactsInput = {
    create?: XOR<UserCreateWithoutApprovedArtifactsInput, UserUncheckedCreateWithoutApprovedArtifactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedArtifactsInput
    connect?: UserWhereUniqueInput
  }

  export type ArtifactVersionCreateNestedManyWithoutArtifactInput = {
    create?: XOR<ArtifactVersionCreateWithoutArtifactInput, ArtifactVersionUncheckedCreateWithoutArtifactInput> | ArtifactVersionCreateWithoutArtifactInput[] | ArtifactVersionUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: ArtifactVersionCreateOrConnectWithoutArtifactInput | ArtifactVersionCreateOrConnectWithoutArtifactInput[]
    createMany?: ArtifactVersionCreateManyArtifactInputEnvelope
    connect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
  }

  export type SubmissionRecordCreateNestedManyWithoutArtifactInput = {
    create?: XOR<SubmissionRecordCreateWithoutArtifactInput, SubmissionRecordUncheckedCreateWithoutArtifactInput> | SubmissionRecordCreateWithoutArtifactInput[] | SubmissionRecordUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutArtifactInput | SubmissionRecordCreateOrConnectWithoutArtifactInput[]
    createMany?: SubmissionRecordCreateManyArtifactInputEnvelope
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
  }

  export type ArtifactVersionUncheckedCreateNestedManyWithoutArtifactInput = {
    create?: XOR<ArtifactVersionCreateWithoutArtifactInput, ArtifactVersionUncheckedCreateWithoutArtifactInput> | ArtifactVersionCreateWithoutArtifactInput[] | ArtifactVersionUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: ArtifactVersionCreateOrConnectWithoutArtifactInput | ArtifactVersionCreateOrConnectWithoutArtifactInput[]
    createMany?: ArtifactVersionCreateManyArtifactInputEnvelope
    connect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
  }

  export type SubmissionRecordUncheckedCreateNestedManyWithoutArtifactInput = {
    create?: XOR<SubmissionRecordCreateWithoutArtifactInput, SubmissionRecordUncheckedCreateWithoutArtifactInput> | SubmissionRecordCreateWithoutArtifactInput[] | SubmissionRecordUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutArtifactInput | SubmissionRecordCreateOrConnectWithoutArtifactInput[]
    createMany?: SubmissionRecordCreateManyArtifactInputEnvelope
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutArtifactsNestedInput = {
    create?: XOR<ProjectCreateWithoutArtifactsInput, ProjectUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutArtifactsInput
    upsert?: ProjectUpsertWithoutArtifactsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutArtifactsInput, ProjectUpdateWithoutArtifactsInput>, ProjectUncheckedUpdateWithoutArtifactsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedArtifactsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedArtifactsInput, UserUncheckedCreateWithoutCreatedArtifactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedArtifactsInput
    upsert?: UserUpsertWithoutCreatedArtifactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedArtifactsInput, UserUpdateWithoutCreatedArtifactsInput>, UserUncheckedUpdateWithoutCreatedArtifactsInput>
  }

  export type UserUpdateOneWithoutApprovedArtifactsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedArtifactsInput, UserUncheckedCreateWithoutApprovedArtifactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedArtifactsInput
    upsert?: UserUpsertWithoutApprovedArtifactsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedArtifactsInput, UserUpdateWithoutApprovedArtifactsInput>, UserUncheckedUpdateWithoutApprovedArtifactsInput>
  }

  export type ArtifactVersionUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<ArtifactVersionCreateWithoutArtifactInput, ArtifactVersionUncheckedCreateWithoutArtifactInput> | ArtifactVersionCreateWithoutArtifactInput[] | ArtifactVersionUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: ArtifactVersionCreateOrConnectWithoutArtifactInput | ArtifactVersionCreateOrConnectWithoutArtifactInput[]
    upsert?: ArtifactVersionUpsertWithWhereUniqueWithoutArtifactInput | ArtifactVersionUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: ArtifactVersionCreateManyArtifactInputEnvelope
    set?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    disconnect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    delete?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    connect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    update?: ArtifactVersionUpdateWithWhereUniqueWithoutArtifactInput | ArtifactVersionUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: ArtifactVersionUpdateManyWithWhereWithoutArtifactInput | ArtifactVersionUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: ArtifactVersionScalarWhereInput | ArtifactVersionScalarWhereInput[]
  }

  export type SubmissionRecordUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<SubmissionRecordCreateWithoutArtifactInput, SubmissionRecordUncheckedCreateWithoutArtifactInput> | SubmissionRecordCreateWithoutArtifactInput[] | SubmissionRecordUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutArtifactInput | SubmissionRecordCreateOrConnectWithoutArtifactInput[]
    upsert?: SubmissionRecordUpsertWithWhereUniqueWithoutArtifactInput | SubmissionRecordUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: SubmissionRecordCreateManyArtifactInputEnvelope
    set?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    disconnect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    delete?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    update?: SubmissionRecordUpdateWithWhereUniqueWithoutArtifactInput | SubmissionRecordUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: SubmissionRecordUpdateManyWithWhereWithoutArtifactInput | SubmissionRecordUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: SubmissionRecordScalarWhereInput | SubmissionRecordScalarWhereInput[]
  }

  export type ArtifactVersionUncheckedUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<ArtifactVersionCreateWithoutArtifactInput, ArtifactVersionUncheckedCreateWithoutArtifactInput> | ArtifactVersionCreateWithoutArtifactInput[] | ArtifactVersionUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: ArtifactVersionCreateOrConnectWithoutArtifactInput | ArtifactVersionCreateOrConnectWithoutArtifactInput[]
    upsert?: ArtifactVersionUpsertWithWhereUniqueWithoutArtifactInput | ArtifactVersionUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: ArtifactVersionCreateManyArtifactInputEnvelope
    set?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    disconnect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    delete?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    connect?: ArtifactVersionWhereUniqueInput | ArtifactVersionWhereUniqueInput[]
    update?: ArtifactVersionUpdateWithWhereUniqueWithoutArtifactInput | ArtifactVersionUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: ArtifactVersionUpdateManyWithWhereWithoutArtifactInput | ArtifactVersionUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: ArtifactVersionScalarWhereInput | ArtifactVersionScalarWhereInput[]
  }

  export type SubmissionRecordUncheckedUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<SubmissionRecordCreateWithoutArtifactInput, SubmissionRecordUncheckedCreateWithoutArtifactInput> | SubmissionRecordCreateWithoutArtifactInput[] | SubmissionRecordUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: SubmissionRecordCreateOrConnectWithoutArtifactInput | SubmissionRecordCreateOrConnectWithoutArtifactInput[]
    upsert?: SubmissionRecordUpsertWithWhereUniqueWithoutArtifactInput | SubmissionRecordUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: SubmissionRecordCreateManyArtifactInputEnvelope
    set?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    disconnect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    delete?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    connect?: SubmissionRecordWhereUniqueInput | SubmissionRecordWhereUniqueInput[]
    update?: SubmissionRecordUpdateWithWhereUniqueWithoutArtifactInput | SubmissionRecordUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: SubmissionRecordUpdateManyWithWhereWithoutArtifactInput | SubmissionRecordUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: SubmissionRecordScalarWhereInput | SubmissionRecordScalarWhereInput[]
  }

  export type ArtifactCreateNestedOneWithoutVersionsInput = {
    create?: XOR<ArtifactCreateWithoutVersionsInput, ArtifactUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: ArtifactCreateOrConnectWithoutVersionsInput
    connect?: ArtifactWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedArtifactVersionsInput = {
    create?: XOR<UserCreateWithoutCreatedArtifactVersionsInput, UserUncheckedCreateWithoutCreatedArtifactVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedArtifactVersionsInput
    connect?: UserWhereUniqueInput
  }

  export type ArtifactUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<ArtifactCreateWithoutVersionsInput, ArtifactUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: ArtifactCreateOrConnectWithoutVersionsInput
    upsert?: ArtifactUpsertWithoutVersionsInput
    connect?: ArtifactWhereUniqueInput
    update?: XOR<XOR<ArtifactUpdateToOneWithWhereWithoutVersionsInput, ArtifactUpdateWithoutVersionsInput>, ArtifactUncheckedUpdateWithoutVersionsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedArtifactVersionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedArtifactVersionsInput, UserUncheckedCreateWithoutCreatedArtifactVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedArtifactVersionsInput
    upsert?: UserUpsertWithoutCreatedArtifactVersionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedArtifactVersionsInput, UserUpdateWithoutCreatedArtifactVersionsInput>, UserUncheckedUpdateWithoutCreatedArtifactVersionsInput>
  }

  export type ProjectCreateNestedOneWithoutKnowledgeBasesInput = {
    create?: XOR<ProjectCreateWithoutKnowledgeBasesInput, ProjectUncheckedCreateWithoutKnowledgeBasesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutKnowledgeBasesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedKnowledgeBasesInput = {
    create?: XOR<UserCreateWithoutCreatedKnowledgeBasesInput, UserUncheckedCreateWithoutCreatedKnowledgeBasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedKnowledgeBasesInput
    connect?: UserWhereUniqueInput
  }

  export type KnowledgeBaseDocumentCreateNestedManyWithoutKnowledgeBaseInput = {
    create?: XOR<KnowledgeBaseDocumentCreateWithoutKnowledgeBaseInput, KnowledgeBaseDocumentUncheckedCreateWithoutKnowledgeBaseInput> | KnowledgeBaseDocumentCreateWithoutKnowledgeBaseInput[] | KnowledgeBaseDocumentUncheckedCreateWithoutKnowledgeBaseInput[]
    connectOrCreate?: KnowledgeBaseDocumentCreateOrConnectWithoutKnowledgeBaseInput | KnowledgeBaseDocumentCreateOrConnectWithoutKnowledgeBaseInput[]
    createMany?: KnowledgeBaseDocumentCreateManyKnowledgeBaseInputEnvelope
    connect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
  }

  export type KnowledgeBasePermissionCreateNestedManyWithoutKnowledgeBaseInput = {
    create?: XOR<KnowledgeBasePermissionCreateWithoutKnowledgeBaseInput, KnowledgeBasePermissionUncheckedCreateWithoutKnowledgeBaseInput> | KnowledgeBasePermissionCreateWithoutKnowledgeBaseInput[] | KnowledgeBasePermissionUncheckedCreateWithoutKnowledgeBaseInput[]
    connectOrCreate?: KnowledgeBasePermissionCreateOrConnectWithoutKnowledgeBaseInput | KnowledgeBasePermissionCreateOrConnectWithoutKnowledgeBaseInput[]
    createMany?: KnowledgeBasePermissionCreateManyKnowledgeBaseInputEnvelope
    connect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
  }

  export type KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutKnowledgeBaseInput = {
    create?: XOR<KnowledgeBaseDocumentCreateWithoutKnowledgeBaseInput, KnowledgeBaseDocumentUncheckedCreateWithoutKnowledgeBaseInput> | KnowledgeBaseDocumentCreateWithoutKnowledgeBaseInput[] | KnowledgeBaseDocumentUncheckedCreateWithoutKnowledgeBaseInput[]
    connectOrCreate?: KnowledgeBaseDocumentCreateOrConnectWithoutKnowledgeBaseInput | KnowledgeBaseDocumentCreateOrConnectWithoutKnowledgeBaseInput[]
    createMany?: KnowledgeBaseDocumentCreateManyKnowledgeBaseInputEnvelope
    connect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
  }

  export type KnowledgeBasePermissionUncheckedCreateNestedManyWithoutKnowledgeBaseInput = {
    create?: XOR<KnowledgeBasePermissionCreateWithoutKnowledgeBaseInput, KnowledgeBasePermissionUncheckedCreateWithoutKnowledgeBaseInput> | KnowledgeBasePermissionCreateWithoutKnowledgeBaseInput[] | KnowledgeBasePermissionUncheckedCreateWithoutKnowledgeBaseInput[]
    connectOrCreate?: KnowledgeBasePermissionCreateOrConnectWithoutKnowledgeBaseInput | KnowledgeBasePermissionCreateOrConnectWithoutKnowledgeBaseInput[]
    createMany?: KnowledgeBasePermissionCreateManyKnowledgeBaseInputEnvelope
    connect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
  }

  export type ProjectUpdateOneWithoutKnowledgeBasesNestedInput = {
    create?: XOR<ProjectCreateWithoutKnowledgeBasesInput, ProjectUncheckedCreateWithoutKnowledgeBasesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutKnowledgeBasesInput
    upsert?: ProjectUpsertWithoutKnowledgeBasesInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutKnowledgeBasesInput, ProjectUpdateWithoutKnowledgeBasesInput>, ProjectUncheckedUpdateWithoutKnowledgeBasesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedKnowledgeBasesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedKnowledgeBasesInput, UserUncheckedCreateWithoutCreatedKnowledgeBasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedKnowledgeBasesInput
    upsert?: UserUpsertWithoutCreatedKnowledgeBasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedKnowledgeBasesInput, UserUpdateWithoutCreatedKnowledgeBasesInput>, UserUncheckedUpdateWithoutCreatedKnowledgeBasesInput>
  }

  export type KnowledgeBaseDocumentUpdateManyWithoutKnowledgeBaseNestedInput = {
    create?: XOR<KnowledgeBaseDocumentCreateWithoutKnowledgeBaseInput, KnowledgeBaseDocumentUncheckedCreateWithoutKnowledgeBaseInput> | KnowledgeBaseDocumentCreateWithoutKnowledgeBaseInput[] | KnowledgeBaseDocumentUncheckedCreateWithoutKnowledgeBaseInput[]
    connectOrCreate?: KnowledgeBaseDocumentCreateOrConnectWithoutKnowledgeBaseInput | KnowledgeBaseDocumentCreateOrConnectWithoutKnowledgeBaseInput[]
    upsert?: KnowledgeBaseDocumentUpsertWithWhereUniqueWithoutKnowledgeBaseInput | KnowledgeBaseDocumentUpsertWithWhereUniqueWithoutKnowledgeBaseInput[]
    createMany?: KnowledgeBaseDocumentCreateManyKnowledgeBaseInputEnvelope
    set?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    disconnect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    delete?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    connect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    update?: KnowledgeBaseDocumentUpdateWithWhereUniqueWithoutKnowledgeBaseInput | KnowledgeBaseDocumentUpdateWithWhereUniqueWithoutKnowledgeBaseInput[]
    updateMany?: KnowledgeBaseDocumentUpdateManyWithWhereWithoutKnowledgeBaseInput | KnowledgeBaseDocumentUpdateManyWithWhereWithoutKnowledgeBaseInput[]
    deleteMany?: KnowledgeBaseDocumentScalarWhereInput | KnowledgeBaseDocumentScalarWhereInput[]
  }

  export type KnowledgeBasePermissionUpdateManyWithoutKnowledgeBaseNestedInput = {
    create?: XOR<KnowledgeBasePermissionCreateWithoutKnowledgeBaseInput, KnowledgeBasePermissionUncheckedCreateWithoutKnowledgeBaseInput> | KnowledgeBasePermissionCreateWithoutKnowledgeBaseInput[] | KnowledgeBasePermissionUncheckedCreateWithoutKnowledgeBaseInput[]
    connectOrCreate?: KnowledgeBasePermissionCreateOrConnectWithoutKnowledgeBaseInput | KnowledgeBasePermissionCreateOrConnectWithoutKnowledgeBaseInput[]
    upsert?: KnowledgeBasePermissionUpsertWithWhereUniqueWithoutKnowledgeBaseInput | KnowledgeBasePermissionUpsertWithWhereUniqueWithoutKnowledgeBaseInput[]
    createMany?: KnowledgeBasePermissionCreateManyKnowledgeBaseInputEnvelope
    set?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    disconnect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    delete?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    connect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    update?: KnowledgeBasePermissionUpdateWithWhereUniqueWithoutKnowledgeBaseInput | KnowledgeBasePermissionUpdateWithWhereUniqueWithoutKnowledgeBaseInput[]
    updateMany?: KnowledgeBasePermissionUpdateManyWithWhereWithoutKnowledgeBaseInput | KnowledgeBasePermissionUpdateManyWithWhereWithoutKnowledgeBaseInput[]
    deleteMany?: KnowledgeBasePermissionScalarWhereInput | KnowledgeBasePermissionScalarWhereInput[]
  }

  export type KnowledgeBaseDocumentUncheckedUpdateManyWithoutKnowledgeBaseNestedInput = {
    create?: XOR<KnowledgeBaseDocumentCreateWithoutKnowledgeBaseInput, KnowledgeBaseDocumentUncheckedCreateWithoutKnowledgeBaseInput> | KnowledgeBaseDocumentCreateWithoutKnowledgeBaseInput[] | KnowledgeBaseDocumentUncheckedCreateWithoutKnowledgeBaseInput[]
    connectOrCreate?: KnowledgeBaseDocumentCreateOrConnectWithoutKnowledgeBaseInput | KnowledgeBaseDocumentCreateOrConnectWithoutKnowledgeBaseInput[]
    upsert?: KnowledgeBaseDocumentUpsertWithWhereUniqueWithoutKnowledgeBaseInput | KnowledgeBaseDocumentUpsertWithWhereUniqueWithoutKnowledgeBaseInput[]
    createMany?: KnowledgeBaseDocumentCreateManyKnowledgeBaseInputEnvelope
    set?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    disconnect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    delete?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    connect?: KnowledgeBaseDocumentWhereUniqueInput | KnowledgeBaseDocumentWhereUniqueInput[]
    update?: KnowledgeBaseDocumentUpdateWithWhereUniqueWithoutKnowledgeBaseInput | KnowledgeBaseDocumentUpdateWithWhereUniqueWithoutKnowledgeBaseInput[]
    updateMany?: KnowledgeBaseDocumentUpdateManyWithWhereWithoutKnowledgeBaseInput | KnowledgeBaseDocumentUpdateManyWithWhereWithoutKnowledgeBaseInput[]
    deleteMany?: KnowledgeBaseDocumentScalarWhereInput | KnowledgeBaseDocumentScalarWhereInput[]
  }

  export type KnowledgeBasePermissionUncheckedUpdateManyWithoutKnowledgeBaseNestedInput = {
    create?: XOR<KnowledgeBasePermissionCreateWithoutKnowledgeBaseInput, KnowledgeBasePermissionUncheckedCreateWithoutKnowledgeBaseInput> | KnowledgeBasePermissionCreateWithoutKnowledgeBaseInput[] | KnowledgeBasePermissionUncheckedCreateWithoutKnowledgeBaseInput[]
    connectOrCreate?: KnowledgeBasePermissionCreateOrConnectWithoutKnowledgeBaseInput | KnowledgeBasePermissionCreateOrConnectWithoutKnowledgeBaseInput[]
    upsert?: KnowledgeBasePermissionUpsertWithWhereUniqueWithoutKnowledgeBaseInput | KnowledgeBasePermissionUpsertWithWhereUniqueWithoutKnowledgeBaseInput[]
    createMany?: KnowledgeBasePermissionCreateManyKnowledgeBaseInputEnvelope
    set?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    disconnect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    delete?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    connect?: KnowledgeBasePermissionWhereUniqueInput | KnowledgeBasePermissionWhereUniqueInput[]
    update?: KnowledgeBasePermissionUpdateWithWhereUniqueWithoutKnowledgeBaseInput | KnowledgeBasePermissionUpdateWithWhereUniqueWithoutKnowledgeBaseInput[]
    updateMany?: KnowledgeBasePermissionUpdateManyWithWhereWithoutKnowledgeBaseInput | KnowledgeBasePermissionUpdateManyWithWhereWithoutKnowledgeBaseInput[]
    deleteMany?: KnowledgeBasePermissionScalarWhereInput | KnowledgeBasePermissionScalarWhereInput[]
  }

  export type KnowledgeBaseCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<KnowledgeBaseCreateWithoutDocumentsInput, KnowledgeBaseUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutDocumentsInput
    connect?: KnowledgeBaseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedKBDocumentsInput = {
    create?: XOR<UserCreateWithoutUploadedKBDocumentsInput, UserUncheckedCreateWithoutUploadedKBDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedKBDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type KnowledgeBaseUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<KnowledgeBaseCreateWithoutDocumentsInput, KnowledgeBaseUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutDocumentsInput
    upsert?: KnowledgeBaseUpsertWithoutDocumentsInput
    connect?: KnowledgeBaseWhereUniqueInput
    update?: XOR<XOR<KnowledgeBaseUpdateToOneWithWhereWithoutDocumentsInput, KnowledgeBaseUpdateWithoutDocumentsInput>, KnowledgeBaseUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedKBDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedKBDocumentsInput, UserUncheckedCreateWithoutUploadedKBDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedKBDocumentsInput
    upsert?: UserUpsertWithoutUploadedKBDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedKBDocumentsInput, UserUpdateWithoutUploadedKBDocumentsInput>, UserUncheckedUpdateWithoutUploadedKBDocumentsInput>
  }

  export type KnowledgeBaseCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<KnowledgeBaseCreateWithoutPermissionsInput, KnowledgeBaseUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutPermissionsInput
    connect?: KnowledgeBaseWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutKbPermissionsInput = {
    create?: XOR<RoleCreateWithoutKbPermissionsInput, RoleUncheckedCreateWithoutKbPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutKbPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type KnowledgeBaseUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<KnowledgeBaseCreateWithoutPermissionsInput, KnowledgeBaseUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: KnowledgeBaseCreateOrConnectWithoutPermissionsInput
    upsert?: KnowledgeBaseUpsertWithoutPermissionsInput
    connect?: KnowledgeBaseWhereUniqueInput
    update?: XOR<XOR<KnowledgeBaseUpdateToOneWithWhereWithoutPermissionsInput, KnowledgeBaseUpdateWithoutPermissionsInput>, KnowledgeBaseUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateOneWithoutKbPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutKbPermissionsInput, RoleUncheckedCreateWithoutKbPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutKbPermissionsInput
    upsert?: RoleUpsertWithoutKbPermissionsInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutKbPermissionsInput, RoleUpdateWithoutKbPermissionsInput>, RoleUncheckedUpdateWithoutKbPermissionsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutCreatedIntegrationsInput = {
    create?: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedIntegrationsInput
    connect?: UserWhereUniqueInput
  }

  export type IntegrationLogCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<IntegrationLogCreateWithoutIntegrationInput, IntegrationLogUncheckedCreateWithoutIntegrationInput> | IntegrationLogCreateWithoutIntegrationInput[] | IntegrationLogUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: IntegrationLogCreateOrConnectWithoutIntegrationInput | IntegrationLogCreateOrConnectWithoutIntegrationInput[]
    createMany?: IntegrationLogCreateManyIntegrationInputEnvelope
    connect?: IntegrationLogWhereUniqueInput | IntegrationLogWhereUniqueInput[]
  }

  export type IntegrationLogUncheckedCreateNestedManyWithoutIntegrationInput = {
    create?: XOR<IntegrationLogCreateWithoutIntegrationInput, IntegrationLogUncheckedCreateWithoutIntegrationInput> | IntegrationLogCreateWithoutIntegrationInput[] | IntegrationLogUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: IntegrationLogCreateOrConnectWithoutIntegrationInput | IntegrationLogCreateOrConnectWithoutIntegrationInput[]
    createMany?: IntegrationLogCreateManyIntegrationInputEnvelope
    connect?: IntegrationLogWhereUniqueInput | IntegrationLogWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedIntegrationsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedIntegrationsInput
    upsert?: UserUpsertWithoutCreatedIntegrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedIntegrationsInput, UserUpdateWithoutCreatedIntegrationsInput>, UserUncheckedUpdateWithoutCreatedIntegrationsInput>
  }

  export type IntegrationLogUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<IntegrationLogCreateWithoutIntegrationInput, IntegrationLogUncheckedCreateWithoutIntegrationInput> | IntegrationLogCreateWithoutIntegrationInput[] | IntegrationLogUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: IntegrationLogCreateOrConnectWithoutIntegrationInput | IntegrationLogCreateOrConnectWithoutIntegrationInput[]
    upsert?: IntegrationLogUpsertWithWhereUniqueWithoutIntegrationInput | IntegrationLogUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: IntegrationLogCreateManyIntegrationInputEnvelope
    set?: IntegrationLogWhereUniqueInput | IntegrationLogWhereUniqueInput[]
    disconnect?: IntegrationLogWhereUniqueInput | IntegrationLogWhereUniqueInput[]
    delete?: IntegrationLogWhereUniqueInput | IntegrationLogWhereUniqueInput[]
    connect?: IntegrationLogWhereUniqueInput | IntegrationLogWhereUniqueInput[]
    update?: IntegrationLogUpdateWithWhereUniqueWithoutIntegrationInput | IntegrationLogUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: IntegrationLogUpdateManyWithWhereWithoutIntegrationInput | IntegrationLogUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: IntegrationLogScalarWhereInput | IntegrationLogScalarWhereInput[]
  }

  export type IntegrationLogUncheckedUpdateManyWithoutIntegrationNestedInput = {
    create?: XOR<IntegrationLogCreateWithoutIntegrationInput, IntegrationLogUncheckedCreateWithoutIntegrationInput> | IntegrationLogCreateWithoutIntegrationInput[] | IntegrationLogUncheckedCreateWithoutIntegrationInput[]
    connectOrCreate?: IntegrationLogCreateOrConnectWithoutIntegrationInput | IntegrationLogCreateOrConnectWithoutIntegrationInput[]
    upsert?: IntegrationLogUpsertWithWhereUniqueWithoutIntegrationInput | IntegrationLogUpsertWithWhereUniqueWithoutIntegrationInput[]
    createMany?: IntegrationLogCreateManyIntegrationInputEnvelope
    set?: IntegrationLogWhereUniqueInput | IntegrationLogWhereUniqueInput[]
    disconnect?: IntegrationLogWhereUniqueInput | IntegrationLogWhereUniqueInput[]
    delete?: IntegrationLogWhereUniqueInput | IntegrationLogWhereUniqueInput[]
    connect?: IntegrationLogWhereUniqueInput | IntegrationLogWhereUniqueInput[]
    update?: IntegrationLogUpdateWithWhereUniqueWithoutIntegrationInput | IntegrationLogUpdateWithWhereUniqueWithoutIntegrationInput[]
    updateMany?: IntegrationLogUpdateManyWithWhereWithoutIntegrationInput | IntegrationLogUpdateManyWithWhereWithoutIntegrationInput[]
    deleteMany?: IntegrationLogScalarWhereInput | IntegrationLogScalarWhereInput[]
  }

  export type IntegrationCreateNestedOneWithoutLogsInput = {
    create?: XOR<IntegrationCreateWithoutLogsInput, IntegrationUncheckedCreateWithoutLogsInput>
    connectOrCreate?: IntegrationCreateOrConnectWithoutLogsInput
    connect?: IntegrationWhereUniqueInput
  }

  export type IntegrationUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<IntegrationCreateWithoutLogsInput, IntegrationUncheckedCreateWithoutLogsInput>
    connectOrCreate?: IntegrationCreateOrConnectWithoutLogsInput
    upsert?: IntegrationUpsertWithoutLogsInput
    connect?: IntegrationWhereUniqueInput
    update?: XOR<XOR<IntegrationUpdateToOneWithWhereWithoutLogsInput, IntegrationUpdateWithoutLogsInput>, IntegrationUncheckedUpdateWithoutLogsInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProjectCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<ProjectCreateWithoutSubmissionsInput, ProjectUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSubmissionsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ArtifactCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<ArtifactCreateWithoutSubmissionsInput, ArtifactUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: ArtifactCreateOrConnectWithoutSubmissionsInput
    connect?: ArtifactWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<ProjectCreateWithoutSubmissionsInput, ProjectUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSubmissionsInput
    upsert?: ProjectUpsertWithoutSubmissionsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSubmissionsInput, ProjectUpdateWithoutSubmissionsInput>, ProjectUncheckedUpdateWithoutSubmissionsInput>
  }

  export type ArtifactUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<ArtifactCreateWithoutSubmissionsInput, ArtifactUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: ArtifactCreateOrConnectWithoutSubmissionsInput
    upsert?: ArtifactUpsertWithoutSubmissionsInput
    connect?: ArtifactWhereUniqueInput
    update?: XOR<XOR<ArtifactUpdateToOneWithWhereWithoutSubmissionsInput, ArtifactUpdateWithoutSubmissionsInput>, ArtifactUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput
    upsert?: UserUpsertWithoutSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubmissionsInput, UserUpdateWithoutSubmissionsInput>, UserUncheckedUpdateWithoutSubmissionsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    assignedAt?: Date | string
    assignedBy?: string | null
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    roleId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutUserInput = {
    id?: string
    addedById: string
    joinedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    addedById: string
    joinedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberCreateManyUserInputEnvelope = {
    data: ProjectMemberCreateManyUserInput | ProjectMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completer?: UserCreateNestedOneWithoutCompletedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectCreateManyCreatorInputEnvelope = {
    data: ProjectCreateManyCreatorInput | ProjectCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutCompleterInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator: UserCreateNestedOneWithoutCreatedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCompleterInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCompleterInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCompleterInput, ProjectUncheckedCreateWithoutCompleterInput>
  }

  export type ProjectCreateManyCompleterInputEnvelope = {
    data: ProjectCreateManyCompleterInput | ProjectCreateManyCompleterInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resourceType: string
    resourceId: string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resourceType: string
    resourceId: string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectDocumentCreateWithoutUploaderInput = {
    id?: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    rawFileLocation: string
    processedFileLocation?: string | null
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutDocumentsInput
  }

  export type ProjectDocumentUncheckedCreateWithoutUploaderInput = {
    id?: string
    projectId: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    rawFileLocation: string
    processedFileLocation?: string | null
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectDocumentCreateOrConnectWithoutUploaderInput = {
    where: ProjectDocumentWhereUniqueInput
    create: XOR<ProjectDocumentCreateWithoutUploaderInput, ProjectDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type ProjectDocumentCreateManyUploaderInputEnvelope = {
    data: ProjectDocumentCreateManyUploaderInput | ProjectDocumentCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeBaseCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    documentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
    project?: ProjectCreateNestedOneWithoutKnowledgeBasesInput
    documents?: KnowledgeBaseDocumentCreateNestedManyWithoutKnowledgeBaseInput
    permissions?: KnowledgeBasePermissionCreateNestedManyWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    projectId?: string | null
    documentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
    documents?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutKnowledgeBaseInput
    permissions?: KnowledgeBasePermissionUncheckedCreateNestedManyWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseCreateOrConnectWithoutCreatorInput = {
    where: KnowledgeBaseWhereUniqueInput
    create: XOR<KnowledgeBaseCreateWithoutCreatorInput, KnowledgeBaseUncheckedCreateWithoutCreatorInput>
  }

  export type KnowledgeBaseCreateManyCreatorInputEnvelope = {
    data: KnowledgeBaseCreateManyCreatorInput | KnowledgeBaseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ArtifactCreateWithoutCreatorInput = {
    id?: string
    name: string
    type: string
    category: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutArtifactsInput
    approver?: UserCreateNestedOneWithoutApprovedArtifactsInput
    versions?: ArtifactVersionCreateNestedManyWithoutArtifactInput
    submissions?: SubmissionRecordCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactUncheckedCreateWithoutCreatorInput = {
    id?: string
    projectId: string
    name: string
    type: string
    category: string
    status?: string
    approvedBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
    versions?: ArtifactVersionUncheckedCreateNestedManyWithoutArtifactInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactCreateOrConnectWithoutCreatorInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutCreatorInput, ArtifactUncheckedCreateWithoutCreatorInput>
  }

  export type ArtifactCreateManyCreatorInputEnvelope = {
    data: ArtifactCreateManyCreatorInput | ArtifactCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ArtifactCreateWithoutApproverInput = {
    id?: string
    name: string
    type: string
    category: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutArtifactsInput
    creator: UserCreateNestedOneWithoutCreatedArtifactsInput
    versions?: ArtifactVersionCreateNestedManyWithoutArtifactInput
    submissions?: SubmissionRecordCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactUncheckedCreateWithoutApproverInput = {
    id?: string
    projectId: string
    name: string
    type: string
    category: string
    status?: string
    createdBy: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    versions?: ArtifactVersionUncheckedCreateNestedManyWithoutArtifactInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactCreateOrConnectWithoutApproverInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutApproverInput, ArtifactUncheckedCreateWithoutApproverInput>
  }

  export type ArtifactCreateManyApproverInputEnvelope = {
    data: ArtifactCreateManyApproverInput | ArtifactCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionRecordCreateWithoutUserInput = {
    id?: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutSubmissionsInput
    artifact: ArtifactCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionRecordUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    artifactId: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordCreateOrConnectWithoutUserInput = {
    where: SubmissionRecordWhereUniqueInput
    create: XOR<SubmissionRecordCreateWithoutUserInput, SubmissionRecordUncheckedCreateWithoutUserInput>
  }

  export type SubmissionRecordCreateManyUserInputEnvelope = {
    data: SubmissionRecordCreateManyUserInput | SubmissionRecordCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationCreateWithoutCreatorInput = {
    id?: string
    type: string
    name: string
    configuration: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: IntegrationLogCreateNestedManyWithoutIntegrationInput
  }

  export type IntegrationUncheckedCreateWithoutCreatorInput = {
    id?: string
    type: string
    name: string
    configuration: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: IntegrationLogUncheckedCreateNestedManyWithoutIntegrationInput
  }

  export type IntegrationCreateOrConnectWithoutCreatorInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput>
  }

  export type IntegrationCreateManyCreatorInputEnvelope = {
    data: IntegrationCreateManyCreatorInput | IntegrationCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeBaseDocumentCreateWithoutUploaderInput = {
    id?: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    s3Bucket: string
    s3Key: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: string | null
    knowledgeBase: KnowledgeBaseCreateNestedOneWithoutDocumentsInput
  }

  export type KnowledgeBaseDocumentUncheckedCreateWithoutUploaderInput = {
    id?: string
    knowledgeBaseId: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    s3Bucket: string
    s3Key: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: string | null
  }

  export type KnowledgeBaseDocumentCreateOrConnectWithoutUploaderInput = {
    where: KnowledgeBaseDocumentWhereUniqueInput
    create: XOR<KnowledgeBaseDocumentCreateWithoutUploaderInput, KnowledgeBaseDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type KnowledgeBaseDocumentCreateManyUploaderInputEnvelope = {
    data: KnowledgeBaseDocumentCreateManyUploaderInput | KnowledgeBaseDocumentCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type ArtifactVersionCreateWithoutCreatorInput = {
    id?: string
    versionNumber: number
    content: JsonNullValueInput | InputJsonValue
    location?: string | null
    createdAt?: Date | string
    artifact: ArtifactCreateNestedOneWithoutVersionsInput
  }

  export type ArtifactVersionUncheckedCreateWithoutCreatorInput = {
    id?: string
    artifactId: string
    versionNumber: number
    content: JsonNullValueInput | InputJsonValue
    location?: string | null
    createdAt?: Date | string
  }

  export type ArtifactVersionCreateOrConnectWithoutCreatorInput = {
    where: ArtifactVersionWhereUniqueInput
    create: XOR<ArtifactVersionCreateWithoutCreatorInput, ArtifactVersionUncheckedCreateWithoutCreatorInput>
  }

  export type ArtifactVersionCreateManyCreatorInputEnvelope = {
    data: ArtifactVersionCreateManyCreatorInput | ArtifactVersionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: UuidFilter<"UserRole"> | string
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    assignedBy?: UuidNullableFilter<"UserRole"> | string | null
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: UuidFilter<"ProjectMember"> | string
    projectId?: UuidFilter<"ProjectMember"> | string
    userId?: UuidFilter<"ProjectMember"> | string
    addedById?: UuidFilter<"ProjectMember"> | string
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCreatorInput, ProjectUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCreatorInput, ProjectUncheckedUpdateWithoutCreatorInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCreatorInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: UuidFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    status?: StringFilter<"Project"> | string
    value?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    deadline?: DateTimeNullableFilter<"Project"> | Date | string | null
    progressPercentage?: IntFilter<"Project"> | number
    createdBy?: UuidFilter<"Project"> | string
    completedBy?: UuidNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    completedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    metadata?: JsonNullableFilter<"Project">
  }

  export type ProjectUpsertWithWhereUniqueWithoutCompleterInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCompleterInput, ProjectUncheckedUpdateWithoutCompleterInput>
    create: XOR<ProjectCreateWithoutCompleterInput, ProjectUncheckedCreateWithoutCompleterInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCompleterInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCompleterInput, ProjectUncheckedUpdateWithoutCompleterInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCompleterInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCompleterInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: UuidFilter<"Notification"> | string
    userId?: UuidFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: UuidFilter<"AuditLog"> | string
    userId?: UuidFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resourceType?: StringFilter<"AuditLog"> | string
    resourceId?: UuidFilter<"AuditLog"> | string
    previousState?: JsonNullableFilter<"AuditLog">
    newState?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type ProjectDocumentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: ProjectDocumentWhereUniqueInput
    update: XOR<ProjectDocumentUpdateWithoutUploaderInput, ProjectDocumentUncheckedUpdateWithoutUploaderInput>
    create: XOR<ProjectDocumentCreateWithoutUploaderInput, ProjectDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type ProjectDocumentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: ProjectDocumentWhereUniqueInput
    data: XOR<ProjectDocumentUpdateWithoutUploaderInput, ProjectDocumentUncheckedUpdateWithoutUploaderInput>
  }

  export type ProjectDocumentUpdateManyWithWhereWithoutUploaderInput = {
    where: ProjectDocumentScalarWhereInput
    data: XOR<ProjectDocumentUpdateManyMutationInput, ProjectDocumentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type ProjectDocumentScalarWhereInput = {
    AND?: ProjectDocumentScalarWhereInput | ProjectDocumentScalarWhereInput[]
    OR?: ProjectDocumentScalarWhereInput[]
    NOT?: ProjectDocumentScalarWhereInput | ProjectDocumentScalarWhereInput[]
    id?: UuidFilter<"ProjectDocument"> | string
    projectId?: UuidFilter<"ProjectDocument"> | string
    fileName?: StringFilter<"ProjectDocument"> | string
    filePath?: StringFilter<"ProjectDocument"> | string
    fileType?: StringFilter<"ProjectDocument"> | string
    fileSize?: BigIntFilter<"ProjectDocument"> | bigint | number
    rawFileLocation?: StringFilter<"ProjectDocument"> | string
    processedFileLocation?: StringNullableFilter<"ProjectDocument"> | string | null
    uploadedBy?: UuidFilter<"ProjectDocument"> | string
    uploadedAt?: DateTimeFilter<"ProjectDocument"> | Date | string
    metadata?: JsonNullableFilter<"ProjectDocument">
  }

  export type KnowledgeBaseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: KnowledgeBaseWhereUniqueInput
    update: XOR<KnowledgeBaseUpdateWithoutCreatorInput, KnowledgeBaseUncheckedUpdateWithoutCreatorInput>
    create: XOR<KnowledgeBaseCreateWithoutCreatorInput, KnowledgeBaseUncheckedCreateWithoutCreatorInput>
  }

  export type KnowledgeBaseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: KnowledgeBaseWhereUniqueInput
    data: XOR<KnowledgeBaseUpdateWithoutCreatorInput, KnowledgeBaseUncheckedUpdateWithoutCreatorInput>
  }

  export type KnowledgeBaseUpdateManyWithWhereWithoutCreatorInput = {
    where: KnowledgeBaseScalarWhereInput
    data: XOR<KnowledgeBaseUpdateManyMutationInput, KnowledgeBaseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type KnowledgeBaseScalarWhereInput = {
    AND?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
    OR?: KnowledgeBaseScalarWhereInput[]
    NOT?: KnowledgeBaseScalarWhereInput | KnowledgeBaseScalarWhereInput[]
    id?: UuidFilter<"KnowledgeBase"> | string
    name?: StringFilter<"KnowledgeBase"> | string
    description?: StringNullableFilter<"KnowledgeBase"> | string | null
    scope?: StringFilter<"KnowledgeBase"> | string
    projectId?: UuidNullableFilter<"KnowledgeBase"> | string | null
    documentCount?: IntFilter<"KnowledgeBase"> | number
    createdBy?: UuidFilter<"KnowledgeBase"> | string
    createdAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBase"> | Date | string
    vectorStoreId?: StringNullableFilter<"KnowledgeBase"> | string | null
  }

  export type ArtifactUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ArtifactWhereUniqueInput
    update: XOR<ArtifactUpdateWithoutCreatorInput, ArtifactUncheckedUpdateWithoutCreatorInput>
    create: XOR<ArtifactCreateWithoutCreatorInput, ArtifactUncheckedCreateWithoutCreatorInput>
  }

  export type ArtifactUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ArtifactWhereUniqueInput
    data: XOR<ArtifactUpdateWithoutCreatorInput, ArtifactUncheckedUpdateWithoutCreatorInput>
  }

  export type ArtifactUpdateManyWithWhereWithoutCreatorInput = {
    where: ArtifactScalarWhereInput
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ArtifactScalarWhereInput = {
    AND?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
    OR?: ArtifactScalarWhereInput[]
    NOT?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
    id?: UuidFilter<"Artifact"> | string
    projectId?: UuidFilter<"Artifact"> | string
    name?: StringFilter<"Artifact"> | string
    type?: StringFilter<"Artifact"> | string
    category?: StringFilter<"Artifact"> | string
    status?: StringFilter<"Artifact"> | string
    createdBy?: UuidFilter<"Artifact"> | string
    approvedBy?: UuidNullableFilter<"Artifact"> | string | null
    createdAt?: DateTimeFilter<"Artifact"> | Date | string
    approvedAt?: DateTimeNullableFilter<"Artifact"> | Date | string | null
  }

  export type ArtifactUpsertWithWhereUniqueWithoutApproverInput = {
    where: ArtifactWhereUniqueInput
    update: XOR<ArtifactUpdateWithoutApproverInput, ArtifactUncheckedUpdateWithoutApproverInput>
    create: XOR<ArtifactCreateWithoutApproverInput, ArtifactUncheckedCreateWithoutApproverInput>
  }

  export type ArtifactUpdateWithWhereUniqueWithoutApproverInput = {
    where: ArtifactWhereUniqueInput
    data: XOR<ArtifactUpdateWithoutApproverInput, ArtifactUncheckedUpdateWithoutApproverInput>
  }

  export type ArtifactUpdateManyWithWhereWithoutApproverInput = {
    where: ArtifactScalarWhereInput
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyWithoutApproverInput>
  }

  export type SubmissionRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: SubmissionRecordWhereUniqueInput
    update: XOR<SubmissionRecordUpdateWithoutUserInput, SubmissionRecordUncheckedUpdateWithoutUserInput>
    create: XOR<SubmissionRecordCreateWithoutUserInput, SubmissionRecordUncheckedCreateWithoutUserInput>
  }

  export type SubmissionRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: SubmissionRecordWhereUniqueInput
    data: XOR<SubmissionRecordUpdateWithoutUserInput, SubmissionRecordUncheckedUpdateWithoutUserInput>
  }

  export type SubmissionRecordUpdateManyWithWhereWithoutUserInput = {
    where: SubmissionRecordScalarWhereInput
    data: XOR<SubmissionRecordUpdateManyMutationInput, SubmissionRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type SubmissionRecordScalarWhereInput = {
    AND?: SubmissionRecordScalarWhereInput | SubmissionRecordScalarWhereInput[]
    OR?: SubmissionRecordScalarWhereInput[]
    NOT?: SubmissionRecordScalarWhereInput | SubmissionRecordScalarWhereInput[]
    id?: UuidFilter<"SubmissionRecord"> | string
    projectId?: UuidFilter<"SubmissionRecord"> | string
    artifactId?: UuidFilter<"SubmissionRecord"> | string
    portalName?: StringFilter<"SubmissionRecord"> | string
    submissionId?: StringNullableFilter<"SubmissionRecord"> | string | null
    status?: StringFilter<"SubmissionRecord"> | string
    submittedBy?: UuidFilter<"SubmissionRecord"> | string
    submittedAt?: DateTimeFilter<"SubmissionRecord"> | Date | string
    submissionMetadata?: JsonNullableFilter<"SubmissionRecord">
  }

  export type IntegrationUpsertWithWhereUniqueWithoutCreatorInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutCreatorInput, IntegrationUncheckedUpdateWithoutCreatorInput>
    create: XOR<IntegrationCreateWithoutCreatorInput, IntegrationUncheckedCreateWithoutCreatorInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutCreatorInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutCreatorInput, IntegrationUncheckedUpdateWithoutCreatorInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutCreatorInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutCreatorInput>
  }

  export type IntegrationScalarWhereInput = {
    AND?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    OR?: IntegrationScalarWhereInput[]
    NOT?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    id?: UuidFilter<"Integration"> | string
    type?: StringFilter<"Integration"> | string
    name?: StringFilter<"Integration"> | string
    configuration?: JsonFilter<"Integration">
    enabled?: BoolFilter<"Integration"> | boolean
    createdBy?: UuidFilter<"Integration"> | string
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
  }

  export type KnowledgeBaseDocumentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: KnowledgeBaseDocumentWhereUniqueInput
    update: XOR<KnowledgeBaseDocumentUpdateWithoutUploaderInput, KnowledgeBaseDocumentUncheckedUpdateWithoutUploaderInput>
    create: XOR<KnowledgeBaseDocumentCreateWithoutUploaderInput, KnowledgeBaseDocumentUncheckedCreateWithoutUploaderInput>
  }

  export type KnowledgeBaseDocumentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: KnowledgeBaseDocumentWhereUniqueInput
    data: XOR<KnowledgeBaseDocumentUpdateWithoutUploaderInput, KnowledgeBaseDocumentUncheckedUpdateWithoutUploaderInput>
  }

  export type KnowledgeBaseDocumentUpdateManyWithWhereWithoutUploaderInput = {
    where: KnowledgeBaseDocumentScalarWhereInput
    data: XOR<KnowledgeBaseDocumentUpdateManyMutationInput, KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type KnowledgeBaseDocumentScalarWhereInput = {
    AND?: KnowledgeBaseDocumentScalarWhereInput | KnowledgeBaseDocumentScalarWhereInput[]
    OR?: KnowledgeBaseDocumentScalarWhereInput[]
    NOT?: KnowledgeBaseDocumentScalarWhereInput | KnowledgeBaseDocumentScalarWhereInput[]
    id?: UuidFilter<"KnowledgeBaseDocument"> | string
    knowledgeBaseId?: UuidFilter<"KnowledgeBaseDocument"> | string
    fileName?: StringFilter<"KnowledgeBaseDocument"> | string
    filePath?: StringFilter<"KnowledgeBaseDocument"> | string
    fileType?: StringFilter<"KnowledgeBaseDocument"> | string
    fileSize?: BigIntFilter<"KnowledgeBaseDocument"> | bigint | number
    s3Bucket?: StringFilter<"KnowledgeBaseDocument"> | string
    s3Key?: StringFilter<"KnowledgeBaseDocument"> | string
    uploadedBy?: UuidFilter<"KnowledgeBaseDocument"> | string
    uploadedAt?: DateTimeFilter<"KnowledgeBaseDocument"> | Date | string
    metadata?: JsonNullableFilter<"KnowledgeBaseDocument">
    vectorIds?: StringNullableFilter<"KnowledgeBaseDocument"> | string | null
  }

  export type ArtifactVersionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ArtifactVersionWhereUniqueInput
    update: XOR<ArtifactVersionUpdateWithoutCreatorInput, ArtifactVersionUncheckedUpdateWithoutCreatorInput>
    create: XOR<ArtifactVersionCreateWithoutCreatorInput, ArtifactVersionUncheckedCreateWithoutCreatorInput>
  }

  export type ArtifactVersionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ArtifactVersionWhereUniqueInput
    data: XOR<ArtifactVersionUpdateWithoutCreatorInput, ArtifactVersionUncheckedUpdateWithoutCreatorInput>
  }

  export type ArtifactVersionUpdateManyWithWhereWithoutCreatorInput = {
    where: ArtifactVersionScalarWhereInput
    data: XOR<ArtifactVersionUpdateManyMutationInput, ArtifactVersionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ArtifactVersionScalarWhereInput = {
    AND?: ArtifactVersionScalarWhereInput | ArtifactVersionScalarWhereInput[]
    OR?: ArtifactVersionScalarWhereInput[]
    NOT?: ArtifactVersionScalarWhereInput | ArtifactVersionScalarWhereInput[]
    id?: UuidFilter<"ArtifactVersion"> | string
    artifactId?: UuidFilter<"ArtifactVersion"> | string
    versionNumber?: IntFilter<"ArtifactVersion"> | number
    content?: JsonFilter<"ArtifactVersion">
    location?: StringNullableFilter<"ArtifactVersion"> | string | null
    createdBy?: UuidFilter<"ArtifactVersion"> | string
    createdAt?: DateTimeFilter<"ArtifactVersion"> | Date | string
  }

  export type UserRoleCreateWithoutRoleInput = {
    id?: string
    assignedAt?: Date | string
    assignedBy?: string | null
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type PermissionCreateWithoutRoleInput = {
    id?: string
    resource: string
    action: string
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    resource: string
    action: string
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput>
  }

  export type PermissionCreateManyRoleInputEnvelope = {
    data: PermissionCreateManyRoleInput | PermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeBasePermissionCreateWithoutRoleInput = {
    id?: string
    userId?: string | null
    permissionType: string
    grantedAt?: Date | string
    knowledgeBase: KnowledgeBaseCreateNestedOneWithoutPermissionsInput
  }

  export type KnowledgeBasePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    knowledgeBaseId: string
    userId?: string | null
    permissionType: string
    grantedAt?: Date | string
  }

  export type KnowledgeBasePermissionCreateOrConnectWithoutRoleInput = {
    where: KnowledgeBasePermissionWhereUniqueInput
    create: XOR<KnowledgeBasePermissionCreateWithoutRoleInput, KnowledgeBasePermissionUncheckedCreateWithoutRoleInput>
  }

  export type KnowledgeBasePermissionCreateManyRoleInputEnvelope = {
    data: KnowledgeBasePermissionCreateManyRoleInput | KnowledgeBasePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type PermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutRoleInput, PermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<PermissionCreateWithoutRoleInput, PermissionUncheckedCreateWithoutRoleInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutRoleInput, PermissionUncheckedUpdateWithoutRoleInput>
  }

  export type PermissionUpdateManyWithWhereWithoutRoleInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    id?: UuidFilter<"Permission"> | string
    roleId?: UuidFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
  }

  export type KnowledgeBasePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: KnowledgeBasePermissionWhereUniqueInput
    update: XOR<KnowledgeBasePermissionUpdateWithoutRoleInput, KnowledgeBasePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<KnowledgeBasePermissionCreateWithoutRoleInput, KnowledgeBasePermissionUncheckedCreateWithoutRoleInput>
  }

  export type KnowledgeBasePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: KnowledgeBasePermissionWhereUniqueInput
    data: XOR<KnowledgeBasePermissionUpdateWithoutRoleInput, KnowledgeBasePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type KnowledgeBasePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: KnowledgeBasePermissionScalarWhereInput
    data: XOR<KnowledgeBasePermissionUpdateManyMutationInput, KnowledgeBasePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type KnowledgeBasePermissionScalarWhereInput = {
    AND?: KnowledgeBasePermissionScalarWhereInput | KnowledgeBasePermissionScalarWhereInput[]
    OR?: KnowledgeBasePermissionScalarWhereInput[]
    NOT?: KnowledgeBasePermissionScalarWhereInput | KnowledgeBasePermissionScalarWhereInput[]
    id?: UuidFilter<"KnowledgeBasePermission"> | string
    knowledgeBaseId?: UuidFilter<"KnowledgeBasePermission"> | string
    userId?: UuidNullableFilter<"KnowledgeBasePermission"> | string | null
    roleId?: UuidNullableFilter<"KnowledgeBasePermission"> | string | null
    permissionType?: StringFilter<"KnowledgeBasePermission"> | string
    grantedAt?: DateTimeFilter<"KnowledgeBasePermission"> | Date | string
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutUserRolesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: PermissionCreateNestedManyWithoutRoleInput
    kbPermissions?: KnowledgeBasePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: PermissionUncheckedCreateNestedManyWithoutRoleInput
    kbPermissions?: KnowledgeBasePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: PermissionUpdateManyWithoutRoleNestedInput
    kbPermissions?: KnowledgeBasePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: PermissionUncheckedUpdateManyWithoutRoleNestedInput
    kbPermissions?: KnowledgeBasePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
    kbPermissions?: KnowledgeBasePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    kbPermissions?: KnowledgeBasePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
    kbPermissions?: KnowledgeBasePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    kbPermissions?: KnowledgeBasePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserCreateWithoutCreatedProjectsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedProjectsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
  }

  export type UserCreateWithoutCompletedProjectsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCompletedProjectsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCompletedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompletedProjectsInput, UserUncheckedCreateWithoutCompletedProjectsInput>
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    id?: string
    addedById: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectMembershipsInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    addedById: string
    joinedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectDocumentCreateWithoutProjectInput = {
    id?: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    rawFileLocation: string
    processedFileLocation?: string | null
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploader: UserCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type ProjectDocumentUncheckedCreateWithoutProjectInput = {
    id?: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    rawFileLocation: string
    processedFileLocation?: string | null
    uploadedBy: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectDocumentCreateOrConnectWithoutProjectInput = {
    where: ProjectDocumentWhereUniqueInput
    create: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectDocumentCreateManyProjectInputEnvelope = {
    data: ProjectDocumentCreateManyProjectInput | ProjectDocumentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeBaseCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    documentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
    creator: UserCreateNestedOneWithoutCreatedKnowledgeBasesInput
    documents?: KnowledgeBaseDocumentCreateNestedManyWithoutKnowledgeBaseInput
    permissions?: KnowledgeBasePermissionCreateNestedManyWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    documentCount?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
    documents?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutKnowledgeBaseInput
    permissions?: KnowledgeBasePermissionUncheckedCreateNestedManyWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseCreateOrConnectWithoutProjectInput = {
    where: KnowledgeBaseWhereUniqueInput
    create: XOR<KnowledgeBaseCreateWithoutProjectInput, KnowledgeBaseUncheckedCreateWithoutProjectInput>
  }

  export type KnowledgeBaseCreateManyProjectInputEnvelope = {
    data: KnowledgeBaseCreateManyProjectInput | KnowledgeBaseCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ArtifactCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    category: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutCreatedArtifactsInput
    approver?: UserCreateNestedOneWithoutApprovedArtifactsInput
    versions?: ArtifactVersionCreateNestedManyWithoutArtifactInput
    submissions?: SubmissionRecordCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    category: string
    status?: string
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
    versions?: ArtifactVersionUncheckedCreateNestedManyWithoutArtifactInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactCreateOrConnectWithoutProjectInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutProjectInput, ArtifactUncheckedCreateWithoutProjectInput>
  }

  export type ArtifactCreateManyProjectInputEnvelope = {
    data: ArtifactCreateManyProjectInput | ArtifactCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowExecutionCreateWithoutProjectInput = {
    id?: string
    status?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastUpdatedAt?: Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    agentTasks?: AgentTaskCreateNestedManyWithoutWorkflowExecutionInput
  }

  export type WorkflowExecutionUncheckedCreateWithoutProjectInput = {
    id?: string
    status?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastUpdatedAt?: Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    agentTasks?: AgentTaskUncheckedCreateNestedManyWithoutWorkflowExecutionInput
  }

  export type WorkflowExecutionCreateOrConnectWithoutProjectInput = {
    where: WorkflowExecutionWhereUniqueInput
    create: XOR<WorkflowExecutionCreateWithoutProjectInput, WorkflowExecutionUncheckedCreateWithoutProjectInput>
  }

  export type WorkflowExecutionCreateManyProjectInputEnvelope = {
    data: WorkflowExecutionCreateManyProjectInput | WorkflowExecutionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionRecordCreateWithoutProjectInput = {
    id?: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
    artifact: ArtifactCreateNestedOneWithoutSubmissionsInput
    user: UserCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionRecordUncheckedCreateWithoutProjectInput = {
    id?: string
    artifactId: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedBy: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordCreateOrConnectWithoutProjectInput = {
    where: SubmissionRecordWhereUniqueInput
    create: XOR<SubmissionRecordCreateWithoutProjectInput, SubmissionRecordUncheckedCreateWithoutProjectInput>
  }

  export type SubmissionRecordCreateManyProjectInputEnvelope = {
    data: SubmissionRecordCreateManyProjectInput | SubmissionRecordCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedProjectsInput = {
    update: XOR<UserUpdateWithoutCreatedProjectsInput, UserUncheckedUpdateWithoutCreatedProjectsInput>
    create: XOR<UserCreateWithoutCreatedProjectsInput, UserUncheckedCreateWithoutCreatedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedProjectsInput, UserUncheckedUpdateWithoutCreatedProjectsInput>
  }

  export type UserUpdateWithoutCreatedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutCompletedProjectsInput = {
    update: XOR<UserUpdateWithoutCompletedProjectsInput, UserUncheckedUpdateWithoutCompletedProjectsInput>
    create: XOR<UserCreateWithoutCompletedProjectsInput, UserUncheckedCreateWithoutCompletedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompletedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompletedProjectsInput, UserUncheckedUpdateWithoutCompletedProjectsInput>
  }

  export type UserUpdateWithoutCompletedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCompletedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectDocumentUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectDocumentWhereUniqueInput
    update: XOR<ProjectDocumentUpdateWithoutProjectInput, ProjectDocumentUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectDocumentUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectDocumentWhereUniqueInput
    data: XOR<ProjectDocumentUpdateWithoutProjectInput, ProjectDocumentUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectDocumentUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectDocumentScalarWhereInput
    data: XOR<ProjectDocumentUpdateManyMutationInput, ProjectDocumentUncheckedUpdateManyWithoutProjectInput>
  }

  export type KnowledgeBaseUpsertWithWhereUniqueWithoutProjectInput = {
    where: KnowledgeBaseWhereUniqueInput
    update: XOR<KnowledgeBaseUpdateWithoutProjectInput, KnowledgeBaseUncheckedUpdateWithoutProjectInput>
    create: XOR<KnowledgeBaseCreateWithoutProjectInput, KnowledgeBaseUncheckedCreateWithoutProjectInput>
  }

  export type KnowledgeBaseUpdateWithWhereUniqueWithoutProjectInput = {
    where: KnowledgeBaseWhereUniqueInput
    data: XOR<KnowledgeBaseUpdateWithoutProjectInput, KnowledgeBaseUncheckedUpdateWithoutProjectInput>
  }

  export type KnowledgeBaseUpdateManyWithWhereWithoutProjectInput = {
    where: KnowledgeBaseScalarWhereInput
    data: XOR<KnowledgeBaseUpdateManyMutationInput, KnowledgeBaseUncheckedUpdateManyWithoutProjectInput>
  }

  export type ArtifactUpsertWithWhereUniqueWithoutProjectInput = {
    where: ArtifactWhereUniqueInput
    update: XOR<ArtifactUpdateWithoutProjectInput, ArtifactUncheckedUpdateWithoutProjectInput>
    create: XOR<ArtifactCreateWithoutProjectInput, ArtifactUncheckedCreateWithoutProjectInput>
  }

  export type ArtifactUpdateWithWhereUniqueWithoutProjectInput = {
    where: ArtifactWhereUniqueInput
    data: XOR<ArtifactUpdateWithoutProjectInput, ArtifactUncheckedUpdateWithoutProjectInput>
  }

  export type ArtifactUpdateManyWithWhereWithoutProjectInput = {
    where: ArtifactScalarWhereInput
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyWithoutProjectInput>
  }

  export type WorkflowExecutionUpsertWithWhereUniqueWithoutProjectInput = {
    where: WorkflowExecutionWhereUniqueInput
    update: XOR<WorkflowExecutionUpdateWithoutProjectInput, WorkflowExecutionUncheckedUpdateWithoutProjectInput>
    create: XOR<WorkflowExecutionCreateWithoutProjectInput, WorkflowExecutionUncheckedCreateWithoutProjectInput>
  }

  export type WorkflowExecutionUpdateWithWhereUniqueWithoutProjectInput = {
    where: WorkflowExecutionWhereUniqueInput
    data: XOR<WorkflowExecutionUpdateWithoutProjectInput, WorkflowExecutionUncheckedUpdateWithoutProjectInput>
  }

  export type WorkflowExecutionUpdateManyWithWhereWithoutProjectInput = {
    where: WorkflowExecutionScalarWhereInput
    data: XOR<WorkflowExecutionUpdateManyMutationInput, WorkflowExecutionUncheckedUpdateManyWithoutProjectInput>
  }

  export type WorkflowExecutionScalarWhereInput = {
    AND?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[]
    OR?: WorkflowExecutionScalarWhereInput[]
    NOT?: WorkflowExecutionScalarWhereInput | WorkflowExecutionScalarWhereInput[]
    id?: UuidFilter<"WorkflowExecution"> | string
    projectId?: UuidFilter<"WorkflowExecution"> | string
    status?: StringFilter<"WorkflowExecution"> | string
    initiatedBy?: UuidFilter<"WorkflowExecution"> | string
    handledBy?: UuidNullableFilter<"WorkflowExecution"> | string | null
    completedBy?: UuidNullableFilter<"WorkflowExecution"> | string | null
    startedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowExecution"> | Date | string | null
    lastUpdatedAt?: DateTimeFilter<"WorkflowExecution"> | Date | string
    workflowConfig?: JsonNullableFilter<"WorkflowExecution">
    errorLog?: JsonNullableFilter<"WorkflowExecution">
    errorMessage?: StringNullableFilter<"WorkflowExecution"> | string | null
    results?: JsonNullableFilter<"WorkflowExecution">
  }

  export type SubmissionRecordUpsertWithWhereUniqueWithoutProjectInput = {
    where: SubmissionRecordWhereUniqueInput
    update: XOR<SubmissionRecordUpdateWithoutProjectInput, SubmissionRecordUncheckedUpdateWithoutProjectInput>
    create: XOR<SubmissionRecordCreateWithoutProjectInput, SubmissionRecordUncheckedCreateWithoutProjectInput>
  }

  export type SubmissionRecordUpdateWithWhereUniqueWithoutProjectInput = {
    where: SubmissionRecordWhereUniqueInput
    data: XOR<SubmissionRecordUpdateWithoutProjectInput, SubmissionRecordUncheckedUpdateWithoutProjectInput>
  }

  export type SubmissionRecordUpdateManyWithWhereWithoutProjectInput = {
    where: SubmissionRecordScalarWhereInput
    data: XOR<SubmissionRecordUpdateManyMutationInput, SubmissionRecordUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator: UserCreateNestedOneWithoutCreatedProjectsInput
    completer?: UserCreateNestedOneWithoutCompletedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdBy: string
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDocumentsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutUploadedDocumentsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutUploadedDocumentsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutUploadedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
  }

  export type ProjectUpsertWithoutDocumentsInput = {
    update: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ProjectCreateWithoutDocumentsInput, ProjectUncheckedCreateWithoutDocumentsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDocumentsInput, ProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type ProjectUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    completer?: UserUpdateOneWithoutCompletedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutUploadedDocumentsInput = {
    update: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
    create: XOR<UserCreateWithoutUploadedDocumentsInput, UserUncheckedCreateWithoutUploadedDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedDocumentsInput, UserUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type UserUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator: UserCreateNestedOneWithoutCreatedProjectsInput
    completer?: UserCreateNestedOneWithoutCompletedProjectsInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdBy: string
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutProjectMembershipsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutProjectMembershipsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutProjectMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    completer?: UserUpdateOneWithoutCompletedProjectsNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectMembershipsInput = {
    update: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
    create: XOR<UserCreateWithoutProjectMembershipsInput, UserUncheckedCreateWithoutProjectMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMembershipsInput, UserUncheckedUpdateWithoutProjectMembershipsInput>
  }

  export type UserUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ProjectCreateWithoutWorkflowExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator: UserCreateNestedOneWithoutCreatedProjectsInput
    completer?: UserCreateNestedOneWithoutCompletedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWorkflowExecutionsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdBy: string
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWorkflowExecutionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWorkflowExecutionsInput, ProjectUncheckedCreateWithoutWorkflowExecutionsInput>
  }

  export type AgentTaskCreateWithoutWorkflowExecutionInput = {
    id?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    agent: string
    status?: string
    sequenceOrder: number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    executionTimeSeconds?: number | null
  }

  export type AgentTaskUncheckedCreateWithoutWorkflowExecutionInput = {
    id?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    agent: string
    status?: string
    sequenceOrder: number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    executionTimeSeconds?: number | null
  }

  export type AgentTaskCreateOrConnectWithoutWorkflowExecutionInput = {
    where: AgentTaskWhereUniqueInput
    create: XOR<AgentTaskCreateWithoutWorkflowExecutionInput, AgentTaskUncheckedCreateWithoutWorkflowExecutionInput>
  }

  export type AgentTaskCreateManyWorkflowExecutionInputEnvelope = {
    data: AgentTaskCreateManyWorkflowExecutionInput | AgentTaskCreateManyWorkflowExecutionInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutWorkflowExecutionsInput = {
    update: XOR<ProjectUpdateWithoutWorkflowExecutionsInput, ProjectUncheckedUpdateWithoutWorkflowExecutionsInput>
    create: XOR<ProjectCreateWithoutWorkflowExecutionsInput, ProjectUncheckedCreateWithoutWorkflowExecutionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutWorkflowExecutionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutWorkflowExecutionsInput, ProjectUncheckedUpdateWithoutWorkflowExecutionsInput>
  }

  export type ProjectUpdateWithoutWorkflowExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    completer?: UserUpdateOneWithoutCompletedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWorkflowExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AgentTaskUpsertWithWhereUniqueWithoutWorkflowExecutionInput = {
    where: AgentTaskWhereUniqueInput
    update: XOR<AgentTaskUpdateWithoutWorkflowExecutionInput, AgentTaskUncheckedUpdateWithoutWorkflowExecutionInput>
    create: XOR<AgentTaskCreateWithoutWorkflowExecutionInput, AgentTaskUncheckedCreateWithoutWorkflowExecutionInput>
  }

  export type AgentTaskUpdateWithWhereUniqueWithoutWorkflowExecutionInput = {
    where: AgentTaskWhereUniqueInput
    data: XOR<AgentTaskUpdateWithoutWorkflowExecutionInput, AgentTaskUncheckedUpdateWithoutWorkflowExecutionInput>
  }

  export type AgentTaskUpdateManyWithWhereWithoutWorkflowExecutionInput = {
    where: AgentTaskScalarWhereInput
    data: XOR<AgentTaskUpdateManyMutationInput, AgentTaskUncheckedUpdateManyWithoutWorkflowExecutionInput>
  }

  export type AgentTaskScalarWhereInput = {
    AND?: AgentTaskScalarWhereInput | AgentTaskScalarWhereInput[]
    OR?: AgentTaskScalarWhereInput[]
    NOT?: AgentTaskScalarWhereInput | AgentTaskScalarWhereInput[]
    id?: UuidFilter<"AgentTask"> | string
    workflowExecutionId?: UuidFilter<"AgentTask"> | string
    initiatedBy?: UuidFilter<"AgentTask"> | string
    handledBy?: UuidNullableFilter<"AgentTask"> | string | null
    completedBy?: UuidNullableFilter<"AgentTask"> | string | null
    agent?: StringFilter<"AgentTask"> | string
    status?: StringFilter<"AgentTask"> | string
    sequenceOrder?: IntFilter<"AgentTask"> | number
    inputData?: JsonNullableFilter<"AgentTask">
    outputData?: JsonNullableFilter<"AgentTask">
    taskConfig?: JsonNullableFilter<"AgentTask">
    errorLog?: JsonNullableFilter<"AgentTask">
    errorMessage?: StringNullableFilter<"AgentTask"> | string | null
    startedAt?: DateTimeNullableFilter<"AgentTask"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AgentTask"> | Date | string | null
    executionTimeSeconds?: FloatNullableFilter<"AgentTask"> | number | null
  }

  export type WorkflowExecutionCreateWithoutAgentTasksInput = {
    id?: string
    status?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastUpdatedAt?: Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutWorkflowExecutionsInput
  }

  export type WorkflowExecutionUncheckedCreateWithoutAgentTasksInput = {
    id?: string
    projectId: string
    status?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastUpdatedAt?: Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionCreateOrConnectWithoutAgentTasksInput = {
    where: WorkflowExecutionWhereUniqueInput
    create: XOR<WorkflowExecutionCreateWithoutAgentTasksInput, WorkflowExecutionUncheckedCreateWithoutAgentTasksInput>
  }

  export type WorkflowExecutionUpsertWithoutAgentTasksInput = {
    update: XOR<WorkflowExecutionUpdateWithoutAgentTasksInput, WorkflowExecutionUncheckedUpdateWithoutAgentTasksInput>
    create: XOR<WorkflowExecutionCreateWithoutAgentTasksInput, WorkflowExecutionUncheckedCreateWithoutAgentTasksInput>
    where?: WorkflowExecutionWhereInput
  }

  export type WorkflowExecutionUpdateToOneWithWhereWithoutAgentTasksInput = {
    where?: WorkflowExecutionWhereInput
    data: XOR<WorkflowExecutionUpdateWithoutAgentTasksInput, WorkflowExecutionUncheckedUpdateWithoutAgentTasksInput>
  }

  export type WorkflowExecutionUpdateWithoutAgentTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutWorkflowExecutionsNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateWithoutAgentTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectCreateWithoutArtifactsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator: UserCreateNestedOneWithoutCreatedProjectsInput
    completer?: UserCreateNestedOneWithoutCompletedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutArtifactsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdBy: string
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutArtifactsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutArtifactsInput, ProjectUncheckedCreateWithoutArtifactsInput>
  }

  export type UserCreateWithoutCreatedArtifactsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedArtifactsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedArtifactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedArtifactsInput, UserUncheckedCreateWithoutCreatedArtifactsInput>
  }

  export type UserCreateWithoutApprovedArtifactsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutApprovedArtifactsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutApprovedArtifactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedArtifactsInput, UserUncheckedCreateWithoutApprovedArtifactsInput>
  }

  export type ArtifactVersionCreateWithoutArtifactInput = {
    id?: string
    versionNumber: number
    content: JsonNullValueInput | InputJsonValue
    location?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedArtifactVersionsInput
  }

  export type ArtifactVersionUncheckedCreateWithoutArtifactInput = {
    id?: string
    versionNumber: number
    content: JsonNullValueInput | InputJsonValue
    location?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ArtifactVersionCreateOrConnectWithoutArtifactInput = {
    where: ArtifactVersionWhereUniqueInput
    create: XOR<ArtifactVersionCreateWithoutArtifactInput, ArtifactVersionUncheckedCreateWithoutArtifactInput>
  }

  export type ArtifactVersionCreateManyArtifactInputEnvelope = {
    data: ArtifactVersionCreateManyArtifactInput | ArtifactVersionCreateManyArtifactInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionRecordCreateWithoutArtifactInput = {
    id?: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
    project: ProjectCreateNestedOneWithoutSubmissionsInput
    user: UserCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionRecordUncheckedCreateWithoutArtifactInput = {
    id?: string
    projectId: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedBy: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordCreateOrConnectWithoutArtifactInput = {
    where: SubmissionRecordWhereUniqueInput
    create: XOR<SubmissionRecordCreateWithoutArtifactInput, SubmissionRecordUncheckedCreateWithoutArtifactInput>
  }

  export type SubmissionRecordCreateManyArtifactInputEnvelope = {
    data: SubmissionRecordCreateManyArtifactInput | SubmissionRecordCreateManyArtifactInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutArtifactsInput = {
    update: XOR<ProjectUpdateWithoutArtifactsInput, ProjectUncheckedUpdateWithoutArtifactsInput>
    create: XOR<ProjectCreateWithoutArtifactsInput, ProjectUncheckedCreateWithoutArtifactsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutArtifactsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutArtifactsInput, ProjectUncheckedUpdateWithoutArtifactsInput>
  }

  export type ProjectUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    completer?: UserUpdateOneWithoutCompletedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutCreatedArtifactsInput = {
    update: XOR<UserUpdateWithoutCreatedArtifactsInput, UserUncheckedUpdateWithoutCreatedArtifactsInput>
    create: XOR<UserCreateWithoutCreatedArtifactsInput, UserUncheckedCreateWithoutCreatedArtifactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedArtifactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedArtifactsInput, UserUncheckedUpdateWithoutCreatedArtifactsInput>
  }

  export type UserUpdateWithoutCreatedArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutApprovedArtifactsInput = {
    update: XOR<UserUpdateWithoutApprovedArtifactsInput, UserUncheckedUpdateWithoutApprovedArtifactsInput>
    create: XOR<UserCreateWithoutApprovedArtifactsInput, UserUncheckedCreateWithoutApprovedArtifactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedArtifactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedArtifactsInput, UserUncheckedUpdateWithoutApprovedArtifactsInput>
  }

  export type UserUpdateWithoutApprovedArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ArtifactVersionUpsertWithWhereUniqueWithoutArtifactInput = {
    where: ArtifactVersionWhereUniqueInput
    update: XOR<ArtifactVersionUpdateWithoutArtifactInput, ArtifactVersionUncheckedUpdateWithoutArtifactInput>
    create: XOR<ArtifactVersionCreateWithoutArtifactInput, ArtifactVersionUncheckedCreateWithoutArtifactInput>
  }

  export type ArtifactVersionUpdateWithWhereUniqueWithoutArtifactInput = {
    where: ArtifactVersionWhereUniqueInput
    data: XOR<ArtifactVersionUpdateWithoutArtifactInput, ArtifactVersionUncheckedUpdateWithoutArtifactInput>
  }

  export type ArtifactVersionUpdateManyWithWhereWithoutArtifactInput = {
    where: ArtifactVersionScalarWhereInput
    data: XOR<ArtifactVersionUpdateManyMutationInput, ArtifactVersionUncheckedUpdateManyWithoutArtifactInput>
  }

  export type SubmissionRecordUpsertWithWhereUniqueWithoutArtifactInput = {
    where: SubmissionRecordWhereUniqueInput
    update: XOR<SubmissionRecordUpdateWithoutArtifactInput, SubmissionRecordUncheckedUpdateWithoutArtifactInput>
    create: XOR<SubmissionRecordCreateWithoutArtifactInput, SubmissionRecordUncheckedCreateWithoutArtifactInput>
  }

  export type SubmissionRecordUpdateWithWhereUniqueWithoutArtifactInput = {
    where: SubmissionRecordWhereUniqueInput
    data: XOR<SubmissionRecordUpdateWithoutArtifactInput, SubmissionRecordUncheckedUpdateWithoutArtifactInput>
  }

  export type SubmissionRecordUpdateManyWithWhereWithoutArtifactInput = {
    where: SubmissionRecordScalarWhereInput
    data: XOR<SubmissionRecordUpdateManyMutationInput, SubmissionRecordUncheckedUpdateManyWithoutArtifactInput>
  }

  export type ArtifactCreateWithoutVersionsInput = {
    id?: string
    name: string
    type: string
    category: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutArtifactsInput
    creator: UserCreateNestedOneWithoutCreatedArtifactsInput
    approver?: UserCreateNestedOneWithoutApprovedArtifactsInput
    submissions?: SubmissionRecordCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactUncheckedCreateWithoutVersionsInput = {
    id?: string
    projectId: string
    name: string
    type: string
    category: string
    status?: string
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactCreateOrConnectWithoutVersionsInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutVersionsInput, ArtifactUncheckedCreateWithoutVersionsInput>
  }

  export type UserCreateWithoutCreatedArtifactVersionsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
  }

  export type UserUncheckedCreateWithoutCreatedArtifactVersionsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type UserCreateOrConnectWithoutCreatedArtifactVersionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedArtifactVersionsInput, UserUncheckedCreateWithoutCreatedArtifactVersionsInput>
  }

  export type ArtifactUpsertWithoutVersionsInput = {
    update: XOR<ArtifactUpdateWithoutVersionsInput, ArtifactUncheckedUpdateWithoutVersionsInput>
    create: XOR<ArtifactCreateWithoutVersionsInput, ArtifactUncheckedCreateWithoutVersionsInput>
    where?: ArtifactWhereInput
  }

  export type ArtifactUpdateToOneWithWhereWithoutVersionsInput = {
    where?: ArtifactWhereInput
    data: XOR<ArtifactUpdateWithoutVersionsInput, ArtifactUncheckedUpdateWithoutVersionsInput>
  }

  export type ArtifactUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutArtifactsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedArtifactsNestedInput
    approver?: UserUpdateOneWithoutApprovedArtifactsNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutArtifactNestedInput
  }

  export type ArtifactUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type UserUpsertWithoutCreatedArtifactVersionsInput = {
    update: XOR<UserUpdateWithoutCreatedArtifactVersionsInput, UserUncheckedUpdateWithoutCreatedArtifactVersionsInput>
    create: XOR<UserCreateWithoutCreatedArtifactVersionsInput, UserUncheckedCreateWithoutCreatedArtifactVersionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedArtifactVersionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedArtifactVersionsInput, UserUncheckedUpdateWithoutCreatedArtifactVersionsInput>
  }

  export type UserUpdateWithoutCreatedArtifactVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedArtifactVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type ProjectCreateWithoutKnowledgeBasesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator: UserCreateNestedOneWithoutCreatedProjectsInput
    completer?: UserCreateNestedOneWithoutCompletedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutKnowledgeBasesInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdBy: string
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutProjectInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutKnowledgeBasesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutKnowledgeBasesInput, ProjectUncheckedCreateWithoutKnowledgeBasesInput>
  }

  export type UserCreateWithoutCreatedKnowledgeBasesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedKnowledgeBasesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedKnowledgeBasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedKnowledgeBasesInput, UserUncheckedCreateWithoutCreatedKnowledgeBasesInput>
  }

  export type KnowledgeBaseDocumentCreateWithoutKnowledgeBaseInput = {
    id?: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    s3Bucket: string
    s3Key: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: string | null
    uploader: UserCreateNestedOneWithoutUploadedKBDocumentsInput
  }

  export type KnowledgeBaseDocumentUncheckedCreateWithoutKnowledgeBaseInput = {
    id?: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    s3Bucket: string
    s3Key: string
    uploadedBy: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: string | null
  }

  export type KnowledgeBaseDocumentCreateOrConnectWithoutKnowledgeBaseInput = {
    where: KnowledgeBaseDocumentWhereUniqueInput
    create: XOR<KnowledgeBaseDocumentCreateWithoutKnowledgeBaseInput, KnowledgeBaseDocumentUncheckedCreateWithoutKnowledgeBaseInput>
  }

  export type KnowledgeBaseDocumentCreateManyKnowledgeBaseInputEnvelope = {
    data: KnowledgeBaseDocumentCreateManyKnowledgeBaseInput | KnowledgeBaseDocumentCreateManyKnowledgeBaseInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeBasePermissionCreateWithoutKnowledgeBaseInput = {
    id?: string
    userId?: string | null
    permissionType: string
    grantedAt?: Date | string
    role?: RoleCreateNestedOneWithoutKbPermissionsInput
  }

  export type KnowledgeBasePermissionUncheckedCreateWithoutKnowledgeBaseInput = {
    id?: string
    userId?: string | null
    roleId?: string | null
    permissionType: string
    grantedAt?: Date | string
  }

  export type KnowledgeBasePermissionCreateOrConnectWithoutKnowledgeBaseInput = {
    where: KnowledgeBasePermissionWhereUniqueInput
    create: XOR<KnowledgeBasePermissionCreateWithoutKnowledgeBaseInput, KnowledgeBasePermissionUncheckedCreateWithoutKnowledgeBaseInput>
  }

  export type KnowledgeBasePermissionCreateManyKnowledgeBaseInputEnvelope = {
    data: KnowledgeBasePermissionCreateManyKnowledgeBaseInput | KnowledgeBasePermissionCreateManyKnowledgeBaseInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutKnowledgeBasesInput = {
    update: XOR<ProjectUpdateWithoutKnowledgeBasesInput, ProjectUncheckedUpdateWithoutKnowledgeBasesInput>
    create: XOR<ProjectCreateWithoutKnowledgeBasesInput, ProjectUncheckedCreateWithoutKnowledgeBasesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutKnowledgeBasesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutKnowledgeBasesInput, ProjectUncheckedUpdateWithoutKnowledgeBasesInput>
  }

  export type ProjectUpdateWithoutKnowledgeBasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    completer?: UserUpdateOneWithoutCompletedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutKnowledgeBasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutCreatedKnowledgeBasesInput = {
    update: XOR<UserUpdateWithoutCreatedKnowledgeBasesInput, UserUncheckedUpdateWithoutCreatedKnowledgeBasesInput>
    create: XOR<UserCreateWithoutCreatedKnowledgeBasesInput, UserUncheckedCreateWithoutCreatedKnowledgeBasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedKnowledgeBasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedKnowledgeBasesInput, UserUncheckedUpdateWithoutCreatedKnowledgeBasesInput>
  }

  export type UserUpdateWithoutCreatedKnowledgeBasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedKnowledgeBasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type KnowledgeBaseDocumentUpsertWithWhereUniqueWithoutKnowledgeBaseInput = {
    where: KnowledgeBaseDocumentWhereUniqueInput
    update: XOR<KnowledgeBaseDocumentUpdateWithoutKnowledgeBaseInput, KnowledgeBaseDocumentUncheckedUpdateWithoutKnowledgeBaseInput>
    create: XOR<KnowledgeBaseDocumentCreateWithoutKnowledgeBaseInput, KnowledgeBaseDocumentUncheckedCreateWithoutKnowledgeBaseInput>
  }

  export type KnowledgeBaseDocumentUpdateWithWhereUniqueWithoutKnowledgeBaseInput = {
    where: KnowledgeBaseDocumentWhereUniqueInput
    data: XOR<KnowledgeBaseDocumentUpdateWithoutKnowledgeBaseInput, KnowledgeBaseDocumentUncheckedUpdateWithoutKnowledgeBaseInput>
  }

  export type KnowledgeBaseDocumentUpdateManyWithWhereWithoutKnowledgeBaseInput = {
    where: KnowledgeBaseDocumentScalarWhereInput
    data: XOR<KnowledgeBaseDocumentUpdateManyMutationInput, KnowledgeBaseDocumentUncheckedUpdateManyWithoutKnowledgeBaseInput>
  }

  export type KnowledgeBasePermissionUpsertWithWhereUniqueWithoutKnowledgeBaseInput = {
    where: KnowledgeBasePermissionWhereUniqueInput
    update: XOR<KnowledgeBasePermissionUpdateWithoutKnowledgeBaseInput, KnowledgeBasePermissionUncheckedUpdateWithoutKnowledgeBaseInput>
    create: XOR<KnowledgeBasePermissionCreateWithoutKnowledgeBaseInput, KnowledgeBasePermissionUncheckedCreateWithoutKnowledgeBaseInput>
  }

  export type KnowledgeBasePermissionUpdateWithWhereUniqueWithoutKnowledgeBaseInput = {
    where: KnowledgeBasePermissionWhereUniqueInput
    data: XOR<KnowledgeBasePermissionUpdateWithoutKnowledgeBaseInput, KnowledgeBasePermissionUncheckedUpdateWithoutKnowledgeBaseInput>
  }

  export type KnowledgeBasePermissionUpdateManyWithWhereWithoutKnowledgeBaseInput = {
    where: KnowledgeBasePermissionScalarWhereInput
    data: XOR<KnowledgeBasePermissionUpdateManyMutationInput, KnowledgeBasePermissionUncheckedUpdateManyWithoutKnowledgeBaseInput>
  }

  export type KnowledgeBaseCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    documentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
    project?: ProjectCreateNestedOneWithoutKnowledgeBasesInput
    creator: UserCreateNestedOneWithoutCreatedKnowledgeBasesInput
    permissions?: KnowledgeBasePermissionCreateNestedManyWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    projectId?: string | null
    documentCount?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
    permissions?: KnowledgeBasePermissionUncheckedCreateNestedManyWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseCreateOrConnectWithoutDocumentsInput = {
    where: KnowledgeBaseWhereUniqueInput
    create: XOR<KnowledgeBaseCreateWithoutDocumentsInput, KnowledgeBaseUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutUploadedKBDocumentsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutUploadedKBDocumentsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutUploadedKBDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedKBDocumentsInput, UserUncheckedCreateWithoutUploadedKBDocumentsInput>
  }

  export type KnowledgeBaseUpsertWithoutDocumentsInput = {
    update: XOR<KnowledgeBaseUpdateWithoutDocumentsInput, KnowledgeBaseUncheckedUpdateWithoutDocumentsInput>
    create: XOR<KnowledgeBaseCreateWithoutDocumentsInput, KnowledgeBaseUncheckedCreateWithoutDocumentsInput>
    where?: KnowledgeBaseWhereInput
  }

  export type KnowledgeBaseUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: KnowledgeBaseWhereInput
    data: XOR<KnowledgeBaseUpdateWithoutDocumentsInput, KnowledgeBaseUncheckedUpdateWithoutDocumentsInput>
  }

  export type KnowledgeBaseUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    documentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneWithoutKnowledgeBasesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedKnowledgeBasesNestedInput
    permissions?: KnowledgeBasePermissionUpdateManyWithoutKnowledgeBaseNestedInput
  }

  export type KnowledgeBaseUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    documentCount?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: KnowledgeBasePermissionUncheckedUpdateManyWithoutKnowledgeBaseNestedInput
  }

  export type UserUpsertWithoutUploadedKBDocumentsInput = {
    update: XOR<UserUpdateWithoutUploadedKBDocumentsInput, UserUncheckedUpdateWithoutUploadedKBDocumentsInput>
    create: XOR<UserCreateWithoutUploadedKBDocumentsInput, UserUncheckedCreateWithoutUploadedKBDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedKBDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedKBDocumentsInput, UserUncheckedUpdateWithoutUploadedKBDocumentsInput>
  }

  export type UserUpdateWithoutUploadedKBDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedKBDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type KnowledgeBaseCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    documentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
    project?: ProjectCreateNestedOneWithoutKnowledgeBasesInput
    creator: UserCreateNestedOneWithoutCreatedKnowledgeBasesInput
    documents?: KnowledgeBaseDocumentCreateNestedManyWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    projectId?: string | null
    documentCount?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
    documents?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutKnowledgeBaseInput
  }

  export type KnowledgeBaseCreateOrConnectWithoutPermissionsInput = {
    where: KnowledgeBaseWhereUniqueInput
    create: XOR<KnowledgeBaseCreateWithoutPermissionsInput, KnowledgeBaseUncheckedCreateWithoutPermissionsInput>
  }

  export type RoleCreateWithoutKbPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
    permissions?: PermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutKbPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutKbPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutKbPermissionsInput, RoleUncheckedCreateWithoutKbPermissionsInput>
  }

  export type KnowledgeBaseUpsertWithoutPermissionsInput = {
    update: XOR<KnowledgeBaseUpdateWithoutPermissionsInput, KnowledgeBaseUncheckedUpdateWithoutPermissionsInput>
    create: XOR<KnowledgeBaseCreateWithoutPermissionsInput, KnowledgeBaseUncheckedCreateWithoutPermissionsInput>
    where?: KnowledgeBaseWhereInput
  }

  export type KnowledgeBaseUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: KnowledgeBaseWhereInput
    data: XOR<KnowledgeBaseUpdateWithoutPermissionsInput, KnowledgeBaseUncheckedUpdateWithoutPermissionsInput>
  }

  export type KnowledgeBaseUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    documentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneWithoutKnowledgeBasesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedKnowledgeBasesNestedInput
    documents?: KnowledgeBaseDocumentUpdateManyWithoutKnowledgeBaseNestedInput
  }

  export type KnowledgeBaseUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    documentCount?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutKnowledgeBaseNestedInput
  }

  export type RoleUpsertWithoutKbPermissionsInput = {
    update: XOR<RoleUpdateWithoutKbPermissionsInput, RoleUncheckedUpdateWithoutKbPermissionsInput>
    create: XOR<RoleCreateWithoutKbPermissionsInput, RoleUncheckedCreateWithoutKbPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutKbPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutKbPermissionsInput, RoleUncheckedUpdateWithoutKbPermissionsInput>
  }

  export type RoleUpdateWithoutKbPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutKbPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutCreatedIntegrationsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordCreateNestedManyWithoutUserInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCreatedIntegrationsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    submissions?: SubmissionRecordUncheckedCreateNestedManyWithoutUserInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCreatedIntegrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
  }

  export type IntegrationLogCreateWithoutIntegrationInput = {
    id?: string
    action: string
    status: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type IntegrationLogUncheckedCreateWithoutIntegrationInput = {
    id?: string
    action: string
    status: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type IntegrationLogCreateOrConnectWithoutIntegrationInput = {
    where: IntegrationLogWhereUniqueInput
    create: XOR<IntegrationLogCreateWithoutIntegrationInput, IntegrationLogUncheckedCreateWithoutIntegrationInput>
  }

  export type IntegrationLogCreateManyIntegrationInputEnvelope = {
    data: IntegrationLogCreateManyIntegrationInput | IntegrationLogCreateManyIntegrationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedIntegrationsInput = {
    update: XOR<UserUpdateWithoutCreatedIntegrationsInput, UserUncheckedUpdateWithoutCreatedIntegrationsInput>
    create: XOR<UserCreateWithoutCreatedIntegrationsInput, UserUncheckedCreateWithoutCreatedIntegrationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedIntegrationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedIntegrationsInput, UserUncheckedUpdateWithoutCreatedIntegrationsInput>
  }

  export type UserUpdateWithoutCreatedIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutUserNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutUserNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type IntegrationLogUpsertWithWhereUniqueWithoutIntegrationInput = {
    where: IntegrationLogWhereUniqueInput
    update: XOR<IntegrationLogUpdateWithoutIntegrationInput, IntegrationLogUncheckedUpdateWithoutIntegrationInput>
    create: XOR<IntegrationLogCreateWithoutIntegrationInput, IntegrationLogUncheckedCreateWithoutIntegrationInput>
  }

  export type IntegrationLogUpdateWithWhereUniqueWithoutIntegrationInput = {
    where: IntegrationLogWhereUniqueInput
    data: XOR<IntegrationLogUpdateWithoutIntegrationInput, IntegrationLogUncheckedUpdateWithoutIntegrationInput>
  }

  export type IntegrationLogUpdateManyWithWhereWithoutIntegrationInput = {
    where: IntegrationLogScalarWhereInput
    data: XOR<IntegrationLogUpdateManyMutationInput, IntegrationLogUncheckedUpdateManyWithoutIntegrationInput>
  }

  export type IntegrationLogScalarWhereInput = {
    AND?: IntegrationLogScalarWhereInput | IntegrationLogScalarWhereInput[]
    OR?: IntegrationLogScalarWhereInput[]
    NOT?: IntegrationLogScalarWhereInput | IntegrationLogScalarWhereInput[]
    id?: UuidFilter<"IntegrationLog"> | string
    integrationId?: UuidFilter<"IntegrationLog"> | string
    action?: StringFilter<"IntegrationLog"> | string
    status?: StringFilter<"IntegrationLog"> | string
    requestData?: JsonNullableFilter<"IntegrationLog">
    responseData?: JsonNullableFilter<"IntegrationLog">
    errorMessage?: StringNullableFilter<"IntegrationLog"> | string | null
    createdAt?: DateTimeFilter<"IntegrationLog"> | Date | string
  }

  export type IntegrationCreateWithoutLogsInput = {
    id?: string
    type: string
    name: string
    configuration: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedIntegrationsInput
  }

  export type IntegrationUncheckedCreateWithoutLogsInput = {
    id?: string
    type: string
    name: string
    configuration: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateOrConnectWithoutLogsInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutLogsInput, IntegrationUncheckedCreateWithoutLogsInput>
  }

  export type IntegrationUpsertWithoutLogsInput = {
    update: XOR<IntegrationUpdateWithoutLogsInput, IntegrationUncheckedUpdateWithoutLogsInput>
    create: XOR<IntegrationCreateWithoutLogsInput, IntegrationUncheckedCreateWithoutLogsInput>
    where?: IntegrationWhereInput
  }

  export type IntegrationUpdateToOneWithWhereWithoutLogsInput = {
    where?: IntegrationWhereInput
    data: XOR<IntegrationUpdateWithoutLogsInput, IntegrationUncheckedUpdateWithoutLogsInput>
  }

  export type IntegrationUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    configuration?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    configuration?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateWithoutSubmissionsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator: UserCreateNestedOneWithoutCreatedProjectsInput
    completer?: UserCreateNestedOneWithoutCompletedProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdBy: string
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
    knowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutProjectInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutProjectInput
    workflowExecutions?: WorkflowExecutionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSubmissionsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSubmissionsInput, ProjectUncheckedCreateWithoutSubmissionsInput>
  }

  export type ArtifactCreateWithoutSubmissionsInput = {
    id?: string
    name: string
    type: string
    category: string
    status?: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutArtifactsInput
    creator: UserCreateNestedOneWithoutCreatedArtifactsInput
    approver?: UserCreateNestedOneWithoutApprovedArtifactsInput
    versions?: ArtifactVersionCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    projectId: string
    name: string
    type: string
    category: string
    status?: string
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
    versions?: ArtifactVersionUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ArtifactCreateOrConnectWithoutSubmissionsInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutSubmissionsInput, ArtifactUncheckedCreateWithoutSubmissionsInput>
  }

  export type UserCreateWithoutSubmissionsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberCreateNestedManyWithoutUserInput
    createdProjects?: ProjectCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectCreateNestedManyWithoutCompleterInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactCreateNestedManyWithoutApproverInput
    createdIntegrations?: IntegrationCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    firstName: string
    lastName: string
    profileImageUrl?: string | null
    preferredLanguage?: string | null
    themePreference?: string | null
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    cognitoUserId: string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    projectMemberships?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    createdProjects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    completedProjects?: ProjectUncheckedCreateNestedManyWithoutCompleterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    uploadedDocuments?: ProjectDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedCreateNestedManyWithoutCreatorInput
    createdArtifacts?: ArtifactUncheckedCreateNestedManyWithoutCreatorInput
    approvedArtifacts?: ArtifactUncheckedCreateNestedManyWithoutApproverInput
    createdIntegrations?: IntegrationUncheckedCreateNestedManyWithoutCreatorInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedCreateNestedManyWithoutUploaderInput
    createdArtifactVersions?: ArtifactVersionUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
  }

  export type ProjectUpsertWithoutSubmissionsInput = {
    update: XOR<ProjectUpdateWithoutSubmissionsInput, ProjectUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<ProjectCreateWithoutSubmissionsInput, ProjectUncheckedCreateWithoutSubmissionsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSubmissionsInput, ProjectUncheckedUpdateWithoutSubmissionsInput>
  }

  export type ProjectUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    completer?: UserUpdateOneWithoutCompletedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ArtifactUpsertWithoutSubmissionsInput = {
    update: XOR<ArtifactUpdateWithoutSubmissionsInput, ArtifactUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<ArtifactCreateWithoutSubmissionsInput, ArtifactUncheckedCreateWithoutSubmissionsInput>
    where?: ArtifactWhereInput
  }

  export type ArtifactUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: ArtifactWhereInput
    data: XOR<ArtifactUpdateWithoutSubmissionsInput, ArtifactUncheckedUpdateWithoutSubmissionsInput>
  }

  export type ArtifactUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutArtifactsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedArtifactsNestedInput
    approver?: UserUpdateOneWithoutApprovedArtifactsNestedInput
    versions?: ArtifactVersionUpdateManyWithoutArtifactNestedInput
  }

  export type ArtifactUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versions?: ArtifactVersionUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type UserUpsertWithoutSubmissionsInput = {
    update: XOR<UserUpdateWithoutSubmissionsInput, UserUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubmissionsInput, UserUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUpdateManyWithoutApproverNestedInput
    createdIntegrations?: IntegrationUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    themePreference?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    projectMemberships?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    createdProjects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    completedProjects?: ProjectUncheckedUpdateManyWithoutCompleterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    uploadedDocuments?: ProjectDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdKnowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutCreatorNestedInput
    createdArtifacts?: ArtifactUncheckedUpdateManyWithoutCreatorNestedInput
    approvedArtifacts?: ArtifactUncheckedUpdateManyWithoutApproverNestedInput
    createdIntegrations?: IntegrationUncheckedUpdateManyWithoutCreatorNestedInput
    uploadedKBDocuments?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderNestedInput
    createdArtifactVersions?: ArtifactVersionUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    roleId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type ProjectMemberCreateManyUserInput = {
    id?: string
    projectId: string
    addedById: string
    joinedAt?: Date | string
  }

  export type ProjectCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    completedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectCreateManyCompleterInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    value?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    progressPercentage?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    title: string
    message: string
    read?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resourceType: string
    resourceId: string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ProjectDocumentCreateManyUploaderInput = {
    id?: string
    projectId: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    rawFileLocation: string
    processedFileLocation?: string | null
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type KnowledgeBaseCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    projectId?: string | null
    documentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
  }

  export type ArtifactCreateManyCreatorInput = {
    id?: string
    projectId: string
    name: string
    type: string
    category: string
    status?: string
    approvedBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type ArtifactCreateManyApproverInput = {
    id?: string
    projectId: string
    name: string
    type: string
    category: string
    status?: string
    createdBy: string
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type SubmissionRecordCreateManyUserInput = {
    id?: string
    projectId: string
    artifactId: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntegrationCreateManyCreatorInput = {
    id?: string
    type: string
    name: string
    configuration: JsonNullValueInput | InputJsonValue
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseDocumentCreateManyUploaderInput = {
    id?: string
    knowledgeBaseId: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    s3Bucket: string
    s3Key: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: string | null
  }

  export type ArtifactVersionCreateManyCreatorInput = {
    id?: string
    artifactId: string
    versionNumber: number
    content: JsonNullValueInput | InputJsonValue
    location?: string | null
    createdAt?: Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProjectMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedById?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    addedById?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    addedById?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completer?: UserUpdateOneWithoutCompletedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectUpdateWithoutCompleterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    creator?: UserUpdateOneRequiredWithoutCreatedProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCompleterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
    knowledgeBases?: KnowledgeBaseUncheckedUpdateManyWithoutProjectNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutProjectNestedInput
    workflowExecutions?: WorkflowExecutionUncheckedUpdateManyWithoutProjectNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCompleterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progressPercentage?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    previousState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDocumentUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    rawFileLocation?: StringFieldUpdateOperationsInput | string
    processedFileLocation?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type ProjectDocumentUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    rawFileLocation?: StringFieldUpdateOperationsInput | string
    processedFileLocation?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectDocumentUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    rawFileLocation?: StringFieldUpdateOperationsInput | string
    processedFileLocation?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type KnowledgeBaseUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    documentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    project?: ProjectUpdateOneWithoutKnowledgeBasesNestedInput
    documents?: KnowledgeBaseDocumentUpdateManyWithoutKnowledgeBaseNestedInput
    permissions?: KnowledgeBasePermissionUpdateManyWithoutKnowledgeBaseNestedInput
  }

  export type KnowledgeBaseUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    documentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutKnowledgeBaseNestedInput
    permissions?: KnowledgeBasePermissionUncheckedUpdateManyWithoutKnowledgeBaseNestedInput
  }

  export type KnowledgeBaseUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    documentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArtifactUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutArtifactsNestedInput
    approver?: UserUpdateOneWithoutApprovedArtifactsNestedInput
    versions?: ArtifactVersionUpdateManyWithoutArtifactNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutArtifactNestedInput
  }

  export type ArtifactUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versions?: ArtifactVersionUncheckedUpdateManyWithoutArtifactNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type ArtifactUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArtifactUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutArtifactsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedArtifactsNestedInput
    versions?: ArtifactVersionUpdateManyWithoutArtifactNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutArtifactNestedInput
  }

  export type ArtifactUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versions?: ArtifactVersionUncheckedUpdateManyWithoutArtifactNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type ArtifactUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubmissionRecordUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutSubmissionsNestedInput
    artifact?: ArtifactUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionRecordUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntegrationUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    configuration?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: IntegrationLogUpdateManyWithoutIntegrationNestedInput
  }

  export type IntegrationUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    configuration?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: IntegrationLogUncheckedUpdateManyWithoutIntegrationNestedInput
  }

  export type IntegrationUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    configuration?: JsonNullValueInput | InputJsonValue
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseDocumentUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: NullableStringFieldUpdateOperationsInput | string | null
    knowledgeBase?: KnowledgeBaseUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type KnowledgeBaseDocumentUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeBaseId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KnowledgeBaseDocumentUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeBaseId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArtifactVersionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifact?: ArtifactUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type ArtifactVersionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactVersionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyRoleInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
    assignedBy?: string | null
  }

  export type PermissionCreateManyRoleInput = {
    id?: string
    resource: string
    action: string
    createdAt?: Date | string
  }

  export type KnowledgeBasePermissionCreateManyRoleInput = {
    id?: string
    knowledgeBaseId: string
    userId?: string | null
    permissionType: string
    grantedAt?: Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBasePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionType?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeBase?: KnowledgeBaseUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type KnowledgeBasePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeBaseId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionType?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBasePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeBaseId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionType?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: string
    userId: string
    addedById: string
    joinedAt?: Date | string
  }

  export type ProjectDocumentCreateManyProjectInput = {
    id?: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    rawFileLocation: string
    processedFileLocation?: string | null
    uploadedBy: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type KnowledgeBaseCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    scope: string
    documentCount?: number
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vectorStoreId?: string | null
  }

  export type ArtifactCreateManyProjectInput = {
    id?: string
    name: string
    type: string
    category: string
    status?: string
    createdBy: string
    approvedBy?: string | null
    createdAt?: Date | string
    approvedAt?: Date | string | null
  }

  export type WorkflowExecutionCreateManyProjectInput = {
    id?: string
    status?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    lastUpdatedAt?: Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    results?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordCreateManyProjectInput = {
    id?: string
    artifactId: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedBy: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedById?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectMembershipsNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedById?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedById?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDocumentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    rawFileLocation?: StringFieldUpdateOperationsInput | string
    processedFileLocation?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploader?: UserUpdateOneRequiredWithoutUploadedDocumentsNestedInput
  }

  export type ProjectDocumentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    rawFileLocation?: StringFieldUpdateOperationsInput | string
    processedFileLocation?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProjectDocumentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    rawFileLocation?: StringFieldUpdateOperationsInput | string
    processedFileLocation?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type KnowledgeBaseUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    documentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedKnowledgeBasesNestedInput
    documents?: KnowledgeBaseDocumentUpdateManyWithoutKnowledgeBaseNestedInput
    permissions?: KnowledgeBasePermissionUpdateManyWithoutKnowledgeBaseNestedInput
  }

  export type KnowledgeBaseUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    documentCount?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: KnowledgeBaseDocumentUncheckedUpdateManyWithoutKnowledgeBaseNestedInput
    permissions?: KnowledgeBasePermissionUncheckedUpdateManyWithoutKnowledgeBaseNestedInput
  }

  export type KnowledgeBaseUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: StringFieldUpdateOperationsInput | string
    documentCount?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArtifactUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedArtifactsNestedInput
    approver?: UserUpdateOneWithoutApprovedArtifactsNestedInput
    versions?: ArtifactVersionUpdateManyWithoutArtifactNestedInput
    submissions?: SubmissionRecordUpdateManyWithoutArtifactNestedInput
  }

  export type ArtifactUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versions?: ArtifactVersionUncheckedUpdateManyWithoutArtifactNestedInput
    submissions?: SubmissionRecordUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type ArtifactUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkflowExecutionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    agentTasks?: AgentTaskUpdateManyWithoutWorkflowExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
    agentTasks?: AgentTaskUncheckedUpdateManyWithoutWorkflowExecutionNestedInput
  }

  export type WorkflowExecutionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    results?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
    artifact?: ArtifactUpdateOneRequiredWithoutSubmissionsNestedInput
    user?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionRecordUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AgentTaskCreateManyWorkflowExecutionInput = {
    id?: string
    initiatedBy: string
    handledBy?: string | null
    completedBy?: string | null
    agent: string
    status?: string
    sequenceOrder: number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    executionTimeSeconds?: number | null
  }

  export type AgentTaskUpdateWithoutWorkflowExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionTimeSeconds?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AgentTaskUncheckedUpdateWithoutWorkflowExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionTimeSeconds?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AgentTaskUncheckedUpdateManyWithoutWorkflowExecutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatedBy?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    completedBy?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sequenceOrder?: IntFieldUpdateOperationsInput | number
    inputData?: NullableJsonNullValueInput | InputJsonValue
    outputData?: NullableJsonNullValueInput | InputJsonValue
    taskConfig?: NullableJsonNullValueInput | InputJsonValue
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    executionTimeSeconds?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ArtifactVersionCreateManyArtifactInput = {
    id?: string
    versionNumber: number
    content: JsonNullValueInput | InputJsonValue
    location?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type SubmissionRecordCreateManyArtifactInput = {
    id?: string
    projectId: string
    portalName: string
    submissionId?: string | null
    status: string
    submittedBy: string
    submittedAt?: Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ArtifactVersionUpdateWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedArtifactVersionsNestedInput
  }

  export type ArtifactVersionUncheckedUpdateWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactVersionUncheckedUpdateManyWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    content?: JsonNullValueInput | InputJsonValue
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionRecordUpdateWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
    project?: ProjectUpdateOneRequiredWithoutSubmissionsNestedInput
    user?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionRecordUncheckedUpdateWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SubmissionRecordUncheckedUpdateManyWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    portalName?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedBy?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionMetadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type KnowledgeBaseDocumentCreateManyKnowledgeBaseInput = {
    id?: string
    fileName: string
    filePath: string
    fileType: string
    fileSize: bigint | number
    s3Bucket: string
    s3Key: string
    uploadedBy: string
    uploadedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: string | null
  }

  export type KnowledgeBasePermissionCreateManyKnowledgeBaseInput = {
    id?: string
    userId?: string | null
    roleId?: string | null
    permissionType: string
    grantedAt?: Date | string
  }

  export type KnowledgeBaseDocumentUpdateWithoutKnowledgeBaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: NullableStringFieldUpdateOperationsInput | string | null
    uploader?: UserUpdateOneRequiredWithoutUploadedKBDocumentsNestedInput
  }

  export type KnowledgeBaseDocumentUncheckedUpdateWithoutKnowledgeBaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KnowledgeBaseDocumentUncheckedUpdateManyWithoutKnowledgeBaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    vectorIds?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KnowledgeBasePermissionUpdateWithoutKnowledgeBaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionType?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutKbPermissionsNestedInput
  }

  export type KnowledgeBasePermissionUncheckedUpdateWithoutKnowledgeBaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionType?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBasePermissionUncheckedUpdateManyWithoutKnowledgeBaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    permissionType?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationLogCreateManyIntegrationInput = {
    id?: string
    action: string
    status: string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: string | null
    createdAt?: Date | string
  }

  export type IntegrationLogUpdateWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationLogUncheckedUpdateWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationLogUncheckedUpdateManyWithoutIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requestData?: NullableJsonNullValueInput | InputJsonValue
    responseData?: NullableJsonNullValueInput | InputJsonValue
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}